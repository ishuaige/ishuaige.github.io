<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Docker高级篇</title>
      <link href="/coderbin/b3e19a84.html"/>
      <url>/coderbin/b3e19a84.html</url>
      
        <content type="html"><![CDATA[<p>尚硅谷 2022 版 Docker 实战教程官方课程资料：<a href="https://pan.baidu.com/s/1AyYbnDRoD-m2xBPvfvjh7Q?pwd=8gfh">https://pan.baidu.com/s/1AyYbnDRoD-m2xBPvfvjh7Q?pwd=8gfh</a><br>提取码：8gfh</p><h1 id="Docker-高级"><a href="#Docker-高级" class="headerlink" title="Docker 高级"></a>Docker 高级</h1><h1 id="一-DockerFile-解析"><a href="#一-DockerFile-解析" class="headerlink" title="一. DockerFile 解析"></a>一. DockerFile 解析</h1><h2 id="1-DockerFile-是什么"><a href="#1-DockerFile-是什么" class="headerlink" title="1. DockerFile 是什么"></a>1. DockerFile 是什么</h2><p>官网地址：<a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></p><p>Dockerfile 是用来构建 Docker 镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220820205504549.png" alt="image-20220820205504549"></p><p>构建三步骤：</p><ul><li>编写 Dockerfile 文件</li><li>docker build 命令构建镜像</li><li>docker run 依镜像运行容器实例</li></ul><h2 id="2-DockerFile-构建过程解析"><a href="#2-DockerFile-构建过程解析" class="headerlink" title="2. DockerFile 构建过程解析"></a>2. DockerFile 构建过程解析</h2><h3 id="2-1-Dockerfile-内容基础知识"><a href="#2-1-Dockerfile-内容基础知识" class="headerlink" title="2.1 Dockerfile 内容基础知识"></a>2.1 Dockerfile 内容基础知识</h3><ol><li>每条保留字指令都必须为大写字母且后面要跟随至少一个参数</li><li>指令按照从上到下，顺序执行</li><li>”#“ 表示注释</li><li>每条指令都会创建一个新的镜像层并对镜像进行提交</li></ol><h3 id="2-2-Docker-执行-Dockerfile-的大致流程"><a href="#2-2-Docker-执行-Dockerfile-的大致流程" class="headerlink" title="2.2 Docker 执行 Dockerfile 的大致流程"></a>2.2 Docker 执行 Dockerfile 的大致流程</h3><ol><li>docker 从基础镜像运行一个容器</li><li>执行一条指令并对容器作出修改</li><li>执行类似 docker commit 的操作提交一个新的镜像层</li><li>docker 再基于刚提交的镜像运行一个新容器</li><li>执行 dockerfile 中的下一条指令直到所有指令都执行完成</li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220820210155728.png" alt="image-20220820210155728"></p><h2 id="3-Dockerfile-常见保留字"><a href="#3-Dockerfile-常见保留字" class="headerlink" title="3. Dockerfile 常见保留字"></a>3. Dockerfile 常见保留字</h2><table><thead><tr><th>保留字</th><th>说明</th></tr></thead><tbody><tr><td>FROM</td><td>基础镜像，当前新镜像是基于哪个镜像的，指定一个已经存在的镜像作为模板，第一条必须是 from</td></tr><tr><td>MAINTAINER</td><td>镜像维护者的姓名和邮箱地址</td></tr><tr><td>RUN</td><td>容器构建时需要运行的命令，RUN 是在 docker build 时运行（RUN yum -y install vim）</td></tr><tr><td>EXPOSE</td><td>当前容器对外暴露出的端口</td></tr><tr><td>WORKDIR</td><td>指定在创建容器后，终端默认登陆的进来工作目录，一个落脚点</td></tr><tr><td>USER</td><td>指定该镜像以什么样的用户去执行，如果都不指定，默认是 root，一般不指定</td></tr><tr><td>ENV</td><td>用来在构建镜像过程中设置环境变量</td></tr><tr><td>ADD</td><td>将宿主机目录下的文件拷贝进镜像且会自动处理 URL 和解压 tar 压缩包</td></tr><tr><td>COPY</td><td>类似 ADD，拷贝文件和目录到镜像中。将从构建上下文目录中 &lt;源路径&gt; 的文件&#x2F;目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置，COPY &lt;src 源路径&gt; &lt;dest 目标路径&gt;</td></tr><tr><td>VOLUME</td><td>容器数据卷，用于数据保存和持久化工作</td></tr><tr><td>CMD</td><td>指定容器启动后的要干的事情，Dockerfile 中可以有多个 CMD 指令，<strong>但只有最后一个生效，CMD 会被 docker run 之后的参数替换</strong></td></tr><tr><td>ENTRYPOINT</td><td>也是用来指定一个容器启动时要运行的命令，类似于 CMD 指令，<strong>但是 ENTRYPOINT 不会被 docker run 后面的命令覆盖</strong>，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序</td></tr></tbody></table><h2 id="4-案例"><a href="#4-案例" class="headerlink" title="4. 案例"></a>4. 案例</h2><p>需求：在 CentOS7 镜像中添加 vim，ifconfig，jdk8，并生成一个新的自定义镜像 mycentosjava8</p><ol><li>下载 jdk，并且移到虚拟机下</li><li>在<strong>jdk 所在目录下</strong>编写 Dockerfile 文件(注意：D 要大写)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">MAINTAINER zzyy&lt;zzyybs@126.com&gt;</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line">#安装vim编辑器</span><br><span class="line">RUN yum -y install vim</span><br><span class="line">#安装ifconfig命令查看网络IP</span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line">#安装java8及lib库</span><br><span class="line">RUN yum -y install glibc.i686</span><br><span class="line">RUN mkdir /usr/local/java</span><br><span class="line">#ADD 是相对路径jar,把jdk-8u171-linux-x64.tar.gz添加到容器中,安装包必须要和Dockerfile文件在同一位置</span><br><span class="line">ADD jdk-8u171-linux-x64.tar.gz /usr/local/java/</span><br><span class="line">#配置java环境变量</span><br><span class="line">ENV JAVA_HOME /usr/local/java/jdk1.8.0_171</span><br><span class="line">ENV JRE_HOME $JAVA_HOME/jre</span><br><span class="line">ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH</span><br><span class="line">ENV PATH $JAVA_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">CMD echo $MYPATH</span><br><span class="line">CMD echo &quot;success--------------ok&quot;</span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure><ol start="3"><li>构建</li></ol><blockquote><p>docker build -t 新镜像名字:TAG .</p><p>注意：有个空格，有个 . 在后面</p></blockquote><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220820211646875.png" alt="image-20220820211646875"></p><ol start="4"><li>运行新镜像</li></ol><blockquote><p>docker run -it 新镜像名字:TAG</p></blockquote><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220820211728653.png"></p><h2 id="5-虚悬镜像"><a href="#5-虚悬镜像" class="headerlink" title="5. 虚悬镜像"></a>5. 虚悬镜像</h2><p>仓库名、标签都是&lt;none&gt;的镜像，俗称 dangling image</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220820211845643.png" alt="image-20220820211845643"></p><h3 id="5-1-查看虚悬镜像"><a href="#5-1-查看虚悬镜像" class="headerlink" title="5.1 查看虚悬镜像"></a>5.1 查看虚悬镜像</h3><blockquote><p>docker image ls -f dangling&#x3D;true</p></blockquote><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220820211914803.png" alt="image-20220820211914803"></p><h3 id="5-2-删除虚悬镜像"><a href="#5-2-删除虚悬镜像" class="headerlink" title="5.2 删除虚悬镜像"></a>5.2 删除虚悬镜像</h3><blockquote><p>docker image prune</p></blockquote><p>虚悬镜像已经没用了，可以删除。</p><h1 id="二-Docker-微服务实战"><a href="#二-Docker-微服务实战" class="headerlink" title="二. Docker 微服务实战"></a>二. Docker 微服务实战</h1><h2 id="1-新建一个普通微服务模块"><a href="#1-新建一个普通微服务模块" class="headerlink" title="1.新建一个普通微服务模块"></a>1.新建一个普通微服务模块</h2><p>不是主要内容，省略</p><h2 id="2-通过-Dockerfile-发布部署到-Docker-容器"><a href="#2-通过-Dockerfile-发布部署到-Docker-容器" class="headerlink" title="2.通过 Dockerfile 发布部署到 Docker 容器"></a>2.通过 Dockerfile 发布部署到 Docker 容器</h2><ol><li>在 IDEA 中利用 maven 打好 jar 包</li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220820212326092.png" alt="image-20220820212326092"></p><ol start="2"><li>编写 Dockerfile</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 基础镜像使用java</span><br><span class="line">FROM java:8</span><br><span class="line"># 作者</span><br><span class="line">MAINTAINER zzyy</span><br><span class="line"># VOLUME 指定临时文件目录为/tmp，在主机/var/lib/docker目录下创建了一个临时文件并链接到容器的/tmp</span><br><span class="line">VOLUME /tmp</span><br><span class="line"># 将jar包添加到容器中并更名为zzyy_docker.jar</span><br><span class="line">ADD docker_boot-0.0.1-SNAPSHOT.jar zzyy_docker.jar</span><br><span class="line"># 运行jar包</span><br><span class="line">RUN bash -c &#x27;touch /zzyy_docker.jar&#x27;</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/zzyy_docker.jar&quot;]</span><br><span class="line">#暴露6001端口作为微服务</span><br><span class="line">EXPOSE 6001</span><br></pre></td></tr></table></figure><ol start="3"><li>把 jar 包和 Dockerfile 放到同一个目录下</li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220820212434019.png" alt="image-20220820212434019"></p><ol start="4"><li>构建镜像</li></ol><blockquote><p>docker build -t zzyy_docker:1.6 .</p></blockquote><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220820212511503.png" alt="image-20220820212511503"></p><ol start="5"><li>运行镜像</li></ol><blockquote><p>docker run -d -p 6001:6001 zzyy_docker:1.6</p></blockquote><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220820212628318.png" alt="image-20220820212628318"></p><ol start="6"><li>访问测试</li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220820212645444.png" alt="image-20220820212645444"></p><h1 id="三-Docker-网络"><a href="#三-Docker-网络" class="headerlink" title="三. Docker 网络"></a>三. Docker 网络</h1><h2 id="1-Docker-网络是什么"><a href="#1-Docker-网络是什么" class="headerlink" title="1. Docker 网络是什么"></a>1. Docker 网络是什么</h2><p>当我们启动 Docker 后，会产生一个名为 docker0 的虚拟网桥</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220820212848431.png" alt="image-20220820212848431"></p><h2 id="2-Docker-网络常用基本命令"><a href="#2-Docker-网络常用基本命令" class="headerlink" title="2. Docker 网络常用基本命令"></a>2. Docker 网络常用基本命令</h2><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220820212956626.png" alt="image-20220820212956626"></p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>docker network ls</td><td>查看网络</td></tr><tr><td>docker network inspect XXX 网络名字</td><td>查看网络源数据</td></tr><tr><td>docker network rm XXX 网络名字</td><td>删除网络</td></tr></tbody></table><h2 id="3-Docker-网络能干嘛"><a href="#3-Docker-网络能干嘛" class="headerlink" title="3. Docker 网络能干嘛"></a>3. Docker 网络能干嘛</h2><ul><li>容器间的互联和通信以及端口映射</li><li>容器 IP 变动时候可以<strong>通过服务名直接网络通信</strong>而不受到影响</li></ul><h2 id="4-网络模式"><a href="#4-网络模式" class="headerlink" title="4. 网络模式"></a>4. 网络模式</h2><ul><li><strong>bridge 模式：使用–network bridge 指定，默认使用 docker0</strong></li><li>host 模式：使用–network host 指定</li><li>none 模式：使用–network none 指定</li><li>container 模式：使用–network container:NAME 或者容器 ID 指定</li></ul><p>docker 容器内部的 ip 是有可能会发生改变的</p><h3 id="4-1-bridge"><a href="#4-1-bridge" class="headerlink" title="4.1 bridge"></a>4.1 bridge</h3><p>Docker 服务默认会创建一个 docker0 网桥（其上有一个 docker0 内部接口），该桥接网络的名称为 docker0，它在<strong>内核层</strong>连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到<strong>同一个物理网络</strong>。Docker 默认指定了 docker0 接口 的 IP 地址和子网掩码，<strong>让主机和容器之间可以通过网桥相互通信</strong>。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220820213446573.png" alt="image-20220820213446573"></p><h3 id="4-2-host"><a href="#4-2-host" class="headerlink" title="4.2 host"></a>4.2 host</h3><p>直接使用宿主机的 IP 地址与外界进行通信，不再需要额外进行 NAT 转换。容器将<strong>不会获得一个独立的 Network Namespace</strong>， 而是和宿主机共用一个 Network Namespace。<strong>容器将不会虚拟出自己的网卡而是使用宿主机的 IP 和端口。</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220820213541957.png"></p><h3 id="4-3-none"><a href="#4-3-none" class="headerlink" title="4.3 none"></a>4.3 none</h3><p>在 none 模式下，并不为 Docker 容器进行任何网络配置。 也就是说，<strong>这个 Docker 容器没有网卡、IP、路由等信息</strong>，只有一个 lo,需要我们自己为 Docker 容器添加网卡、配置 IP 等。</p><h3 id="4-4-container"><a href="#4-4-container" class="headerlink" title="4.4 container"></a>4.4 container</h3><p>新建的容器和已经存在的一个容器共享一个网络 ip 配置而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220820213740450.png" alt="image-20220820213740450"></p><h2 id="5-自定义网络"><a href="#5-自定义网络" class="headerlink" title="5. 自定义网络"></a>5. 自定义网络</h2><p>利用 Docker 自带的 bridge 网络模式，在容器内部之能按照 IP 互相 ping 通，但是我们的 ip 地址是有可能不断变化的，这就导致我们不能硬编码写死在程序中，怎么解决这个问题呢？</p><ul><li><strong>自定义网络本身就维护好了主机名和 ip 的对应关系（ip 和域名都能通）</strong></li></ul><ol><li>新建网络</li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220820214038698.png" alt="image-20220820214038698"></p><ol start="2"><li>新建容器加入新建的自定义网络</li></ol><blockquote><p>docker run -d -p 8081:8080 –network zzyy_network –name tomcat81 billygoo&#x2F;tomcat8-jdk8</p><p>docker run -d -p 8082:8080 –network zzyy_network –name tomcat82 billygoo&#x2F;tomcat8-jdk8</p></blockquote><ol start="3"><li>互相 ping</li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220820214120397.png" alt="image-20220820214120397"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220820214125060.png" alt="image-20220820214125060"></p><p>可以看到能够通过服务名来 Ping 通。</p><h1 id="四-Docker-compose-容器编排"><a href="#四-Docker-compose-容器编排" class="headerlink" title="四. Docker-compose 容器编排"></a>四. Docker-compose 容器编排</h1><p>目前我们的容器较少，一个一个启动也不那么费劲，但是我们可以试想，如果我的一个项目，用到了 Mysql，Redis，还有各个微服务，那么每次启动都要一个一个启动，而且有时还需要保证启动的顺序，是不是很头疼，那么我们就需要一个“总管”，能够帮我们一次性的按照顺序的启动我们需要的容器。</p><h2 id="1-Docker-compose-是什么"><a href="#1-Docker-compose-是什么" class="headerlink" title="1. Docker-compose 是什么"></a>1. Docker-compose 是什么</h2><p>Compose 是 Docker 公司推出的一个工具软件，可以管理多个 Docker 容器组成一个应用。你需要定义一个 YAML 格式的配置文件 docker-compose.yml，<strong>写好多个容器之间的调用关系</strong>。然后，<strong>只要一个命令</strong>，就能<strong>同时启动&#x2F;关闭这些容器</strong>。</p><p>Compose 允许用户通过一个单独的<strong>docker-compose.yml 模板文件</strong>（YAML 格式）来<strong>定义一组相关联的应用容器为一个项目（project）。</strong></p><p>可以很容易地用一个配置文件定义一个多容器的应用，然后使用一条指令安装这个应用的所有依赖，完成构建。Docker-Compose 解决了容器与容器之间如何管理编排的问题。</p><p>官网：<a href="https://docs.docker.com/compose/compose-file/compose-file-v3/">https://docs.docker.com/compose/compose-file/compose-file-v3/</a></p><p>官网下载：<a href="https://docs.docker.com/compose/install/">https://docs.docker.com/compose/install/</a></p><h2 id="2-Compose-核心概念"><a href="#2-Compose-核心概念" class="headerlink" title="2. Compose 核心概念"></a>2. Compose 核心概念</h2><p>一文件：docker-compose.yml</p><p>两要素：</p><ul><li>服务（service）：一个个应用容器实例，比如订单微服务、库存微服务、mysql 容器、nginx 容器或者 redis 容器</li><li>工程（project）：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。</li></ul><h2 id="3-Compose-使用步骤"><a href="#3-Compose-使用步骤" class="headerlink" title="3. Compose 使用步骤"></a>3. Compose 使用步骤</h2><ul><li>编写 Dockerfile 定义各个微服务应用并构建出对应的镜像文件</li><li>使用 docker-compose.yml 定义一个完整业务单元，安排好整体应用中的各个容器服务。</li><li>最后，执行<strong>docker-compose up</strong>命令 来启动并运行整个应用程序，完成一键部署上线</li></ul><h2 id="4-Compose-常用命令"><a href="#4-Compose-常用命令" class="headerlink" title="4. Compose 常用命令"></a>4. Compose 常用命令</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>docker-compose -h</td><td>查看帮助</td></tr><tr><td>docker-compose up</td><td>启动所有 docker-compose 服务</td></tr><tr><td><strong>docker-compose up -d</strong></td><td><strong>启动所有 docker-compose 服务并后台运行</strong></td></tr><tr><td><strong>docker-compose down</strong></td><td><strong>停止并删除容器、网络、卷、镜像。</strong></td></tr><tr><td>docker-compose exec yml 里面的服务 id</td><td>进入容器实例内部 docker-compose exec</td></tr><tr><td>docker-compose ps</td><td>展示当前 docker-compose 编排过的运行的所有容器</td></tr><tr><td>docker-compose top</td><td>展示当前 docker-compose 编排过的容器进程</td></tr><tr><td>docker-compose logs yml 里面的服务 id</td><td>查看容器输出日志</td></tr><tr><td><strong>docker-compose config</strong></td><td><strong>检查配置</strong></td></tr></tbody></table><h2 id="5-Compose-编排微服务"><a href="#5-Compose-编排微服务" class="headerlink" title="5. Compose 编排微服务"></a>5. Compose 编排微服务</h2><p>假设一个微服务需要用到 MySQL,Redis…</p><ol><li>docker-compose.yml 文件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  microService:</span><br><span class="line">    image: zzyy_docker:1.6</span><br><span class="line">    container_name: ms01</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;6001:6001&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - /app/microService:/data</span><br><span class="line">    networks:</span><br><span class="line">      - atguigu_net</span><br><span class="line">    depends_on:</span><br><span class="line">      - redis</span><br><span class="line">      - mysql</span><br><span class="line"></span><br><span class="line">  redis:</span><br><span class="line">    image: redis:6.0.8</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;6379:6379&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - /app/redis/redis.conf:/etc/redis/redis.conf</span><br><span class="line">      - /app/redis/data:/data</span><br><span class="line">    networks:</span><br><span class="line">      - atguigu_net</span><br><span class="line">    command: redis-server /etc/redis/redis.conf</span><br><span class="line"></span><br><span class="line">  mysql:</span><br><span class="line">    image: mysql:5.7</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_ROOT_PASSWORD: &#x27;123456&#x27;</span><br><span class="line">      MYSQL_ALLOW_EMPTY_PASSWORD: &#x27;no&#x27;</span><br><span class="line">      MYSQL_DATABASE: &#x27;db2021&#x27;</span><br><span class="line">      MYSQL_USER: &#x27;zzyy&#x27;</span><br><span class="line">      MYSQL_PASSWORD: &#x27;zzyy123&#x27;</span><br><span class="line">    ports:</span><br><span class="line">       - &quot;3306:3306&quot;</span><br><span class="line">    volumes:</span><br><span class="line">       - /app/mysql/db:/var/lib/mysql</span><br><span class="line">       - /app/mysql/conf/my.cnf:/etc/my.cnf</span><br><span class="line">       - /app/mysql/init:/docker-entrypoint-initdb.d</span><br><span class="line">    networks:</span><br><span class="line">      - atguigu_net</span><br><span class="line">    command: --default-authentication-plugin=mysql_native_password #解决外部无法访问</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">   atguigu_net:</span><br></pre></td></tr></table></figure><ol start="2"><li>修改微服务工程</li></ol><p>将配置文件中的 Mysql 和 Redis 的 ip 地址用服务名代替，与 IP 无关</p><ol start="3"><li>执行 docker-compose up 或者 执行 docker-compose up -d</li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220820215426659.png" alt="image-20220820215426659"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220820215433199.png" alt="image-20220820215433199"></p><p>搞定！</p><h1 id="五-可视化工具-Portainer"><a href="#五-可视化工具-Portainer" class="headerlink" title="五.可视化工具 Portainer"></a>五.可视化工具 Portainer</h1><p>Portainer 是一款轻量级的应用，它提供了图形化界面，用于方便地管理 Docker 环境，包括单机环境和集群环境。</p><p>官网</p><ul><li><a href="https://www.portainer.io/">https://www.portainer.io/</a></li><li><a href="https://docs.portainer.io/v/ce-2.9/start/install/server/docker/linux">https://docs.portainer.io/v/ce-2.9/start/install/server/docker/linux</a></li></ul><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><p>参照官网就完事了</p><h1 id="六-Docker-监控-CAdvisor-InfluxDB-Granfana"><a href="#六-Docker-监控-CAdvisor-InfluxDB-Granfana" class="headerlink" title="六.Docker 监控 CAdvisor+InfluxDB+Granfana"></a>六.Docker 监控 CAdvisor+InfluxDB+Granfana</h1><p><a href="https://www.bilibili.com/video/BV1gr4y1U7CY?p=90&vd_source=665476c062292b64fa2949e9c935b109">90<em>CIG 容器重量级监控系统介绍</em>哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Dockerfile </tag>
            
            <tag> 部署微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis高级篇及最佳实践</title>
      <link href="/coderbin/8e0e8ad8.html"/>
      <url>/coderbin/8e0e8ad8.html</url>
      
        <content type="html"><![CDATA[<p><strong>案例参考：黑马程序员</strong></p><h1 id="一-分布式缓存"><a href="#一-分布式缓存" class="headerlink" title="一.分布式缓存"></a>一.分布式缓存</h1><p>– 基于Redis集群解决单机Redis存在的问题</p><p>单机的Redis存在四大问题：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210725144240631.png" alt="image-20210725144240631"></p><h1 id="1-Redis持久化"><a href="#1-Redis持久化" class="headerlink" title="1.Redis持久化"></a>1.Redis持久化</h1><p>Redis持久化分为两种</p><ul><li>RDB持久化</li><li>AOF持久化</li></ul><h2 id="1-1-RDB持久化"><a href="#1-1-RDB持久化" class="headerlink" title="1.1 RDB持久化"></a>1.1 RDB持久化</h2><p>RDB全称Redis Database Backup file（Redis数据备份文件），也就是快照，<strong>把内存中的所有数据存到磁盘上</strong>。故障修复后，读取磁盘文件恢复数据。快照文件为RDB文件，默认存在当前目录。</p><h3 id="1-1-1-什么时候执行RDB"><a href="#1-1-1-什么时候执行RDB" class="headerlink" title="1.1.1 什么时候执行RDB"></a>1.1.1 什么时候执行RDB</h3><p>有四种情况会执行RDB</p><ul><li>执行save命令</li><li>执行bgsave命令</li><li>redis手动关机</li><li>触发执行RDB条件</li></ul><ol><li><strong>save命令</strong></li></ol><p>执行下面的命令，可以立即执行一次RDB：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210725144536958.png" alt="image-20210725144536958"></p><p><strong>save命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞</strong>。只有在数据迁移时可能用到。</p><ol start="2"><li><strong>bgsave命令</strong></li></ol><p>下面的命令可以异步执行RDB：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210725144725943.png" alt="image-20210725144725943"></p><p>这个命令执行后会<strong>开启独立进程完成RDB</strong>，主进程可以持续处理用户请求，不受影响。</p><ol start="3"><li><strong>手动停机redis</strong></li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220805144028355.png" alt="image-20220805144028355"></p><ol start="4"><li><strong>触发执行RDB条件</strong></li></ol><p>Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 900秒内，如果至少有1个key被修改，则执行bgsave ， 如果是save &quot;&quot; 则表示禁用RDB</span></span><br><span class="line"><span class="attr">save</span> <span class="string">900 1  </span></span><br><span class="line"><span class="attr">save</span> <span class="string">300 10  </span></span><br><span class="line"><span class="attr">save</span> <span class="string">60 10000 </span></span><br></pre></td></tr></table></figure><p>RDB的其它配置也可以在redis.conf文件中设置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱</span></span><br><span class="line"><span class="attr">rdbcompression</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># RDB文件名称</span></span><br><span class="line"><span class="attr">dbfilename</span> <span class="string">dump.rdb  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 文件保存的路径目录</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">./ </span></span><br></pre></td></tr></table></figure><h3 id="1-1-2-RDB原理"><a href="#1-1-2-RDB原理" class="headerlink" title="1.1.2 RDB原理"></a>1.1.2 RDB原理</h3><p>bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。</p><p><strong>fork采用的是copy-on-write技术：</strong></p><ul><li>当主进程执行读操作时，访问共享内存；</li><li>当主进程执行写操作时，则会拷贝一份数据，执行写操作。</li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210725151319695.png" alt="image-20210725151319695"></p><h3 id="1-1-3-总结"><a href="#1-1-3-总结" class="headerlink" title="1.1.3 总结"></a>1.1.3 总结</h3><p><strong>RDB方式bgsave的基本流程？</strong></p><ul><li>fork主进程得到一个子进程，共享内存空间</li><li>子进程读取内存数据并写入新的RDB文件</li><li>用新RDB文件替换旧的RDB文件</li></ul><p><strong>RDB会在什么时候执行？save 60 1000代表什么含义？</strong></p><ul><li>默认是服务停止时</li><li>代表60秒内至少执行1000次修改则触发RDB</li></ul><p><strong>RDB的缺点？</strong></p><ul><li>RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险</li><li>fork子进程、压缩、写出RDB文件都比较耗时</li></ul><h2 id="1-2-AOP持久化"><a href="#1-2-AOP持久化" class="headerlink" title="1.2 AOP持久化"></a>1.2 AOP持久化</h2><h3 id="1-2-1-AOP原理"><a href="#1-2-1-AOP原理" class="headerlink" title="1.2.1 AOP原理"></a>1.2.1 AOP原理</h3><p>AOF：Append Only File（追加文件），就是把redis的每一条命令都记录在AOF文件中，相当于命令日志文件，故障恢复后，执行每一条命令达到恢复数据的目的。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210725151543640.png" alt="image-20210725151543640"></p><h3 id="1-2-2-AOF配置"><a href="#1-2-2-AOF配置" class="headerlink" title="1.2.2 AOF配置"></a>1.2.2 AOF配置</h3><p>AOF默认是关闭的，通过修改配置文件redis.conf，来开启AOF</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是否开启AOF功能，默认是no</span></span><br><span class="line"><span class="attr">appendonly</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"># AOF文件的名称</span></span><br><span class="line"><span class="attr">appendfilename</span> <span class="string">&quot;appendonly.aof&quot;</span></span><br></pre></td></tr></table></figure><p>AOF的命令记录的频率也可以通过redis.conf文件来配：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 表示每执行一次写命令，立即记录到AOF文件</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">always </span></span><br><span class="line"><span class="comment"># 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">everysec </span></span><br><span class="line"><span class="comment"># 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">no</span></span><br></pre></td></tr></table></figure><p>三种策略对比：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210725151654046.png" alt="image-20210725151654046"></p><h3 id="1-2-3-AOF文件重写"><a href="#1-2-3-AOF文件重写" class="headerlink" title="1.2.3.AOF文件重写"></a>1.2.3.AOF文件重写</h3><p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210725151729118.png" alt="image-20210725151729118"></p><p>如图，AOF原本有三个命令，但是<code>set num 123 和 set num 666</code>都是对num的操作，第二次会覆盖第一次的值，因此第一个命令记录下来没有意义。</p><p>所以重写命令后，AOF文件内容就是：<code>mset name jack num 666</code></p><p>Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AOF文件比上次文件 增长超过多少百分比则触发重写</span></span><br><span class="line"><span class="attr">auto-aof-rewrite-percentage</span> <span class="string">100</span></span><br><span class="line"><span class="comment"># AOF文件体积最小多大以上才触发重写 </span></span><br><span class="line"><span class="attr">auto-aof-rewrite-min-size</span> <span class="string">64mb </span></span><br></pre></td></tr></table></figure><h2 id="1-3-RDB与AOF对比"><a href="#1-3-RDB与AOF对比" class="headerlink" title="1.3.RDB与AOF对比"></a>1.3.RDB与AOF对比</h2><p>RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会<strong>结合</strong>两者来使用。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210725151940515.png" alt="image-20210725151940515"></p><h1 id="2-Redis主从同步"><a href="#2-Redis主从同步" class="headerlink" title="2.Redis主从同步"></a>2.Redis主从同步</h1><h2 id="2-1-搭建主从架构"><a href="#2-1-搭建主从架构" class="headerlink" title="2.1 搭建主从架构"></a>2.1 搭建主从架构</h2><p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220808205244604.png" alt="image-20220808205244604"></p><h3 id="2-1-1-准备实例和配置"><a href="#2-1-1-准备实例和配置" class="headerlink" title="2.1.1 准备实例和配置"></a>2.1.1 准备实例和配置</h3><p>要在一台虚拟机上开启3个实例，必须准备三个不同的配置文件和目录。</p><p>假设我们这里准备的端口为7001，7002，7003，其中7001作为主节点。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220808210045090.png" alt="image-20220808210045090"></p><p>这里注意修改每个实例的配置文件。</p><ol><li><p>将持久化模式改为RDB模式</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220808205924412.png" alt="image-20220808205924412"></p></li><li><p>修改端口，修改数据保存位置（将<code>dir ./</code>改到对应的实例位置）</p></li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220808210156738.png" alt="image-20220808210156738"></p><ol start="3"><li>修改每个实例的声明ip，因为虚拟机本身有多个ip，避免混乱，将每个实例指定ip</li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220808210254901.png" alt="image-20220808210254901"></p><ol start="4"><li>启动每个实例</li></ol><h3 id="2-1-2-开启主从关系"><a href="#2-1-2-开启主从关系" class="headerlink" title="2.1.2 开启主从关系"></a>2.1.2 开启主从关系</h3><p>配置主从关系有<strong>临时和永久</strong>两种方法：</p><ul><li>修改配置文件（永久生效）<ul><li>在redis.conf中添加一行配置：<code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></li></ul></li><li>使用redis-cli客户端连接到redis服务，执行 <strong>slaveof(5.0以前)&#x2F;replicaof</strong> 命令（重启失效）:<ul><li>该命令在<strong>从机</strong>上输入</li></ul></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure><h2 id="2-2-数据同步原理"><a href="#2-2-数据同步原理" class="headerlink" title="2.2 数据同步原理"></a>2.2 数据同步原理</h2><h3 id="2-2-1-全量同步"><a href="#2-2-1-全量同步" class="headerlink" title="2.2.1 全量同步"></a>2.2.1 全量同步</h3><p>主从如果是第一次连接，那么就执行全量同步。</p><p><strong>那么怎么判断是否为第一次连接呢？</strong></p><ul><li><strong>Replication Id</strong>：简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid</li><li><strong>offset</strong>：偏移量，随着记录在repl_baklog中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。</li></ul><p>这里是通过<strong>replid</strong>来判断是否为第一次连接，当连接过后，主节点就会将自己的replid发送给从节点，以后从节点的replid就和主节点一样了。具体过程：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210725152700914.png" alt="image-20210725152700914"></p><p><strong>完整流程描述：</strong></p><ul><li>slave节点请求增量同步</li><li>master节点判断replid，发现不一致，拒绝增量同步</li><li>master将完整内存数据<strong>生成RDB</strong>，发送RDB到slave <strong>（这就是为什么要开启RDB持久化）</strong></li><li>slave清空本地数据，加载master的RDB</li><li><strong>master将RDB期间的命令记录在repl_baklog</strong>，并持续将log中的命令发送给slave</li><li>slave执行接收到的命令，保持与master之间的同步</li></ul><h3 id="2-2-2-增量同步"><a href="#2-2-2-增量同步" class="headerlink" title="2.2.2 增量同步"></a>2.2.2 增量同步</h3><p>全量同步需要生成RDB文件，然后将RDB文件网络传输给slave，成本过高，因此在第一次之后，其他时候大多数都是做<strong>增量同步，即只更新master和slave存在差异的部分数据。</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210725153201086.png" alt="image-20210725153201086"></p><p>那么master怎么知道slave与自己的数据差异在哪里呢?</p><ul><li>这就得说说<strong>repl_baklog文件</strong>了</li></ul><p>repl_baklog文件是一个<strong>环形数组，大小固定。</strong></p><p>repl_baklog中会记录Redis处理过的命令日志及offset，<strong>包括master当前的offset，和slave已经拷贝到的offset</strong>：</p><p><strong>slave与master的offset之间的差异，就是salve需要增量拷贝的数据了。</strong></p><p>随着不断有数据写入，master的offset逐渐变大，slave也不断的拷贝，追赶master的offset，直到数组被填满：：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210725153359022.png" alt="image-20210725153359022"><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210725153524190.png" alt="image-20210725153524190"> <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210725153715910.png" alt="image-20210725153715910"> </p><p>此时，如果有新的数据写入，就会覆盖数组中的旧数据。不过，旧的数据只要是绿色的，说明是已经被同步到slave的数据，即便被覆盖了也没什么影响。因为未同步的仅仅是红色部分。</p><p>但是，如果slave出现网络阻塞，导致master的offset远远超过了slave的offset： </p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210725153937031.png" alt="image-20210725153937031"> </p><p>如果master继续写入新数据，其offset就会覆盖旧的数据，直到将slave现在的offset也覆盖：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210725154155984.png" alt="image-20210725154155984"> </p><p>棕色框中的红色部分，就是尚未同步，但是却已经被覆盖的数据。此时如果slave恢复，需要同步，却发现自己的offset都没有了，无法完成增量同步了。只能做全量同步。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210725154216392.png" alt="image-20210725154216392"></p><h2 id="2-3-主从同步优化"><a href="#2-3-主从同步优化" class="headerlink" title="2.3 主从同步优化"></a>2.3 主从同步优化</h2><p>主从同步可以保证主从数据的一致性，非常重要。</p><p><strong>可以从以下几个方面来优化Redis主从就集群：</strong></p><ul><li>在master中配置repl-diskless-sync yes启用无磁盘复制，避免全量同步时的磁盘IO。</li><li>Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO</li><li>适当提高repl_baklog的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步</li><li>限制一个master上的slave节点数量，如果实在是太多slave，则可以采用主-从-从链式结构，减少master压力</li></ul><p>主从从架构图：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210725154405899.png" alt="image-20210725154405899"></p><h2 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4 小结"></a>2.4 小结</h2><p><strong>简述全量同步和增量同步区别？</strong></p><ul><li>全量同步：master将完整内存数据生成RDB，发送RDB到slave。后续命令则记录在repl_baklog，逐个发送给slave。</li><li>增量同步：slave提交自己的offset到master，master获取repl_baklog中从offset之后的命令给slave</li></ul><p><strong>什么时候执行全量同步？</strong></p><ul><li>slave节点第一次连接master节点时</li><li>slave节点断开时间太久，repl_baklog中的offset已经被覆盖时</li></ul><p><strong>什么时候执行增量同步？</strong></p><ul><li>slave节点断开又恢复，<strong>并且</strong>在repl_baklog中能找到offset时</li></ul><h1 id="3-Redis哨兵模式"><a href="#3-Redis哨兵模式" class="headerlink" title="3.Redis哨兵模式"></a>3.Redis哨兵模式</h1><h2 id="3-1哨兵模式原理"><a href="#3-1哨兵模式原理" class="headerlink" title="3.1哨兵模式原理"></a>3.1哨兵模式原理</h2><h3 id="3-1-1-哨兵集群结构及作用"><a href="#3-1-1-哨兵集群结构及作用" class="headerlink" title="3.1.1 哨兵集群结构及作用"></a>3.1.1 哨兵集群结构及作用</h3><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210725154528072.png" alt="image-20210725154528072" style="zoom: 67%;" /><p>哨兵作用：</p><ul><li><strong>监控</strong>：Sentinel 会不断检查您的master和slave是否按预期工作</li><li><strong>自动故障恢复</strong>：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主</li><li><strong>通知</strong>：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端</li></ul><h3 id="3-1-2-监控原理"><a href="#3-1-2-监控原理" class="headerlink" title="3.1.2 监控原理"></a>3.1.2 监控原理</h3><p>Sentinel基于<strong>心跳机制</strong>监测服务状态，每隔1秒向集群的每个实例发送ping命令：</p><ul><li><p>主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例<strong>主观下线</strong>。</p></li><li><p>客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例<strong>客观下线</strong>。quorum值最好超过Sentinel实例数量的一半。</p></li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210725154632354.png" alt="image-20210725154632354"></p><h3 id="3-1-3-故障恢复原理"><a href="#3-1-3-故障恢复原理" class="headerlink" title="3.1.3 故障恢复原理"></a>3.1.3 故障恢复原理</h3><p>一旦发现master故障，sentinel需要在salve中选择一个作为新的master，选择依据是这样的：</p><ul><li>首先会判断slave节点与master节点断开时间长短，如果超过指定值（down-after-milliseconds * 10）则会排除该slave节点</li><li>然后判断slave节点的slave-priority值，越小优先级越高，如果是0则永不参与选举</li><li><strong>如果slave-prority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高</strong></li><li>最后是判断slave节点的运行id大小，越小优先级越高。</li></ul><p>当选出一个新的master后，该如何实现切换呢？</p><p><strong>流程如下：</strong></p><ul><li>sentinel给备选的slave1节点发送<code>slaveof no one</code>命令，让该节点成为master</li><li>sentinel给所有其它slave发送slaveof 192.168.150.101 7002 命令，让这些slave成为新master的从节点，开始从新的master上同步数据。</li><li>最后，sentinel将故障节点标记为slave，当故障节点恢复后会自动成为新的master的slave节点</li></ul><p><strong>先让新皇登基，然后让旧皇俯首。</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210725154816841.png" alt="image-20210725154816841"></p><h3 id="3-1-4-小结"><a href="#3-1-4-小结" class="headerlink" title="3.1.4.小结"></a>3.1.4.小结</h3><p><strong>Sentinel的三个作用是什么？</strong></p><ul><li>监控</li><li>故障转移</li><li>通知</li></ul><p><strong>Sentinel如何判断一个redis实例是否健康？</strong></p><ul><li>每隔1秒发送一次ping命令，如果超过一定时间没有相向则认为是主观下线</li><li>如果大多数sentinel都认为实例主观下线，则判定服务下线</li></ul><p><strong>故障转移步骤有哪些？</strong></p><ul><li>首先选定一个slave作为新的master，执行slaveof no one</li><li>然后让所有节点都执行slaveof 新master</li><li>修改故障节点配置，添加slaveof 新master</li></ul><h2 id="3-2-搭建哨兵集群"><a href="#3-2-搭建哨兵集群" class="headerlink" title="3.2 搭建哨兵集群"></a>3.2 搭建哨兵集群</h2><p>我们搭建的三个sentinel实例信息如下：</p><table><thead><tr><th>节点</th><th align="center">IP</th><th align="center">PORT</th></tr></thead><tbody><tr><td>s1</td><td align="center">192.168.150.101</td><td align="center">27001</td></tr><tr><td>s2</td><td align="center">192.168.150.101</td><td align="center">27002</td></tr><tr><td>s3</td><td align="center">192.168.150.101</td><td align="center">27003</td></tr></tbody></table><h3 id="3-2-1-准备实例和配置"><a href="#3-2-1-准备实例和配置" class="headerlink" title="3.2.1 准备实例和配置"></a>3.2.1 准备实例和配置</h3><ol><li>创建三个文件夹，名字分别叫s1、s2、s3</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入/tmp目录</span></span><br><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line"><span class="built_in">mkdir</span> s1 s2 s3</span><br></pre></td></tr></table></figure><ol start="2"><li>在s1目录创建一个sentinel.conf文件，添加下面的内容：</li></ol><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">port 27001</span><br><span class="line">sentinel announce-ip 192.168.150.101</span><br><span class="line">sentinel monitor mymaster 192.168.150.101 7001 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 5000</span><br><span class="line">sentinel failover-timeout mymaster 60000</span><br><span class="line">dir &quot;/tmp/s1&quot;</span><br></pre></td></tr></table></figure><p>解读：</p><ul><li><code>port 27001</code>：是当前sentinel实例的端口</li><li><code>sentinel monitor mymaster 192.168.150.101 7001 2</code>：指定主节点信息<ul><li><code>mymaster</code>：主节点名称，自定义，任意写</li><li><code>192.168.150.101 7001</code>：主节点的ip和端口</li><li><code>2</code>：选举master时的quorum值</li></ul></li></ul><p>这里只需要指定主节点的ip和端口即可，他会自动找到其他的子节点。</p><ol start="3"><li>将sentinel.conf拷贝到其他两个目录中，并且修改端口和文件目录。</li></ol><p>（在&#x2F;tmp目录执行下列命令）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式一：逐个拷贝</span></span><br><span class="line"><span class="built_in">cp</span> s1/sentinel.conf s2</span><br><span class="line"><span class="built_in">cp</span> s1/sentinel.conf s3</span><br><span class="line"><span class="comment"># 方式二：管道组合命令，一键拷贝</span></span><br><span class="line"><span class="built_in">echo</span> s2 s3 | xargs -t -n 1 <span class="built_in">cp</span> s1/sentinel.conf</span><br></pre></td></tr></table></figure><p>修改s2、s3两个文件夹内的配置文件，将端口分别修改为27002、27003：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i -e <span class="string">&#x27;s/27001/27002/g&#x27;</span> -e <span class="string">&#x27;s/s1/s2/g&#x27;</span> s2/sentinel.conf</span><br><span class="line">sed -i -e <span class="string">&#x27;s/27001/27003/g&#x27;</span> -e <span class="string">&#x27;s/s1/s3/g&#x27;</span> s3/sentinel.conf</span><br></pre></td></tr></table></figure><ol start="4"><li>启动</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第1个</span></span><br><span class="line">redis-sentinel s1/sentinel.conf</span><br><span class="line"><span class="comment"># 第2个</span></span><br><span class="line">redis-sentinel s2/sentinel.conf</span><br><span class="line"><span class="comment"># 第3个</span></span><br><span class="line">redis-sentinel s3/sentinel.conf</span><br></pre></td></tr></table></figure><h3 id="3-2-2-测试"><a href="#3-2-2-测试" class="headerlink" title="3.2.2 测试"></a>3.2.2 测试</h3><p>将7001宕机，发现其中一个从节点继承上来。</p><h2 id="3-3-RedisTemplate"><a href="#3-3-RedisTemplate" class="headerlink" title="3.3 RedisTemplate"></a>3.3 RedisTemplate</h2><p>在Sentinel集群监管下的Redis主从集群，其节点会因为自动故障转移而发生变化，Redis的客户端必须感知这种变化，及时更新连接信息。Spring的<strong>RedisTemplate底层利用lettuce实现了节点的感知和自动切换</strong>。</p><h3 id="3-3-1-配置文件"><a href="#3-3-1-配置文件" class="headerlink" title="3.3.1 配置文件"></a>3.3.1 配置文件</h3><p>我们配置了哨兵，则redis的ip就是动态的，所以我们只需要配置哨兵的ip即可。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">master:</span> <span class="string">mymaster</span></span><br><span class="line">      <span class="attr">nodes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:27001</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:27002</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:27003</span></span><br></pre></td></tr></table></figure><h3 id="3-3-2-配置读写分离"><a href="#3-3-2-配置读写分离" class="headerlink" title="3.3.2 配置读写分离"></a>3.3.2 配置读写分离</h3><p>在redis的配置类中，添加一个新的bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> LettuceClientConfigurationBuilderCustomizer <span class="title function_">clientConfigurationBuilderCustomizer</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> clientConfigurationBuilder -&gt; clientConfigurationBuilder.readFrom(ReadFrom.REPLICA_PREFERRED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们要主节点写操作，从节点读操作。</p><p>这个bean中配置的就是读写策略，包括四种：</p><ul><li>MASTER：从主节点读取</li><li>MASTER_PREFERRED：优先从master节点读取，master不可用才读取replica</li><li>REPLICA：从slave（replica）节点读取</li><li><strong>REPLICA _PREFERRED：优先从slave（replica）节点读取，所有的slave都不可用才读取master</strong></li></ul><h1 id="4-Redis分片集群"><a href="#4-Redis分片集群" class="headerlink" title="4.Redis分片集群"></a>4.Redis分片集群</h1><h2 id="4-1-为什么要分片集群？"><a href="#4-1-为什么要分片集群？" class="headerlink" title="4.1 为什么要分片集群？"></a>4.1 为什么要分片集群？</h2><p>主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：</p><ul><li><p>海量数据存储问题</p></li><li><p>高并发读写的问题</p></li></ul><p>那么我们就需要使用分片集群来解决以上问题：</p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210725155747294.png" alt="image-20210725155747294" style="zoom:67%;" /><p>分片集群特征：</p><ul><li><p>集群中<strong>有多个master</strong>，<strong>每个master保存不同数据</strong></p></li><li><p>每个master都可以有多个slave节点</p></li><li><p>master之间通过ping监测彼此健康状态</p></li><li><p>客户端请求可以访问集群任意节点，最终都会被转发到正确节点</p></li></ul><h2 id="4-2-搭建分片集群"><a href="#4-2-搭建分片集群" class="headerlink" title="4.2 搭建分片集群"></a>4.2 搭建分片集群</h2><p>需要准备的实例：</p><table><thead><tr><th align="center">IP</th><th align="center">PORT</th><th align="center">角色</th></tr></thead><tbody><tr><td align="center">192.168.150.101</td><td align="center">7001</td><td align="center">master</td></tr><tr><td align="center">192.168.150.101</td><td align="center">7002</td><td align="center">master</td></tr><tr><td align="center">192.168.150.101</td><td align="center">7003</td><td align="center">master</td></tr><tr><td align="center">192.168.150.101</td><td align="center">8001</td><td align="center">slave</td></tr><tr><td align="center">192.168.150.101</td><td align="center">8002</td><td align="center">slave</td></tr><tr><td align="center">192.168.150.101</td><td align="center">8003</td><td align="center">slave</td></tr></tbody></table><h3 id="4-2-1-准备实例与配置"><a href="#4-2-1-准备实例与配置" class="headerlink" title="4.2.1 准备实例与配置"></a>4.2.1 准备实例与配置</h3><ol><li>删除之前的7001、7002、7003这几个目录，重新创建出7001、7002、7003、8001、8002、8003目录：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入/tmp目录</span></span><br><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line"><span class="comment"># 删除旧的，避免配置干扰</span></span><br><span class="line"><span class="built_in">rm</span> -rf 7001 7002 7003</span><br><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line"><span class="built_in">mkdir</span> 7001 7002 7003 8001 8002 8003</span><br></pre></td></tr></table></figure><ol start="2"><li>在&#x2F;tmp下准备一个新的redis.conf文件，内容如下：</li></ol><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">port 6379</span><br><span class="line"><span class="comment"># 开启集群功能</span></span><br><span class="line">cluster-enabled yes</span><br><span class="line"><span class="comment"># 集群的配置文件名称，不需要我们创建，由redis自己维护</span></span><br><span class="line">cluster-config-file /tmp/6379/nodes.conf</span><br><span class="line"><span class="comment"># 节点心跳失败的超时时间</span></span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line"><span class="comment"># 持久化文件存放目录</span></span><br><span class="line">dir /tmp/6379</span><br><span class="line"><span class="comment"># 绑定地址</span></span><br><span class="line">bind 0.0.0.0</span><br><span class="line"><span class="comment"># 让redis后台运行</span></span><br><span class="line">daemonize yes</span><br><span class="line"><span class="comment"># 注册的实例ip</span></span><br><span class="line">replica-announce-ip 192.168.150.101</span><br><span class="line"><span class="comment"># 保护模式</span></span><br><span class="line">protected-mode no</span><br><span class="line"><span class="comment"># 数据库数量</span></span><br><span class="line">databases 1</span><br><span class="line"><span class="comment"># 日志</span></span><br><span class="line">logfile /tmp/6379/run.log</span><br></pre></td></tr></table></figure><ol start="3"><li>将这个文件拷贝到每个目录下：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入/tmp目录</span></span><br><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line"><span class="comment"># 执行拷贝</span></span><br><span class="line"><span class="built_in">echo</span> 7001 7002 7003 8001 8002 8003 | xargs -t -n 1 <span class="built_in">cp</span> redis.conf</span><br></pre></td></tr></table></figure><ol start="4"><li>修改每个目录下的redis.conf，将其中的6379修改为与所在目录一致：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入/tmp目录</span></span><br><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line"><span class="comment"># 修改配置文件</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&#x27;%s\n&#x27;</span> 7001 7002 7003 8001 8002 8003 | xargs -I&#123;&#125; -t sed -i <span class="string">&#x27;s/6379/&#123;&#125;/g&#x27;</span> &#123;&#125;/redis.conf</span><br></pre></td></tr></table></figure><ol start="5"><li>启动</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入/tmp目录</span></span><br><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line"><span class="comment"># 一键启动所有服务</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&#x27;%s\n&#x27;</span> 7001 7002 7003 8001 8002 8003 | xargs -I&#123;&#125; -t redis-server &#123;&#125;/redis.conf</span><br></pre></td></tr></table></figure><h3 id="4-2-2-创建集群"><a href="#4-2-2-创建集群" class="headerlink" title="4.2.2 创建集群"></a>4.2.2 创建集群</h3><p>在Redis5.0之前创建集群比较麻烦，5.0之后集群管理命令都集成到了redis-cli中。</p><ol><li><strong>Redis5.0之前</strong></li></ol><p>Redis5.0之前集群命令都是用redis安装包下的src&#x2F;redis-trib.rb来实现的。因为redis-trib.rb是有ruby语言编写的所以需要安装ruby环境。</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">yum -y install zlib ruby rubygems</span><br><span class="line">gem install redis</span><br></pre></td></tr></table></figure><p>然后通过命令来管理集群：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入redis的src目录</span></span><br><span class="line"><span class="built_in">cd</span> /tmp/redis-6.2.4/src</span><br><span class="line"><span class="comment"># 创建集群</span></span><br><span class="line">./redis-trib.rb create --replicas 1 192.168.150.101:7001 192.168.150.101:7002 192.168.150.101:7003 192.168.150.101:8001 192.168.150.101:8002 192.168.150.101:8003</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>Redis5.0以后</strong></li></ol><p>我们使用的是Redis6.2.4版本，集群管理以及集成到了redis-cli中，格式如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create --cluster-replicas 1 192.168.150.101:7001 192.168.150.101:7002 192.168.150.101:7003 192.168.150.101:8001 192.168.150.101:8002 192.168.150.101:8003</span><br></pre></td></tr></table></figure><p>命令说明：</p><ul><li><strong><code>redis-cli --cluster</code>或者<code>./redis-trib.rb</code>：代表集群操作命令</strong></li><li><code>create</code>：代表是创建集群</li><li><code>--replicas 1</code>或者<code>--cluster-replicas 1</code> ：指定集群中每个master的副本个数为1，此时<code>节点总数 ÷ (replicas + 1)</code> 得到的就是master的数量。因此节点列表中的前n个就是master，其它节点都是slave节点，随机分配到不同master</li></ul><p>通过命令可以查看集群状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 7001 cluster nodes</span><br></pre></td></tr></table></figure><p><strong>集群操作时，需要给<code>redis-cli</code>加上<code>-c</code>参数才可以。</strong></p><h2 id="4-3-散列插槽"><a href="#4-3-散列插槽" class="headerlink" title="4.3 散列插槽"></a>4.3 散列插槽</h2><h3 id="4-3-1-插槽原理"><a href="#4-3-1-插槽原理" class="headerlink" title="4.3.1.插槽原理"></a>4.3.1.插槽原理</h3><p>Redis会把每一个master节点映射到0~16383共16384个插槽（hash slot）上，查看集群信息时就能看到：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210725155820320.png" alt="image-20210725155820320"></p><p>数据key不是与节点绑定，而是与插槽绑定。redis会根据key的有效部分计算插槽值，分两种情况：</p><ul><li>key中包含”{}”，且“{}”中至少包含1个字符，“{}”中的部分是有效部分</li><li>key中不包含“{}”，整个key都是有效部分</li></ul><p>例如：key是num，那么就根据num计算，如果是{itcast}num，则根据itcast计算。计算方式是利用CRC16算法得到一个hash值，然后对16384取余，得到的结果就是slot值。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210725155850200.png" alt="image-20210725155850200"> </p><p>如图，在7001这个节点执行set a 1时，对a做hash运算，对16384取余，得到的结果是15495，因此要存储到103节点。</p><p>到了7003后，执行<code>get num</code>时，对num做hash运算，对16384取余，得到的结果是2765，因此需要切换到7001节点</p><h3 id="4-3-1-小结"><a href="#4-3-1-小结" class="headerlink" title="4.3.1.小结"></a>4.3.1.小结</h3><p><strong>Redis如何判断某个key应该在哪个实例？</strong></p><ul><li>将16384个插槽分配到不同的实例</li><li>根据key的有效部分计算哈希值，对16384取余</li><li>余数作为插槽，寻找插槽所在实例即可</li></ul><p><strong>如何将同一类数据固定的保存在同一个Redis实例？</strong></p><ul><li>这一类数据使用相同的有效部分，例如key都以{typeId}为前缀</li></ul><h2 id="4-4-集群伸缩"><a href="#4-4-集群伸缩" class="headerlink" title="4.4 集群伸缩"></a>4.4 集群伸缩</h2><p>添加节点的命令：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210725160448139.png" alt="image-20210725160448139"></p><h3 id="4-4-1-需求分析"><a href="#4-4-1-需求分析" class="headerlink" title="4.4.1 需求分析"></a>4.4.1 需求分析</h3><p><strong>需求：向集群中添加一个新的master节点，并向其中存储 num &#x3D; 10</strong></p><ul><li>启动一个新的redis实例，端口为7004</li><li>添加7004到之前的集群，并作为一个master节点</li><li>给7004节点分配插槽，使得num这个key可以存储到7004实例</li></ul><p>这里需要两个新的功能：</p><ul><li>添加一个节点到集群中</li><li>将部分插槽分配到新插槽</li></ul><h3 id="4-4-2-创建新的redis实例"><a href="#4-4-2-创建新的redis实例" class="headerlink" title="4.4.2 创建新的redis实例"></a>4.4.2 创建新的redis实例</h3><p>创建一个文件夹：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> 7004</span><br></pre></td></tr></table></figure><p>拷贝配置文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> redis.conf /7004</span><br></pre></td></tr></table></figure><p>修改配置文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed /s/6379/7004/g 7004/redis.conf</span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server 7004/redis.conf</span><br></pre></td></tr></table></figure><h3 id="4-4-3-添加新节点到redis"><a href="#4-4-3-添加新节点到redis" class="headerlink" title="4.4.3 添加新节点到redis"></a>4.4.3 添加新节点到redis</h3><p>添加节点的语法如下：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210725160448139.png" alt="image-20210725160448139"></p><p>执行命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster add-node  192.168.150.101:7004 192.168.150.101:7001</span><br></pre></td></tr></table></figure><p>通过命令查看集群状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 7001 cluster nodes</span><br></pre></td></tr></table></figure><p>如图，7004加入了集群，并且默认是一个master节点：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210725161007099.png" alt="image-20210725161007099"></p><p>但是，<strong>可以看到7004节点的插槽数量为0，因此没有任何数据可以存储到7004上</strong></p><h3 id="4-4-4-转移插槽"><a href="#4-4-4-转移插槽" class="headerlink" title="4.4.4 转移插槽"></a>4.4.4 转移插槽</h3><p>我们要将num存储到7004节点，因此需要先看看num的插槽是多少：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210725161241793.png" alt="image-20210725161241793"></p><p>如上图所示，num的插槽为2765.</p><p>我们可以将0~3000的插槽从7001转移到7004，命令格式如下：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210725161401925.png" alt="image-20210725161401925"></p><p>具体命令如下：</p><p>建立连接：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210725161506241.png" alt="image-20210725161506241"></p><p>得到下面的反馈：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210725161540841.png" alt="image-20210725161540841"></p><p>询问要移动多少个插槽，我们计划是3000个：</p><p>新的问题来了：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210725161637152.png" alt="image-20210725161637152"></p><p>那个node来接收这些插槽？？</p><p>显然是7004，那么7004节点的id是多少呢？</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210725161731738.png" alt="image-20210725161731738"></p><p>复制这个id，然后拷贝到刚才的控制台后：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210725161817642.png" alt="image-20210725161817642"></p><p>这里询问，你的插槽是从哪里移动过来的？</p><ul><li>all：代表全部，也就是三个节点各转移一部分</li><li>具体的id：目标节点的id</li><li>done：没有了</li></ul><p>这里我们要从7001获取，因此填写7001的id：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210725162030478.png" alt="image-20210725162030478"></p><p>填完后，点击done，这样插槽转移就准备好了：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210725162101228.png" alt="image-20210725162101228"></p><p>确认要转移吗？输入yes：</p><p>然后，通过命令查看结果：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210725162145497.png" alt="image-20210725162145497"> </p><p>可以看到： </p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210725162224058.png" alt="image-20210725162224058"></p><p>目的达成。</p><h2 id="4-5-故障转移"><a href="#4-5-故障转移" class="headerlink" title="4.5 故障转移"></a>4.5 故障转移</h2><p>集群初识状态是这样的：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210727161152065.png" alt="image-20210727161152065"></p><p>其中7001、7002、7003都是master，我们计划让7002宕机。</p><h3 id="4-5-1-自动故障转移"><a href="#4-5-1-自动故障转移" class="headerlink" title="4.5.1 自动故障转移"></a>4.5.1 自动故障转移</h3><p>当集群中有一个master宕机会发生什么呢？</p><p>直接停止一个redis实例，例如7002：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 7002 shutdown</span><br></pre></td></tr></table></figure><ol><li>首先是该实例与其它实例失去连接</li><li>然后是疑似宕机：</li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210725162319490.png" alt="image-20210725162319490"></p><ol start="3"><li>最后是确定下线，自动提升一个slave为新的master：</li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210725162408979.png" alt="image-20210725162408979"></p><ol start="4"><li>当7002再次启动，就会变为一个slave节点了：</li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210727160803386.png" alt="image-20210727160803386"></p><h3 id="4-5-2-手动故障转移"><a href="#4-5-2-手动故障转移" class="headerlink" title="4.5.2 手动故障转移"></a>4.5.2 手动故障转移</h3><p>利用cluster failover命令可以手动让集群中的某个master宕机，切换到执行cluster failover命令的这个slave节点，实现无感知的数据迁移。其流程如下：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210725162441407.png" alt="image-20210725162441407"></p><p>这种failover命令可以指定三种模式：</p><ul><li>缺省：默认的流程，如图1~6步</li><li>force：省略了对offset的一致性校验</li><li>takeover：直接执行第5歩，忽略数据一致性、忽略master状态和其它master的意见</li></ul><p><strong>案例需求</strong>：在7002这个slave节点执行手动故障转移，重新夺回master地位</p><p>步骤如下：</p><p>1）利用redis-cli连接7002这个节点</p><p>2）执行cluster failover命令</p><p>如图：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210727160037766.png" alt="image-20210727160037766"></p><p>效果：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210727161152065.png" alt="image-20210727161152065"></p><h2 id="4-6-RedisTemplate访问分片集群"><a href="#4-6-RedisTemplate访问分片集群" class="headerlink" title="4.6 RedisTemplate访问分片集群"></a>4.6 RedisTemplate访问分片集群</h2><p>RedisTemplate底层同样基于lettuce实现了分片集群的支持，而使用的步骤与哨兵模式基本一致：</p><ol><li><strong>引入redis的starter依赖</strong></li><li><strong>配置分片集群地址</strong></li><li><strong>配置读写分离</strong></li></ol><p>与哨兵模式相比，其中只有分片集群的配置方式略有差异，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">cluster:</span></span><br><span class="line">      <span class="attr">nodes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:7001</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:7002</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:7003</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:8001</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:8002</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:8003</span></span><br></pre></td></tr></table></figure><h1 id="二-多级缓存"><a href="#二-多级缓存" class="headerlink" title="二.多级缓存"></a>二.多级缓存</h1><p>该部分省略了很多细节，建议看视频，这里只是方便复习。</p><p>视频：<a href="https://www.bilibili.com/video/BV1cr4y1671t?p=113">高级篇-多级缓存-01-什么是多级缓存_哔哩哔哩_bilibili</a></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220811162155830.png" alt="image-20220811162155830"></p><h1 id="1-什么是多级缓存？"><a href="#1-什么是多级缓存？" class="headerlink" title="1.什么是多级缓存？"></a>1.什么是多级缓存？</h1><h2 id="1-1-传统缓存及存在的问题"><a href="#1-1-传统缓存及存在的问题" class="headerlink" title="1.1 传统缓存及存在的问题"></a>1.1 传统缓存及存在的问题</h2><p>传统缓存：</p><ol><li>请求到达Tomcat</li><li>查redis<ol><li>命中，返回数据</li><li>未命中，查询数据库，返回数据</li></ol></li></ol><p>存在的问题：</p><ul><li>所有请求都要先到达Tomcat，Tomcat的性能决定了整个系统的性能。</li><li>Redis缓存失效时，会对数据库造成冲击</li></ul><h2 id="1-2-多级缓存是什么"><a href="#1-2-多级缓存是什么" class="headerlink" title="1.2 多级缓存是什么"></a>1.2 多级缓存是什么</h2><p>多级缓存就是充分利用请求处理每一个环节，分别添加缓存，减轻Tomcat的压力，提升服务性能：</p><ul><li>浏览器访问静态资源时，优先读取浏览器本地缓存</li><li>访问非静态资源（ajax查询数据）时，访问服务端</li><li>请求到达Nginx后，优先读取Nginx本地缓存</li><li><strong>如果Nginx本地缓存未命中，则去直接查询Redis（不经过Tomcat）</strong></li><li>如果Redis查询未命中，则查询Tomcat</li><li>请求进入Tomcat后，优先查询JVM进程缓存</li><li>如果JVM进程缓存未命中，则查询数据库</li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210821075558137.png" alt="image-20210821075558137"></p><p>在多级缓存架构中，Nginx内部需要编写本地缓存查询、Redis查询、Tomcat查询的业务逻辑，因此这样的nginx服务不再是一个<strong>反向代理服务器</strong>，而是一个编写<strong>业务的Web服务器了</strong>。</p><p>因此<strong>Nginx服务也需要搭建集群</strong>来提高并发，再用一个专门的nginx来做反向代理，另外，我们的<strong>Tomcat服务将来也会部署为集群模式</strong>：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210821080954947.png" alt="image-20210821080954947"></p><p><strong>可见，多级缓存的关键有两个：</strong></p><ul><li><p>一个是在nginx中编写业务，实现nginx本地缓存、Redis、Tomcat的查询<strong>（OpenResty框架结合Lua语言）</strong></p></li><li><p>另一个就是在<strong>Tomcat中实现JVM进程缓存</strong></p></li></ul><h1 id="2-JVM进程缓存"><a href="#2-JVM进程缓存" class="headerlink" title="2.JVM进程缓存"></a>2.JVM进程缓存</h1><h2 id="2-1-初识Caffeine"><a href="#2-1-初识Caffeine" class="headerlink" title="2.1 初识Caffeine"></a>2.1 初识Caffeine</h2><p>GitHub地址：<a href="https://github.com/ben-manes/caffeine">https://github.com/ben-manes/caffeine</a></p><p>缓存在日常开发中启动至关重要的作用，由于是存储在内存中，数据的读取速度是非常快的，能大量减少对数据库的访问，减少数据库的压力。我们把缓存分为两类：</p><ul><li>分布式缓存，例如Redis：<ul><li>优点：存储容量更大、可靠性更好、可以在集群间共享</li><li>缺点：访问缓存有网络开销</li><li>场景：缓存数据量较大、可靠性要求较高、需要在集群间共享</li></ul></li><li>进程本地缓存，例如HashMap、GuavaCache：<ul><li>优点：读取本地内存，没有网络开销，速度更快</li><li>缺点：存储容量有限、可靠性较低、无法共享</li><li>场景：性能要求较高，缓存数据量较小</li></ul></li></ul><p><strong>Caffeine</strong>是一个基于Java8开发的，提供了近乎最佳命中率的高性能的本地缓存库。目前Spring内部的缓存使用的就是Caffeine。</p><h2 id="2-2基本API及缓存驱逐策略"><a href="#2-2基本API及缓存驱逐策略" class="headerlink" title="2.2基本API及缓存驱逐策略"></a>2.2基本API及缓存驱逐策略</h2><p>缓存使用的基本API：</p><ul><li>缓存不过就是存取数据</li><li>存数据<code>cache.put(String key,String val)</code></li><li>取数据<ul><li><code>cache.getIfPresent(String key)</code>,有数据返回数据，无数据返回null</li><li><code>cache.get(String key,Lambda表达式)</code>,有数据则返回数据，没有数据通过后面的表达式查数据库并写入缓存，返回数据</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testBasicOps</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 构建cache对象</span></span><br><span class="line">    Cache&lt;String, String&gt; cache = Caffeine.newBuilder().build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存数据</span></span><br><span class="line">    cache.put(<span class="string">&quot;gf&quot;</span>, <span class="string">&quot;迪丽热巴&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">gf</span> <span class="operator">=</span> cache.getIfPresent(<span class="string">&quot;gf&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;gf = &quot;</span> + gf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取数据，包含两个参数：</span></span><br><span class="line">    <span class="comment">// 参数一：缓存的key</span></span><br><span class="line">    <span class="comment">// 参数二：Lambda表达式，表达式参数就是缓存的key，方法体是查询数据库的逻辑</span></span><br><span class="line">    <span class="comment">// 优先根据key查询JVM缓存，如果未命中，则执行参数二的Lambda表达式</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">defaultGF</span> <span class="operator">=</span> cache.get(<span class="string">&quot;defaultGF&quot;</span>, key -&gt; &#123;</span><br><span class="line">        <span class="comment">// 根据key去数据库查询数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;柳岩&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;defaultGF = &quot;</span> + defaultGF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Caffeine提供了三种缓存驱逐策略</strong>：</p><ul><li><p><strong>基于容量</strong>：设置缓存的数量上限</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建缓存对象</span></span><br><span class="line">Cache&lt;String, String&gt; cache = Caffeine.newBuilder()</span><br><span class="line">    .maximumSize(<span class="number">1</span>) <span class="comment">// 设置缓存大小上限为 1</span></span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure></li><li><p><strong>基于时间</strong>：设置缓存的有效时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建缓存对象</span></span><br><span class="line">Cache&lt;String, String&gt; cache = Caffeine.newBuilder()</span><br><span class="line">    <span class="comment">// 设置缓存有效期为 10 秒，从最后一次写入开始计时 </span></span><br><span class="line">    .expireAfterWrite(Duration.ofSeconds(<span class="number">10</span>)) </span><br><span class="line">    .build();</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>基于引用</strong>：设置缓存为软引用或弱引用，利用GC来回收缓存数据。性能较差，不建议使用。</p></li></ul><blockquote><p><strong>注意</strong>：在默认情况下，当一个缓存元素过期的时候，<strong>Caffeine不会自动立即将其清理和驱逐</strong>。而是在一次读或写操作后，或者在空闲时间完成对失效数据的驱逐。</p></blockquote><h2 id="2-3-使用Caffeine"><a href="#2-3-使用Caffeine" class="headerlink" title="2.3 使用Caffeine"></a>2.3 使用Caffeine</h2><p><strong>一般在配置类中将某张表的需要缓存作为bean注入Spring容器中，在配置类中生命好缓存驱逐策略。</strong></p><p>定义两个Caffeine的缓存对象，分别保存商品、库存的缓存数据。</p><p>在item-service的<code>com.heima.item.config</code>包下定义<code>CaffeineConfig</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.item.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.benmanes.caffeine.cache.Cache;</span><br><span class="line"><span class="keyword">import</span> com.github.benmanes.caffeine.cache.Caffeine;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.Item;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.ItemStock;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CaffeineConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Cache&lt;Long, Item&gt; <span class="title function_">itemCache</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Caffeine.newBuilder()</span><br><span class="line">                .initialCapacity(<span class="number">100</span>)</span><br><span class="line">                .maximumSize(<span class="number">10_000</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Cache&lt;Long, ItemStock&gt; <span class="title function_">stockCache</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Caffeine.newBuilder()</span><br><span class="line">                .initialCapacity(<span class="number">100</span>)</span><br><span class="line">                .maximumSize(<span class="number">10_000</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改造业务代码：利用API<code>cache.get()</code>，来获取数据，即可在查询时顺便写入缓存</p><h1 id="3-Lua语法入门"><a href="#3-Lua语法入门" class="headerlink" title="3.Lua语法入门"></a>3.Lua语法入门</h1><p>视频：<a href="https://www.bilibili.com/video/BV1cr4y1671t?p=118&vd_source=665476c062292b64fa2949e9c935b109">高级篇-多级缓存-06-Lua语法-初识Lua_哔哩哔哩_bilibili</a></p><p><strong>Nginx编程需要用到Lua语言</strong>，因此我们必须先入门Lua的基本语法。</p><h1 id="4-实现多级缓存"><a href="#4-实现多级缓存" class="headerlink" title="4.实现多级缓存"></a>4.实现多级缓存</h1><p>多级缓存的实现离不开Nginx编程，而Nginx编程又离不开OpenResty。</p><h2 id="4-1-OpenResty安装及快速入门"><a href="#4-1-OpenResty安装及快速入门" class="headerlink" title="4.1 OpenResty安装及快速入门"></a>4.1 OpenResty安装及快速入门</h2><p>官方网站： <a href="https://openresty.org/cn/">https://openresty.org/cn/</a></p><p>OpenResty® 是一个基于 Nginx的高性能 Web 平台，用于方便地<strong>搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关</strong>。具备下列特点：</p><ul><li>具备Nginx的完整功能</li><li>基于Lua语言进行扩展，集成了大量精良的 Lua 库、第三方模块</li><li>允许使用Lua<strong>自定义业务逻辑</strong>、<strong>自定义库</strong></li></ul><p>视频链接：<a href="https://www.bilibili.com/video/BV1cr4y1671t?p=121&vd_source=665476c062292b64fa2949e9c935b109">高级篇-多级缓存-09-多级缓存-安装OpenResty_哔哩哔哩_bilibili</a></p><h2 id="4-2-请求参数处理"><a href="#4-2-请求参数处理" class="headerlink" title="4.2 请求参数处理"></a>4.2 请求参数处理</h2><p>如何获取前端传递的商品参数呢？</p><h3 id="4-2-1-获取参数的API"><a href="#4-2-1-获取参数的API" class="headerlink" title="4.2.1.获取参数的API"></a>4.2.1.获取参数的API</h3><p>OpenResty中提供了一些API用来获取不同类型的前端请求参数：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210821101433528.png" alt="image-20210821101433528"></p><h2 id="4-3-查询Tomcat"><a href="#4-3-查询Tomcat" class="headerlink" title="4.3 查询Tomcat"></a>4.3 查询Tomcat</h2><p>由Nginx转发到Tomcat集群的时候<strong>默认的负载均衡是轮询</strong>，那么就会<strong>导致一个请求会在多个Tomcat服务器缓存</strong>，并且需要在轮询完所有服务器才能真正的利用到缓存，缓存命中率太低，这是非常不好的。</p><p>所以我们需要改变nginx的负载均衡策略，让同一个请求每次都能转发到同一台Tomcat服务器。</p><h3 id="4-3-1原理"><a href="#4-3-1原理" class="headerlink" title="4.3.1原理"></a>4.3.1原理</h3><p>nginx提供了基于请求路径做负载均衡的算法：</p><p>nginx根据请求路径做hash运算，把得到的数值对tomcat服务的数量取余，余数是几，就访问第几个服务，实现负载均衡。</p><p>例如：</p><ul><li>我们的请求路径是 &#x2F;item&#x2F;10001</li><li>tomcat总数为2台（8081、8082）</li><li>对请求路径&#x2F;item&#x2F;1001做hash运算求余的结果为1</li><li>则访问第一个tomcat服务，也就是8081</li></ul><p>只要id不变，每次hash运算结果也不会变，那就可以保证同一个商品，一直访问同一个tomcat服务，确保JVM缓存生效。</p><h3 id="4-3-2-实现"><a href="#4-3-2-实现" class="headerlink" title="4.3.2 实现"></a>4.3.2 实现</h3><p>修改<code>/usr/local/openresty/nginx/conf/nginx.conf</code>文件，实现基于ID做负载均衡。</p><p>首先，定义tomcat集群，并设置基于路径做负载均衡：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> tomcat-cluster &#123;</span><br><span class="line">    <span class="attribute">hash</span> <span class="variable">$request_uri</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.150.1:8081</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.150.1:8082</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，修改对tomcat服务的反向代理，目标指向tomcat集群：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /item &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://tomcat-cluster;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新加载OpenResty</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><h2 id="4-4-Redis缓存预热"><a href="#4-4-Redis缓存预热" class="headerlink" title="4.4 Redis缓存预热"></a>4.4 Redis缓存预热</h2><p>Redis缓存会面临冷启动问题：</p><p><strong>冷启动</strong>：服务刚刚启动时，Redis中并没有缓存，如果所有商品数据都在第一次查询时添加缓存，可能会给数据库带来较大压力。</p><p><strong>缓存预热</strong>：在实际开发中，我们可以利用大数据统计用户访问的热点数据，在项目启动时<strong>将这些热点数据提前查询并保存到Redis中</strong>。</p><h3 id="4-4-1-编码实现"><a href="#4-4-1-编码实现" class="headerlink" title="4.4.1 编码实现"></a>4.4.1 编码实现</h3><p>缓存预热需要在项目启动时完成，并且必须是拿到RedisTemplate之后。</p><p>这里我们<strong>利用InitializingBean接口</strong>来实现，因为<strong>InitializingBean可以在对象被Spring创建并且成员变量全部注入后执行。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisHandler</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IItemService itemService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IItemStockService stockService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">MAPPER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 初始化缓存</span></span><br><span class="line">        <span class="comment">// 1.查询商品信息</span></span><br><span class="line">        List&lt;Item&gt; itemList = itemService.list();</span><br><span class="line">        <span class="comment">// 2.放入缓存</span></span><br><span class="line">        <span class="keyword">for</span> (Item item : itemList) &#123;</span><br><span class="line">            <span class="comment">// 2.1.item序列化为JSON</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> MAPPER.writeValueAsString(item);</span><br><span class="line">            <span class="comment">// 2.2.存入redis</span></span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;item:id:&quot;</span> + item.getId(), json);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.查询商品库存信息</span></span><br><span class="line">        List&lt;ItemStock&gt; stockList = stockService.list();</span><br><span class="line">        <span class="comment">// 4.放入缓存</span></span><br><span class="line">        <span class="keyword">for</span> (ItemStock stock : stockList) &#123;</span><br><span class="line">            <span class="comment">// 2.1.item序列化为JSON</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> MAPPER.writeValueAsString(stock);</span><br><span class="line">            <span class="comment">// 2.2.存入redis</span></span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;item:stock:id:&quot;</span> + stock.getId(), json);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-6-查询Redis缓存"><a href="#4-6-查询Redis缓存" class="headerlink" title="4.6.查询Redis缓存"></a>4.6.查询Redis缓存</h2><p>具体操作：<a href="https://www.bilibili.com/video/BV1cr4y1671t?p=128">高级篇-多级缓存-16-多级缓存-查询Redis_哔哩哔哩_bilibili</a></p><p>现在，Redis缓存已经准备就绪，我们可以再OpenResty中实现查询Redis的逻辑了。如下图红框所示：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210821113340111.png" alt="image-20210821113340111"></p><p>当请求进入OpenResty之后：</p><ul><li>优先查询Redis缓存</li><li>如果Redis缓存未命中，再查询Tomcat</li></ul><h2 id="4-7-Nginx本地缓存"><a href="#4-7-Nginx本地缓存" class="headerlink" title="4.7.Nginx本地缓存"></a>4.7.Nginx本地缓存</h2><p>具体操作：<a href="https://www.bilibili.com/video/BV1cr4y1671t?p=129&vd_source=665476c062292b64fa2949e9c935b109">高级篇-多级缓存-17-多级缓存-nginx本地缓存_哔哩哔哩_bilibili</a></p><p>现在，整个多级缓存中只差最后一环，也就是nginx的本地缓存了。如图：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210821114742950.png" alt="image-20210821114742950"></p><h1 id="5-缓存同步"><a href="#5-缓存同步" class="headerlink" title="5.缓存同步"></a>5.缓存同步</h1><p>大多数情况下，浏览器查询到的都是缓存数据，如果缓存数据与数据库数据存在较大差异，可能会产生比较严重的后果。</p><p>所以我们必须<strong>保证数据库数据、缓存数据的一致性，这就是缓存与数据库的同步</strong>。</p><h2 id="5-1-数据同步策略"><a href="#5-1-数据同步策略" class="headerlink" title="5.1.数据同步策略"></a>5.1.数据同步策略</h2><p>缓存数据同步的常见方式有三种：</p><p><strong>设置有效期</strong>：给缓存设置有效期，到期后自动删除。再次查询时更新</p><ul><li>优势：简单、方便</li><li>缺点：时效性差，缓存过期之前可能不一致</li><li>场景：更新频率较低，时效性要求低的业务</li></ul><p><strong>同步双写</strong>：在修改数据库的同时，直接修改缓存</p><ul><li>优势：时效性强，缓存与数据库强一致</li><li>缺点：有代码侵入，耦合度高；</li><li>场景：对一致性、时效性要求较高的缓存数据</li></ul><p><strong>异步通知：</strong>修改数据库时发送事件通知，相关服务监听到通知后修改缓存数据</p><ul><li>优势：低耦合，可以同时通知多个缓存服务</li><li>缺点：时效性一般，可能存在中间不一致状态</li><li>场景：时效性要求一般，有多个服务需要同步</li></ul><p>而异步实现又可以基于MQ或者Canal来实现：</p><p>1）基于MQ的异步通知：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210821115552327.png" alt="image-20210821115552327"></p><p>解读：</p><ul><li>商品服务完成对数据的修改后，只需要发送一条消息到MQ中。</li><li>缓存服务监听MQ消息，然后完成对缓存的更新</li></ul><p><strong>依然有少量的代码侵入。</strong></p><p>2）基于Canal的通知</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210821115719363.png" alt="image-20210821115719363"></p><p>解读：</p><ul><li>商品服务完成商品修改后，业务直接结束，没有任何代码侵入</li><li>Canal监听MySQL变化，当发现变化后，立即通知缓存服务</li><li>缓存服务接收到canal通知，更新缓存</li></ul><p><strong>代码零侵入</strong></p><h2 id="5-2-安装Canal"><a href="#5-2-安装Canal" class="headerlink" title="5.2.安装Canal"></a>5.2.安装Canal</h2><h3 id="5-2-1-认识Canal"><a href="#5-2-1-认识Canal" class="headerlink" title="5.2.1.认识Canal"></a>5.2.1.认识Canal</h3><p>**Canal [kə’næl]**，译意为水道&#x2F;管道&#x2F;沟渠，canal是阿里巴巴旗下的一款开源项目，基于Java开发。基于数据库增量日志解析，提供增量数据订阅&amp;消费。GitHub的地址：<a href="https://github.com/alibaba/canal">https://github.com/alibaba/canal</a></p><p>Canal是基于mysql的主从同步来实现的，MySQL主从同步的原理如下：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210821115914748.png" alt="image-20210821115914748"></p><ul><li>1）MySQL master 将数据变更写入二进制日志( binary log），其中记录的数据叫做binary log events</li><li>2）MySQL slave 将 master 的 binary log events拷贝到它的中继日志(relay log)</li><li>3）MySQL slave 重放 relay log 中事件，将数据变更反映它自己的数据</li></ul><p>而Canal就是把自己伪装成MySQL的一个slave节点，从而监听master的binary log变化。再把得到的变化信息通知给Canal的客户端，进而完成对其它数据库的同步。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210821115948395.png" alt="image-20210821115948395"></p><h3 id="5-2-2-安装Canal"><a href="#5-2-2-安装Canal" class="headerlink" title="5.2.2.安装Canal"></a>5.2.2.安装Canal</h3><h1 id="1-开启MySQL主从"><a href="#1-开启MySQL主从" class="headerlink" title="1.开启MySQL主从"></a>1.开启MySQL主从</h1><p>Canal是基于MySQL的主从同步功能，因此必须先开启MySQL的主从功能才可以。</p><p>这里以之前用Docker运行的mysql为例：</p><h2 id="1-1-开启binlog"><a href="#1-1-开启binlog" class="headerlink" title="1.1.开启binlog"></a>1.1.开启binlog</h2><p>打开mysql容器挂载的日志文件，我的在<code>/tmp/mysql/conf</code>目录:</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210813153241537.png" alt="image-20210813153241537"></p><p>修改文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /tmp/mysql/conf/my.cnf</span><br></pre></td></tr></table></figure><p>添加内容：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">log-bin</span>=/var/lib/mysql/mysql-bin</span><br><span class="line"><span class="attr">binlog-do-db</span>=heima</span><br></pre></td></tr></table></figure><p>配置解读：</p><ul><li><code>log-bin=/var/lib/mysql/mysql-bin</code>：设置binary log文件的存放地址和文件名，叫做mysql-bin</li><li><code>binlog-do-db=heima</code>：指定对哪个database记录binary log events，这里记录heima这个库</li></ul><p>最终效果：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line">skip-name-resolve</span><br><span class="line"><span class="attr">character_set_server</span>=utf8</span><br><span class="line"><span class="attr">datadir</span>=/var/lib/mysql</span><br><span class="line"><span class="attr">server-id</span>=<span class="number">1000</span></span><br><span class="line"><span class="attr">log-bin</span>=/var/lib/mysql/mysql-bin</span><br><span class="line"><span class="attr">binlog-do-db</span>=heima</span><br></pre></td></tr></table></figure><h2 id="1-2-设置用户权限"><a href="#1-2-设置用户权限" class="headerlink" title="1.2.设置用户权限"></a>1.2.设置用户权限</h2><p>接下来添加一个仅用于数据同步的账户，出于安全考虑，这里仅提供对heima这个库的操作权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create user canal@&#x27;%&#x27; IDENTIFIED by &#x27;canal&#x27;;</span><br><span class="line">GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT,SUPER ON *.* TO &#x27;canal&#x27;@&#x27;%&#x27; identified by &#x27;canal&#x27;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p>重启mysql容器即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart mysql</span><br></pre></td></tr></table></figure><p>测试设置是否成功：在mysql控制台，或者Navicat中，输入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show master status;</span><br></pre></td></tr></table></figure><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20200327094735948.png" alt="image-20200327094735948"> </p><h1 id="2-安装Canal"><a href="#2-安装Canal" class="headerlink" title="2.安装Canal"></a>2.安装Canal</h1><h2 id="2-1-创建网络"><a href="#2-1-创建网络" class="headerlink" title="2.1.创建网络"></a>2.1.创建网络</h2><p>我们需要创建一个网络，将MySQL、Canal、MQ放到同一个Docker网络中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create heima</span><br></pre></td></tr></table></figure><p>让mysql加入这个网络：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect heima mysql</span><br></pre></td></tr></table></figure><h2 id="2-3-安装Canal"><a href="#2-3-安装Canal" class="headerlink" title="2.3.安装Canal"></a>2.3.安装Canal</h2><p>将canal的镜像压缩包上传到虚拟机，然后通过命令导入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i canal.tar</span><br></pre></td></tr></table></figure><p>然后运行命令创建Canal容器：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 11111:11111 --name canal \</span><br><span class="line">-e canal.destinations=heima \</span><br><span class="line">-e canal.instance.master.address=mysql:3306  \</span><br><span class="line">-e canal.instance.dbUsername=canal  \</span><br><span class="line">-e canal.instance.dbPassword=canal  \</span><br><span class="line">-e canal.instance.connectionCharset=UTF-8 \</span><br><span class="line">-e canal.instance.tsdb.enable=<span class="literal">true</span> \</span><br><span class="line">-e canal.instance.gtidon=<span class="literal">false</span>  \</span><br><span class="line">-e canal.instance.filter.regex=heima\\..* \</span><br><span class="line">--network heima \</span><br><span class="line">-d canal/canal-server:v1.1.5</span><br></pre></td></tr></table></figure><p>说明:</p><ul><li><code>-p 11111:11111</code>：这是canal的默认监听端口</li><li><code>-e canal.instance.master.address=mysql:3306</code>：数据库地址和端口，如果不知道mysql容器地址，可以通过<code>docker inspect 容器id</code>来查看</li><li><code>-e canal.instance.dbUsername=canal</code>：数据库用户名</li><li><code>-e canal.instance.dbPassword=canal</code> ：数据库密码</li><li><code>-e canal.instance.filter.regex=</code>：要监听的表名称</li></ul><p>表名称监听支持的语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql 数据解析关注的表，Perl正则表达式.</span><br><span class="line">多个正则之间以逗号(,)分隔，转义符需要双斜杠(\\) </span><br><span class="line">常见例子：</span><br><span class="line">1.  所有表：.*   or  .*\\..*</span><br><span class="line">2.  canal schema下所有表： canal\\..*</span><br><span class="line">3.  canal下的以canal打头的表：canal\\.canal.*</span><br><span class="line">4.  canal schema下的一张表：canal.test1</span><br><span class="line">5.  多个规则组合使用然后以逗号隔开：canal\\..*,mysql.test1,mysql.test2 </span><br></pre></td></tr></table></figure><h2 id="5-3-监听Canal"><a href="#5-3-监听Canal" class="headerlink" title="5.3.监听Canal"></a>5.3.监听Canal</h2><p>Canal提供了各种语言的客户端，当Canal监听到binlog变化时，会通知Canal的客户端。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20210821120049024.png" alt="image-20210821120049024"></p><p>我们可以利用Canal提供的Java客户端，监听Canal通知消息。当收到变化的消息时，完成对缓存的更新。</p><p>不过这里我们<strong>会使用GitHub上的第三方开源的canal-starter客户端</strong>。地址：<a href="https://github.com/NormanGyllenhaal/canal-client">https://github.com/NormanGyllenhaal/canal-client</a></p><p>与SpringBoot完美整合，自动装配，比官方客户端要简单好用很多。</p><h3 id="5-3-1-引入依赖："><a href="#5-3-1-引入依赖：" class="headerlink" title="5.3.1.引入依赖："></a>5.3.1.引入依赖：</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>top.javatool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>canal-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1-RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-3-2-编写配置："><a href="#5-3-2-编写配置：" class="headerlink" title="5.3.2.编写配置："></a>5.3.2.编写配置：</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">canal:</span></span><br><span class="line">  <span class="attr">destination:</span> <span class="string">heima</span> <span class="comment"># canal的集群名字，要与安装canal时设置的名称一致</span></span><br><span class="line">  <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:11111</span> <span class="comment"># canal服务地址</span></span><br></pre></td></tr></table></figure><h3 id="5-3-3-修改Item实体类"><a href="#5-3-3-修改Item实体类" class="headerlink" title="5.3.3.修改Item实体类"></a>5.3.3.修改Item实体类</h3><p>通过@Id、@Column、等注解完成Item与数据库表字段的映射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.item.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableField;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableId;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableName;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.annotation.Id;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.annotation.Transient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.Column;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;tb_item&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">    <span class="meta">@TableId(type = IdType.AUTO)</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;<span class="comment">//商品id</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//商品名称</span></span><br><span class="line">    <span class="keyword">private</span> String title;<span class="comment">//商品标题</span></span><br><span class="line">    <span class="keyword">private</span> Long price;<span class="comment">//价格（分）</span></span><br><span class="line">    <span class="keyword">private</span> String image;<span class="comment">//商品图片</span></span><br><span class="line">    <span class="keyword">private</span> String category;<span class="comment">//分类名称</span></span><br><span class="line">    <span class="keyword">private</span> String brand;<span class="comment">//品牌名称</span></span><br><span class="line">    <span class="keyword">private</span> String spec;<span class="comment">//规格</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;<span class="comment">//商品状态 1-正常，2-下架</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;<span class="comment">//创建时间</span></span><br><span class="line">    <span class="keyword">private</span> Date updateTime;<span class="comment">//更新时间</span></span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="meta">@Transient</span></span><br><span class="line">    <span class="keyword">private</span> Integer stock;</span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="meta">@Transient</span></span><br><span class="line">    <span class="keyword">private</span> Integer sold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-4-编写监听器"><a href="#5-3-4-编写监听器" class="headerlink" title="5.3.4.编写监听器"></a>5.3.4.编写监听器</h3><p><strong>通过实现<code>EntryHandler&lt;T&gt;</code>接口编写监听器，监听Canal消息。注意两点：</strong></p><ul><li>实现类通过<code>@CanalTable(&quot;tb_item&quot;)</code>指定监听的表信息</li><li>EntryHandler的泛型是与表对应的实体类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.item.canal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.benmanes.caffeine.cache.Cache;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.config.RedisHandler;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.Item;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> top.javatool.canal.client.annotation.CanalTable;</span><br><span class="line"><span class="keyword">import</span> top.javatool.canal.client.handler.EntryHandler;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CanalTable(&quot;tb_item&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItemHandler</span> <span class="keyword">implements</span> <span class="title class_">EntryHandler</span>&lt;Item&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisHandler redisHandler;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Cache&lt;Long, Item&gt; itemCache;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">        <span class="comment">// 写数据到JVM进程缓存</span></span><br><span class="line">        itemCache.put(item.getId(), item);</span><br><span class="line">        <span class="comment">// 写数据到redis</span></span><br><span class="line">        redisHandler.saveItem(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Item before, Item after)</span> &#123;</span><br><span class="line">        <span class="comment">// 写数据到JVM进程缓存</span></span><br><span class="line">        itemCache.put(after.getId(), after);</span><br><span class="line">        <span class="comment">// 写数据到redis</span></span><br><span class="line">        redisHandler.saveItem(after);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">        <span class="comment">// 删除数据到JVM进程缓存</span></span><br><span class="line">        itemCache.invalidate(item.getId());</span><br><span class="line">        <span class="comment">// 删除数据到redis</span></span><br><span class="line">        redisHandler.deleteItemById(item.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里对Redis的操作都封装到了RedisHandler这个对象中，是我们之前做缓存预热时编写的一个类，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.item.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.Item;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.ItemStock;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.service.IItemService;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.service.IItemStockService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisHandler</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IItemService itemService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IItemStockService stockService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">MAPPER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 初始化缓存</span></span><br><span class="line">        <span class="comment">// 1.查询商品信息</span></span><br><span class="line">        List&lt;Item&gt; itemList = itemService.list();</span><br><span class="line">        <span class="comment">// 2.放入缓存</span></span><br><span class="line">        <span class="keyword">for</span> (Item item : itemList) &#123;</span><br><span class="line">            <span class="comment">// 2.1.item序列化为JSON</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> MAPPER.writeValueAsString(item);</span><br><span class="line">            <span class="comment">// 2.2.存入redis</span></span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;item:id:&quot;</span> + item.getId(), json);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.查询商品库存信息</span></span><br><span class="line">        List&lt;ItemStock&gt; stockList = stockService.list();</span><br><span class="line">        <span class="comment">// 4.放入缓存</span></span><br><span class="line">        <span class="keyword">for</span> (ItemStock stock : stockList) &#123;</span><br><span class="line">            <span class="comment">// 2.1.item序列化为JSON</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> MAPPER.writeValueAsString(stock);</span><br><span class="line">            <span class="comment">// 2.2.存入redis</span></span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;item:stock:id:&quot;</span> + stock.getId(), json);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveItem</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> MAPPER.writeValueAsString(item);</span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;item:id:&quot;</span> + item.getId(), json);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteItemById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        redisTemplate.delete(<span class="string">&quot;item:id:&quot;</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三-最佳实践"><a href="#三-最佳实践" class="headerlink" title="三.最佳实践"></a>三.最佳实践</h1><p><strong>参考视频：黑马程序员</strong></p><h2 id="1-Redis的键值设计"><a href="#1-Redis的键值设计" class="headerlink" title="1. Redis的键值设计"></a>1. Redis的键值设计</h2><h3 id="1-1-优雅的key结构"><a href="#1-1-优雅的key结构" class="headerlink" title="1.1 优雅的key结构"></a>1.1 优雅的key结构</h3><p>Redis的key最好遵循以下最佳实践约定：</p><ul><li>遵循基本格式：[业务名称]:[数据名]:[id]，<strong>保证可读性和可管理性</strong></li><li>长度不超过44字节，<strong>保证简洁性</strong></li><li><strong>不包含特殊字符</strong>，包含空格、换行、单双引号以及其他转义字符</li></ul><p>例如：登陆业务，保存用户信息</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220521120213631.png" alt="image-20220521120213631"></p><h3 id="1-2-拒绝BigKey"><a href="#1-2-拒绝BigKey" class="headerlink" title="1.2 拒绝BigKey"></a>1.2 拒绝BigKey</h3><p>BigKey通常以Key的大小和Key中成员的数量来综合判定，例如：</p><ul><li>Key本身的数据量过大：一个String类型的Key，它的值为5 MB</li><li>Key中的成员数过多：一个ZSET类型的Key，它的成员数量为10,000个</li><li>Key中成员的数据量过大：一个Hash类型的Key，它的成员数量虽然只有1,000个但这些成员的Value（值）总大小为100 MB</li></ul><p>通过以下命令可以判断元素大小：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220521124650117.png" alt="image-20220521124650117"></p><p>推荐值：</p><ul><li>单个key的value小于10KB</li><li>对于集合类型的key，建议元素数量小于1000</li></ul><h4 id="1-2-1-BigKey的危害"><a href="#1-2-1-BigKey的危害" class="headerlink" title="1.2.1 BigKey的危害"></a>1.2.1 BigKey的危害</h4><ul><li>网络阻塞<ul><li>对BigKey执行读请求时，少量的QPS就可能导致带宽使用率被占满，导致Redis实例，乃至所在物理机变慢</li></ul></li><li>数据倾斜<ul><li>BigKey所在的Redis实例内存使用率远超其他实例，无法使数据分片的内存资源达到均衡</li></ul></li><li>Redis阻塞<ul><li>对元素较多的hash、list、zset等做运算会耗时较旧，使主线程被阻塞</li></ul></li><li>CPU压力<ul><li>对BigKey的数据序列化和反序列化会导致CPU的使用率飙升，影响Redis实例和本机其它应用</li></ul></li></ul><h4 id="1-2-2-如何发现BigKey"><a href="#1-2-2-如何发现BigKey" class="headerlink" title="1.2.2 如何发现BigKey"></a>1.2.2 如何发现BigKey</h4><h5 id="①redis-cli-–bigkeys"><a href="#①redis-cli-–bigkeys" class="headerlink" title="①redis-cli –bigkeys"></a>①redis-cli –bigkeys</h5><p>利用redis-cli提供的–bigkeys参数，可以遍历分析所有key，并返回Key的整体统计信息与每个数据的Top1的big key</p><p>命令：<code>redis-cli -a 密码 --bigkeys</code></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220521133359507.png" alt="image-20220521133359507"></p><h5 id="②scan扫描"><a href="#②scan扫描" class="headerlink" title="②scan扫描"></a>②scan扫描</h5><p>自己编程，利用scan扫描Redis中的所有key，利用strlen、hlen等命令判断key的长度（此处不建议使用MEMORY USAGE）</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220521133703245.png" alt="image-20220521133703245"></p><p>scan 命令调用完后每次会返回2个元素，第一个是下一次迭代的光标，第一次光标会设置为0，当最后一次scan 返回的光标等于0时，表示整个scan遍历结束了，第二个返回的是List，一个匹配的key的数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.heima.jedis.util.JedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.ScanResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        <span class="comment">// jedis = new Jedis(&quot;192.168.150.101&quot;, 6379);</span></span><br><span class="line">        jedis = JedisConnectionFactory.getJedis();</span><br><span class="line">        <span class="comment">// 2.设置密码</span></span><br><span class="line">        jedis.auth(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.选择库</span></span><br><span class="line">        jedis.select(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">STR_MAX_LEN</span> <span class="operator">=</span> <span class="number">10</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">HASH_MAX_LEN</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testScan</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">cursor</span> <span class="operator">=</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 扫描并获取一部分key</span></span><br><span class="line">            ScanResult&lt;String&gt; result = jedis.scan(cursor);</span><br><span class="line">            <span class="comment">// 记录cursor</span></span><br><span class="line">            cursor = result.getCursor();</span><br><span class="line">            List&lt;String&gt; list = result.getResult();</span><br><span class="line">            <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历</span></span><br><span class="line">            <span class="keyword">for</span> (String key : list) &#123;</span><br><span class="line">                <span class="comment">// 判断key的类型</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> jedis.type(key);</span><br><span class="line">                <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;string&quot;</span>:</span><br><span class="line">                        len = jedis.strlen(key);</span><br><span class="line">                        maxLen = STR_MAX_LEN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;hash&quot;</span>:</span><br><span class="line">                        len = jedis.hlen(key);</span><br><span class="line">                        maxLen = HASH_MAX_LEN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;list&quot;</span>:</span><br><span class="line">                        len = jedis.llen(key);</span><br><span class="line">                        maxLen = HASH_MAX_LEN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;set&quot;</span>:</span><br><span class="line">                        len = jedis.scard(key);</span><br><span class="line">                        maxLen = HASH_MAX_LEN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;zset&quot;</span>:</span><br><span class="line">                        len = jedis.zcard(key);</span><br><span class="line">                        maxLen = HASH_MAX_LEN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (len &gt;= maxLen) &#123;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;Found big key : %s, type: %s, length or size: %d %n&quot;</span>, key, type, len);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!cursor.equals(<span class="string">&quot;0&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="③第三方工具"><a href="#③第三方工具" class="headerlink" title="③第三方工具"></a>③第三方工具</h5><ul><li>利用第三方工具，如 Redis-Rdb-Tools 分析RDB快照文件，全面分析内存使用情况</li><li><a href="https://github.com/sripathikrishnan/redis-rdb-tools">https://github.com/sripathikrishnan/redis-rdb-tools</a></li></ul><h5 id="④网络监控"><a href="#④网络监控" class="headerlink" title="④网络监控"></a>④网络监控</h5><ul><li>自定义工具，监控进出Redis的网络数据，超出预警值时主动告警</li><li>一般阿里云搭建的云服务器就有相关监控页面</li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220521140415785.png" alt="image-20220521140415785"></p><h4 id="1-2-3-如何删除BigKey"><a href="#1-2-3-如何删除BigKey" class="headerlink" title="1.2.3 如何删除BigKey"></a>1.2.3 如何删除BigKey</h4><p>BigKey内存占用较多，即便时删除这样的key也需要耗费很长时间，导致Redis主线程阻塞，引发一系列问题。</p><ul><li>redis 3.0 及以下版本<ul><li>如果是集合类型，则遍历BigKey的元素，先逐个删除子元素，最后删除BigKey</li></ul></li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220521140621204.png" alt="image-20220521140621204"></p><ul><li>Redis 4.0以后<ul><li>Redis在4.0后提供了异步删除的命令：unlink</li></ul></li></ul><p>非字符串的bigkey，不要使用del删除，使用hscan、sscan、zscan方式渐进式删除，同时要注意防止bigkey过期时间自动删除问题(例如一个200万的zset设置1小时过期，会触发del操作，造成阻塞，而且该操作不会不出现在慢查询中(latency可查))，查找方法和删除方法。</p><h3 id="1-3-恰当的数据类型"><a href="#1-3-恰当的数据类型" class="headerlink" title="1.3 恰当的数据类型"></a>1.3 恰当的数据类型</h3><h4 id="例1：比如存储一个User对象，我们有三种存储方式："><a href="#例1：比如存储一个User对象，我们有三种存储方式：" class="headerlink" title="例1：比如存储一个User对象，我们有三种存储方式："></a>例1：比如存储一个User对象，我们有三种存储方式：</h4><h5 id="①方式一：json字符串"><a href="#①方式一：json字符串" class="headerlink" title="①方式一：json字符串"></a>①方式一：json字符串</h5><table><thead><tr><th align="center">user:1</th><th align="center">{“name”: “Jack”, “age”: 21}</th></tr></thead></table><p>优点：实现简单粗暴</p><p>缺点：数据耦合，不够灵活</p><h5 id="②方式二：字段打散"><a href="#②方式二：字段打散" class="headerlink" title="②方式二：字段打散"></a>②方式二：字段打散</h5><table><thead><tr><th align="center">user:1:name</th><th align="center">Jack</th></tr></thead><tbody><tr><td align="center">user:1:age</td><td align="center">21</td></tr></tbody></table><p>优点：可以灵活访问对象任意字段</p><p>缺点：占用空间大、没办法做统一控制</p><h5 id="③方式三：hash（推荐）"><a href="#③方式三：hash（推荐）" class="headerlink" title="③方式三：hash（推荐）"></a>③方式三：hash（推荐）</h5><table>    <tr>        <td rowspan="2">user:1</td>        <td>name</td>        <td>jack</td>    </tr>    <tr>        <td>age</td>        <td>21</td>    </tr></table><p>优点：底层使用ziplist，空间占用小，可以灵活访问对象的任意字段</p><p>缺点：代码相对复杂</p><h4 id="例2：假如有hash类型的key，其中有100万对field和value，field是自增id，这个key存在什么问题？如何优化？"><a href="#例2：假如有hash类型的key，其中有100万对field和value，field是自增id，这个key存在什么问题？如何优化？" class="headerlink" title="例2：假如有hash类型的key，其中有100万对field和value，field是自增id，这个key存在什么问题？如何优化？"></a>例2：假如有hash类型的key，其中有100万对field和value，field是自增id，这个key存在什么问题？如何优化？</h4><table>    <tr style="color:red">        <td>key</td>        <td>field</td>        <td>value</td>    </tr>    <tr>        <td rowspan="3">someKey</td>        <td>id:0</td>        <td>value0</td>    </tr>    <tr>        <td>.....</td>        <td>.....</td>    </tr>    <tr>        <td>id:999999</td>        <td>value999999</td>    </tr></table><p>存在的问题：</p><ul><li>hash的entry数量超过500时，会使用哈希表而不是ZipList，内存占用较多<ul><li><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220521142943350.png" alt="image-20220521142943350"></li></ul></li><li>可以通过hash-max-ziplist-entries配置entry上限。但是如果entry过多就会导致BigKey问题</li></ul><h5 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h5><p>拆分为string类型</p><table>    <tr style="color:red">        <td>key</td>        <td>value</td>    </tr>    <tr>        <td>id:0</td>        <td>value0</td>    </tr>    <tr>        <td>.....</td>        <td>.....</td>    </tr>    <tr>        <td>id:999999</td>        <td>value999999</td>    </tr></table><p>存在的问题：</p><ul><li>string结构底层没有太多内存优化，内存占用较多</li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220521143458010.png" alt="image-20220521143458010"></p><ul><li>想要批量获取这些数据比较麻烦</li></ul><h5 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h5><p>拆分为小的hash，将 id &#x2F; 100 作为key， 将id % 100 作为field，这样每100个元素为一个Hash</p><table>    <tr style="color:red">        <td>key</td>        <td>field</td>        <td>value</td>    </tr>    <tr>        <td rowspan="3">key:0</td>        <td>id:00</td>        <td>value0</td>    </tr>    <tr>        <td>.....</td>        <td>.....</td>    </tr>    <tr>        <td>id:99</td>        <td>value99</td>    </tr>    <tr>        <td rowspan="3">key:1</td>        <td>id:00</td>        <td>value100</td>    </tr>    <tr>        <td>.....</td>        <td>.....</td>    </tr>    <tr>        <td>id:99</td>        <td>value199</td>    </tr>    <tr>        <td colspan="3">....</td>    </tr>    <tr>        <td rowspan="3">key:9999</td>        <td>id:00</td>        <td>value999900</td>    </tr>    <tr>        <td>.....</td>        <td>.....</td>    </tr>    <tr>        <td>id:99</td>        <td>value999999</td>    </tr></table><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220521144339377.png" alt="image-20220521144339377"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.heima.jedis.util.JedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Pipeline;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.ScanResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        <span class="comment">// jedis = new Jedis(&quot;192.168.150.101&quot;, 6379);</span></span><br><span class="line">        jedis = JedisConnectionFactory.getJedis();</span><br><span class="line">        <span class="comment">// 2.设置密码</span></span><br><span class="line">        jedis.auth(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.选择库</span></span><br><span class="line">        jedis.select(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSetBigKey</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">650</span>; i++) &#123;</span><br><span class="line">            map.put(<span class="string">&quot;hello_&quot;</span> + i, <span class="string">&quot;world!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        jedis.hmset(<span class="string">&quot;m2&quot;</span>, map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testBigHash</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            map.put(<span class="string">&quot;key_&quot;</span> + i, <span class="string">&quot;value_&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        jedis.hmset(<span class="string">&quot;test:big:hash&quot;</span>, map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testBigString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            jedis.set(<span class="string">&quot;test:str:key_&quot;</span> + i, <span class="string">&quot;value_&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSmallHash</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hashSize</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(hashSize);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> (i - <span class="number">1</span>) / hashSize;</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> i % hashSize;</span><br><span class="line">            map.put(<span class="string">&quot;key_&quot;</span> + v, <span class="string">&quot;value_&quot;</span> + v);</span><br><span class="line">            <span class="keyword">if</span> (v == <span class="number">0</span>) &#123;</span><br><span class="line">                jedis.hmset(<span class="string">&quot;test:small:hash_&quot;</span> + k, map);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h3><ul><li>Key的最佳实践<ul><li>固定格式：[业务名]:[数据名]:[id]</li><li>足够简短：不超过44字节</li><li>不包含特殊字符</li></ul></li><li>Value的最佳实践：<ul><li>合理的拆分数据，拒绝BigKey</li><li>选择合适数据结构</li><li>Hash结构的entry数量不要超过1000</li><li>设置合理的超时时间</li></ul></li></ul><h2 id="2-批处理优化"><a href="#2-批处理优化" class="headerlink" title="2. 批处理优化"></a>2. 批处理优化</h2><h3 id="2-1-Pipeline"><a href="#2-1-Pipeline" class="headerlink" title="2.1 Pipeline"></a>2.1 Pipeline</h3><h4 id="2-1-1-我们的客户端与redis服务器是这样交互的"><a href="#2-1-1-我们的客户端与redis服务器是这样交互的" class="headerlink" title="2.1.1 我们的客户端与redis服务器是这样交互的"></a>2.1.1 我们的客户端与redis服务器是这样交互的</h4><p>单个命令的执行流程</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220521151459880.png" alt="image-20220521151459880"></p><p>N条命令的执行流程</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220521151524621.png" alt="image-20220521151524621"></p><p>redis处理指令是很快的，主要花费的时候在于网络传输。于是乎很容易想到将多条指令批量的传输给redis</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220521151902080.png" alt="image-20220521151902080"></p><h4 id="2-1-2-MSet"><a href="#2-1-2-MSet" class="headerlink" title="2.1.2 MSet"></a>2.1.2 MSet</h4><p>Redis提供了很多Mxxx这样的命令，可以实现批量插入数据，例如：</p><ul><li>mset</li><li>hmset</li></ul><p>利用mset批量插入10万条数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testMxx</span><span class="params">()</span> &#123;</span><br><span class="line">    String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">2000</span>];</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        j = (i % <span class="number">1000</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        arr[j] = <span class="string">&quot;test:key_&quot;</span> + i;</span><br><span class="line">        arr[j + <span class="number">1</span>] = <span class="string">&quot;value_&quot;</span> + i;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">            jedis.mset(arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">e</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;time: &quot;</span> + (e - b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-3-Pipeline"><a href="#2-1-3-Pipeline" class="headerlink" title="2.1.3 Pipeline"></a>2.1.3 Pipeline</h4><p>MSET虽然可以批处理，但是却只能操作部分数据类型，因此如果有对复杂数据类型的批处理需要，建议使用Pipeline</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPipeline</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建管道</span></span><br><span class="line">    <span class="type">Pipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> jedis.pipelined();</span><br><span class="line">    <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 放入命令到管道</span></span><br><span class="line">        pipeline.set(<span class="string">&quot;test:key_&quot;</span> + i, <span class="string">&quot;value_&quot;</span> + i);</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">1000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 每放入1000条命令，批量执行</span></span><br><span class="line">            pipeline.sync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">e</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;time: &quot;</span> + (e - b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-集群下的批处理"><a href="#2-2-集群下的批处理" class="headerlink" title="2.2 集群下的批处理"></a>2.2 集群下的批处理</h3><p>如MSET或Pipeline这样的批处理需要在一次请求中携带多条命令，而此时如果Redis是一个集群，那批处理命令的多个key必须落在一个插槽中，否则就会导致执行失败。大家可以想一想这样的要求其实很难实现，因为我们在批处理时，可能一次要插入很多条数据，这些数据很有可能不会都落在相同的节点上，这就会导致报错了</p><p>这个时候，我们可以找到4种解决方案</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/1653126446641.png" alt="1653126446641"></p><p>第一种方案：串行执行，所以这种方式没有什么意义，当然，执行起来就很简单了，缺点就是耗时过久。</p><p>第二种方案：串行slot，简单来说，就是执行前，客户端先计算一下对应的key的slot，一样slot的key就放到一个组里边，不同的，就放到不同的组里边，然后对每个组执行pipeline的批处理，他就能串行执行各个组的命令，这种做法比第一种方法耗时要少，但是缺点呢，相对来说复杂一点，所以这种方案还需要优化一下</p><p>第三种方案：并行slot，相较于第二种方案，在分组完成后串行执行，第三种方案，就变成了并行执行各个命令，所以他的耗时就非常短，但是实现呢，也更加复杂。</p><p>第四种：hash_tag，redis计算key的slot的时候，其实是根据key的有效部分来计算的，通过这种方式就能一次处理所有的key，这种方式耗时最短，实现也简单，但是如果通过操作key的有效部分，那么就会导致所有的key都落在一个节点上，产生数据倾斜的问题，所以我们推荐使用第三种方式。</p><h4 id="2-2-1-串行化执行代码实践"><a href="#2-2-1-串行化执行代码实践" class="headerlink" title="2.2.1 串行化执行代码实践"></a>2.2.1 串行化执行代码实践</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisClusterTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JedisCluster jedisCluster;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 配置连接池</span></span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">poolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        poolConfig.setMaxTotal(<span class="number">8</span>);</span><br><span class="line">        poolConfig.setMaxIdle(<span class="number">8</span>);</span><br><span class="line">        poolConfig.setMinIdle(<span class="number">0</span>);</span><br><span class="line">        poolConfig.setMaxWaitMillis(<span class="number">1000</span>);</span><br><span class="line">        HashSet&lt;HostAndPort&gt; nodes = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.150.101&quot;</span>, <span class="number">7001</span>));</span><br><span class="line">        nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.150.101&quot;</span>, <span class="number">7002</span>));</span><br><span class="line">        nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.150.101&quot;</span>, <span class="number">7003</span>));</span><br><span class="line">        nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.150.101&quot;</span>, <span class="number">8001</span>));</span><br><span class="line">        nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.150.101&quot;</span>, <span class="number">8002</span>));</span><br><span class="line">        nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.150.101&quot;</span>, <span class="number">8003</span>));</span><br><span class="line">        jedisCluster = <span class="keyword">new</span> <span class="title class_">JedisCluster</span>(nodes, poolConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testMSet</span><span class="params">()</span> &#123;</span><br><span class="line">        jedisCluster.mset(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>, <span class="string">&quot;sex&quot;</span>, <span class="string">&quot;male&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testMSet2</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;sex&quot;</span>, <span class="string">&quot;Male&quot;</span>);</span><br><span class="line">        <span class="comment">//对Map数据进行分组。根据相同的slot放在一个分组</span></span><br><span class="line">        <span class="comment">//key就是slot，value就是一个组</span></span><br><span class="line">        Map&lt;Integer, List&lt;Map.Entry&lt;String, String&gt;&gt;&gt; result = map.entrySet()</span><br><span class="line">                .stream()</span><br><span class="line">                .collect(Collectors.groupingBy(</span><br><span class="line">                        entry -&gt; ClusterSlotHashUtil.calculateSlot(entry.getKey()))</span><br><span class="line">                );</span><br><span class="line">        <span class="comment">//串行的去执行mset的逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Map.Entry&lt;String, String&gt;&gt; list : result.values()) &#123;</span><br><span class="line">            String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[list.size() * <span class="number">2</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">                j = i&lt;&lt;<span class="number">2</span>;</span><br><span class="line">                Map.Entry&lt;String, String&gt; e = list.get(<span class="number">0</span>);</span><br><span class="line">                arr[j] = e.getKey();</span><br><span class="line">                arr[j + <span class="number">1</span>] = e.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">            jedisCluster.mset(arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (jedisCluster != <span class="literal">null</span>) &#123;</span><br><span class="line">            jedisCluster.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-Spring集群环境下批处理代码"><a href="#2-2-2-Spring集群环境下批处理代码" class="headerlink" title="2.2.2 Spring集群环境下批处理代码"></a>2.2.2 Spring集群环境下批处理代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">testMSetInCluster</span><span class="params">()</span> &#123;</span><br><span class="line">     Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">     map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Rose&quot;</span>);</span><br><span class="line">     map.put(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line">     map.put(<span class="string">&quot;sex&quot;</span>, <span class="string">&quot;Female&quot;</span>);</span><br><span class="line">     stringRedisTemplate.opsForValue().multiSet(map);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     List&lt;String&gt; strings = stringRedisTemplate.opsForValue().multiGet(Arrays.asList(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;sex&quot;</span>));</span><br><span class="line">     strings.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>原理分析</strong></p><p>在RedisAdvancedClusterAsyncCommandsImpl 类中</p><p>首先根据slotHash算出来一个partitioned的map，map中的key就是slot，而他的value就是对应的对应相同slot的key对应的数据</p><p>通过 RedisFuture<String> mset &#x3D; super.mset(op);进行异步的消息发送</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RedisFuture&lt;String&gt; <span class="title function_">mset</span><span class="params">(Map&lt;K, V&gt; map)</span> &#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, List&lt;K&gt;&gt; partitioned = SlotHash.partition(codec, map.keySet());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (partitioned.size() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.mset(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, RedisFuture&lt;String&gt;&gt; executions = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, List&lt;K&gt;&gt; entry : partitioned.entrySet()) &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;K, V&gt; op = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        entry.getValue().forEach(k -&gt; op.put(k, map.get(k)));</span><br><span class="line"></span><br><span class="line">        RedisFuture&lt;String&gt; mset = <span class="built_in">super</span>.mset(op);</span><br><span class="line">        executions.put(entry.getKey(), mset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MultiNodeExecution.firstOfAsync(executions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-服务器端优化-持久化配置"><a href="#3-服务器端优化-持久化配置" class="headerlink" title="3. 服务器端优化-持久化配置"></a>3. 服务器端优化-持久化配置</h2><p>Redis的持久化虽然可以保证数据安全，但也会带来很多额外的开销，因此持久化请遵循下列建议：</p><ul><li>用来做缓存的Redis实例尽量不要开启持久化功能</li><li>建议关闭RDB持久化功能，使用AOF持久化</li><li>利用脚本定期在slave节点做RDB，实现数据备份</li><li>设置合理的rewrite阈值，避免频繁的bgrewrite</li><li>配置no-appendfsync-on-rewrite &#x3D; yes，禁止在rewrite期间做aof，避免因AOF引起的阻塞</li><li>部署有关建议：<ul><li>Redis实例的物理机要预留足够内存，应对fork和rewrite</li><li>单个Redis实例内存上限不要太大，例如4G或8G。可以加快fork的速度、减少主从同步、数据迁移压力</li><li>不要与CPU密集型应用部署在一起</li><li>不要与高硬盘负载应用一起部署。例如：数据库、消息队列</li></ul></li></ul><h2 id="4-服务器端优化-慢查询优化"><a href="#4-服务器端优化-慢查询优化" class="headerlink" title="4. 服务器端优化-慢查询优化"></a>4. 服务器端优化-慢查询优化</h2><h3 id="4-1-什么是慢查询"><a href="#4-1-什么是慢查询" class="headerlink" title="4.1 什么是慢查询"></a>4.1 什么是慢查询</h3><p>并不是很慢的查询才是慢查询，而是：在Redis执行时耗时超过某个阈值的命令，称为慢查询。</p><p>慢查询的危害：由于Redis是单线程的，所以当客户端发出指令后，他们都会进入到redis底层的queue来执行，如果此时有一些慢查询的数据，就会导致大量请求阻塞，从而引起报错，所以我们需要解决慢查询问题。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/1653129590210.png" alt="1653129590210"></p><p>慢查询的阈值可以通过配置指定：</p><p>slowlog-log-slower-than：慢查询阈值，单位是微秒。默认是10000，建议1000</p><p>慢查询会被放入慢查询日志中，日志的长度有上限，可以通过配置指定：</p><p>slowlog-max-len：慢查询日志（本质是一个队列）的长度。默认是128，建议1000</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/1653130457771.png" alt="1653130457771"></p><p>修改这两个配置可以使用：config set命令：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/1653130475979.png" alt="1653130475979"></p><h3 id="4-2-如何查看慢查询"><a href="#4-2-如何查看慢查询" class="headerlink" title="4.2 如何查看慢查询"></a>4.2 如何查看慢查询</h3><p>知道了以上内容之后，那么咱们如何去查看慢查询日志列表呢：</p><ul><li>slowlog len：查询慢查询日志长度</li><li>slowlog get [n]：读取n条慢查询日志</li><li>slowlog reset：清空慢查询列表</li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/1653130858066.png" alt="1653130858066"></p><h2 id="5-服务器端优化-命令及安全配置"><a href="#5-服务器端优化-命令及安全配置" class="headerlink" title="5. 服务器端优化-命令及安全配置"></a>5. 服务器端优化-命令及安全配置</h2><p> 安全可以说是服务器端一个非常重要的话题，如果安全出现了问题，那么一旦这个漏洞被一些坏人知道了之后，并且进行攻击，那么这就会给咱们的系统带来很多的损失，所以我们这节课就来解决这个问题。</p><p>Redis会绑定在0.0.0.0:6379，这样将会将Redis服务暴露到公网上，而Redis如果没有做身份认证，会出现严重的安全漏洞.<br>漏洞重现方式：<a href="https://cloud.tencent.com/developer/article/1039000">https://cloud.tencent.com/developer/article/1039000</a></p><p>为什么会出现不需要密码也能够登录呢，主要是Redis考虑到每次登录都比较麻烦，所以Redis就有一种ssh免秘钥登录的方式，生成一对公钥和私钥，私钥放在本地，公钥放在redis端，当我们登录时服务器，再登录时候，他会去解析公钥和私钥，如果没有问题，则不需要利用redis的登录也能访问，这种做法本身也很常见，但是这里有一个前提，前提就是公钥必须保存在服务器上，才行，但是Redis的漏洞在于在不登录的情况下，也能把秘钥送到Linux服务器，从而产生漏洞</p><p>漏洞出现的核心的原因有以下几点：</p><ul><li>Redis未设置密码</li><li>利用了Redis的config set命令动态修改Redis配置</li><li>使用了Root账号权限启动Redis</li></ul><p>所以：如何解决呢？我们可以采用如下几种方案</p><p>为了避免这样的漏洞，这里给出一些建议：</p><ul><li>Redis一定要设置密码</li><li>禁止线上使用下面命令：keys、flushall、flushdb、config set等命令。可以利用rename-command禁用。</li><li>bind：限制网卡，禁止外网网卡访问</li><li>开启防火墙</li><li>不要使用Root账户启动Redis</li><li>尽量不是有默认的端口</li></ul><h2 id="6-服务器端优化-Redis内存划分和内存配置"><a href="#6-服务器端优化-Redis内存划分和内存配置" class="headerlink" title="6. 服务器端优化-Redis内存划分和内存配置"></a>6. 服务器端优化-Redis内存划分和内存配置</h2><p>当Redis内存不足时，可能导致Key频繁被删除、响应时间变长、QPS不稳定等问题。当内存使用率达到90%以上时就需要我们警惕，并快速定位到内存占用的原因。</p><p><strong>有关碎片问题分析</strong></p><p>Redis底层分配并不是这个key有多大，他就会分配多大，而是有他自己的分配策略，比如8,16,20等等，假定当前key只需要10个字节，此时分配8肯定不够，那么他就会分配16个字节，多出来的6个字节就不能被使用，这就是我们常说的 碎片问题</p><p><strong>进程内存问题分析：</strong></p><p>这片内存，通常我们都可以忽略不计</p><p><strong>缓冲区内存问题分析：</strong></p><p>一般包括客户端缓冲区、AOF缓冲区、复制缓冲区等。客户端缓冲区又包括输入缓冲区和输出缓冲区两种。这部分内存占用波动较大，所以这片内存也是我们需要重点分析的内存问题。</p><table><thead><tr><th><strong>内存占用</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>数据内存</td><td>是Redis最主要的部分，存储Redis的键值信息。主要问题是BigKey问题、内存碎片问题</td></tr><tr><td>进程内存</td><td>Redis主进程本身运⾏肯定需要占⽤内存，如代码、常量池等等；这部分内存⼤约⼏兆，在⼤多数⽣产环境中与Redis数据占⽤的内存相⽐可以忽略。</td></tr><tr><td>缓冲区内存</td><td>一般包括客户端缓冲区、AOF缓冲区、复制缓冲区等。客户端缓冲区又包括输入缓冲区和输出缓冲区两种。这部分内存占用波动较大，不当使用BigKey，可能导致内存溢出。</td></tr></tbody></table><p>于是我们就需要通过一些命令，可以查看到Redis目前的内存分配状态：</p><ul><li>info memory：查看内存分配的情况</li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/1653132073570.png" alt="1653132073570"></p><ul><li>memory xxx：查看key的主要占用情况</li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/1653132098823.png" alt="1653132098823"></p><p>接下来我们看到了这些配置，最关键的缓存区内存如何定位和解决呢？</p><p>内存缓冲区常见的有三种：</p><ul><li>复制缓冲区：主从复制的repl_backlog_buf，如果太小可能导致频繁的全量复制，影响性能。通过replbacklog-size来设置，默认1mb</li><li>AOF缓冲区：AOF刷盘之前的缓存区域，AOF执行rewrite的缓冲区。无法设置容量上限</li><li>客户端缓冲区：分为输入缓冲区和输出缓冲区，输入缓冲区最大1G且不能设置。输出缓冲区可以设置</li></ul><p>以上复制缓冲区和AOF缓冲区 不会有问题，最关键就是客户端缓冲区的问题</p><p>客户端缓冲区：指的就是我们发送命令时，客户端用来缓存命令的一个缓冲区，也就是我们向redis输入数据的输入端缓冲区和redis向客户端返回数据的响应缓存区，输入缓冲区最大1G且不能设置，所以这一块我们根本不用担心，如果超过了这个空间，redis会直接断开，因为本来此时此刻就代表着redis处理不过来了，我们需要担心的就是输出端缓冲区</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/1653132410073.png" alt="1653132410073"></p><p>我们在使用redis过程中，处理大量的big value，那么会导致我们的输出结果过多，如果输出缓存区过大，会导致redis直接断开，而默认配置的情况下， 其实他是没有大小的，这就比较坑了，内存可能一下子被占满，会直接导致咱们的redis断开，所以解决方案有两个</p><p>1、设置一个大小</p><p>2、增加我们带宽的大小，避免我们出现大量数据从而直接超过了redis的承受能力</p><h2 id="7-服务器端集群优化-集群还是主从"><a href="#7-服务器端集群优化-集群还是主从" class="headerlink" title="7. 服务器端集群优化-集群还是主从"></a>7. 服务器端集群优化-集群还是主从</h2><p>集群虽然具备高可用特性，能实现自动故障恢复，但是如果使用不当，也会存在一些问题：</p><ul><li>集群完整性问题</li><li>集群带宽问题</li><li>数据倾斜问题</li><li>客户端性能问题</li><li>命令的集群兼容性问题</li><li>lua和事务问题</li></ul><p> <strong>问题1、在Redis的默认配置中，如果发现任意一个插槽不可用，则整个集群都会停止对外服务：</strong> </p><p>大家可以设想一下，如果有几个slot不能使用，那么此时整个集群都不能用了，我们在开发中，其实最重要的是可用性，所以需要把如下配置修改成no，即有slot不能使用时，我们的redis集群还是可以对外提供服务</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/1653132740637.png" alt="1653132740637"></p><p><strong>问题2、集群带宽问题</strong></p><p>集群节点之间会不断的互相Ping来确定集群中其它节点的状态。每次Ping携带的信息至少包括：</p><ul><li>插槽信息</li><li>集群状态信息</li></ul><p>集群中节点越多，集群状态信息数据量也越大，10个节点的相关信息可能达到1kb，此时每次集群互通需要的带宽会非常高，这样会导致集群中大量的带宽都会被ping信息所占用，这是一个非常可怕的问题，所以我们需要去解决这样的问题</p><p><strong>解决途径：</strong></p><ul><li>避免大集群，集群节点数不要太多，最好少于1000，如果业务庞大，则建立多个集群。</li><li>避免在单个物理机中运行太多Redis实例</li><li>配置合适的cluster-node-timeout值</li></ul><p><strong>问题3、命令的集群兼容性问题</strong></p><p>有关这个问题咱们已经探讨过了，当我们使用批处理的命令时，redis要求我们的key必须落在相同的slot上，然后大量的key同时操作时，是无法完成的，所以客户端必须要对这样的数据进行处理，这些方案我们之前已经探讨过了，所以不再这个地方赘述了。</p><p><strong>问题4、lua和事务的问题</strong></p><p>lua和事务都是要保证原子性问题，如果你的key不在一个节点，那么是无法保证lua的执行和事务的特性的，所以在集群模式是没有办法执行lua和事务的</p><p><strong>那我们到底是集群还是主从</strong></p><p>单体Redis（主从Redis）已经能达到万级别的QPS，并且也具备很强的高可用特性。如果主从能满足业务需求的情况下，所以如果不是在万不得已的情况下，尽量不搭建Redis集群</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 多级缓存 </tag>
            
            <tag> 分布式缓存 </tag>
            
            <tag> Redis集群 </tag>
            
            <tag> Redis最佳实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA复制实例开启多个服务</title>
      <link href="/coderbin/6926ecac.html"/>
      <url>/coderbin/6926ecac.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-找到IDEA下的Services并点开"><a href="#1-找到IDEA下的Services并点开" class="headerlink" title="1.找到IDEA下的Services并点开"></a>1.找到IDEA下的Services并点开</h2><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220818220725863.png" alt="image-20220818220725863"></p><h3 id="1-1-没有Services"><a href="#1-1-没有Services" class="headerlink" title="1.1 没有Services"></a>1.1 没有Services</h3><p>点击View-&gt;Tool Windows-&gt;Services</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220818220816158.png" alt="image-20220818220816158"></p><h2 id="2-点击＋号选择Run-Configuration-Type"><a href="#2-点击＋号选择Run-Configuration-Type" class="headerlink" title="2.点击＋号选择Run Configuration Type"></a>2.点击＋号选择Run Configuration Type</h2><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220818220922299.png" alt="image-20220818220922299"></p><h2 id="3-选择Spring-Boot"><a href="#3-选择Spring-Boot" class="headerlink" title="3.选择Spring Boot"></a>3.选择Spring Boot</h2><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220818221042749.png" alt="image-20220818221042749"></p><p>这时你就可以看到你的项目了</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220818221116162.png" alt="image-20220818221116162"></p><p>接下来我们需要复制该实例并且改变端口启动</p><h2 id="4-右键选择Copy-Configuration"><a href="#4-右键选择Copy-Configuration" class="headerlink" title="4.右键选择Copy Configuration"></a>4.右键选择Copy Configuration</h2><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220818221216286.png" alt="image-20220818221216286"></p><h2 id="5-在对应位置修改名字和端口"><a href="#5-在对应位置修改名字和端口" class="headerlink" title="5.在对应位置修改名字和端口"></a>5.在对应位置修改名字和端口</h2><blockquote><p>-Dserver.port&#x3D;xxxx</p></blockquote><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220818221337986.png" alt="image-20220818221337986"></p><h2 id="6-确认后就可以看到有两个实例了"><a href="#6-确认后就可以看到有两个实例了" class="headerlink" title="6.确认后就可以看到有两个实例了"></a>6.确认后就可以看到有两个实例了</h2><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220818221424636.png" alt="image-20220818221424636"></p><h2 id="7-启动"><a href="#7-启动" class="headerlink" title="7.启动"></a>7.启动</h2><p>一个运行在8080</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220818221501270.png" alt="image-20220818221501270"></p><p>一个运行在8081</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220818221537131.png" alt="image-20220818221537131"></p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
            <tag> 开发工具 </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8新特性</title>
      <link href="/coderbin/397c083a.html"/>
      <url>/coderbin/397c083a.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="一-Java8新特性"><a href="#一-Java8新特性" class="headerlink" title="一.Java8新特性"></a>一.Java8新特性</h1><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/27782283/1660138438802-7daffb99-03e7-46d9-aa63-65a09adcc9af.jpeg#clientId=u912af564-828b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uce9b0a25&margin=%5Bobject%20Object%5D&name=image.png&originHeight=569&originWidth=1027&originalType=url&ratio=1&rotation=0&showTitle=false&size=122793&status=done&style=none&taskId=u9ff23556-510e-4b24-b3c8-8b426fcb02e&title=" alt="image.png"></p><h2 id="1-Java8新特性的好处"><a href="#1-Java8新特性的好处" class="headerlink" title="1.Java8新特性的好处"></a>1.Java8新特性的好处</h2><ul><li>速度更快</li><li>代码更少(增加了新的语法：Lambda 表达式)</li><li>强大的Stream API</li><li>便于并行</li><li>最大化减少空指针异常：Optional</li><li>Nashorn引擎，允许在JVM上运行JS应用</li></ul><h2 id="2-并行流与串行流"><a href="#2-并行流与串行流" class="headerlink" title="2.并行流与串行流"></a>2.并行流与串行流</h2><p>并行流就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。相比较串行的流，并行的流可以很大程度上提高程序的执行效率。<br>Java 8 中将并行进行了优化，我们可以很容易的对数据进行并行操作。Stream API 可以声明性地通过parallel() 与sequential() 在并行流与顺序流之间进行切换。</p><h1 id="二-Lambda表达式"><a href="#二-Lambda表达式" class="headerlink" title="二.Lambda表达式"></a>二.Lambda表达式</h1><p>Lambda 是一个匿名函数，我们可以把Lambda 表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。</p><h2 id="1-Lambda表达式的使用"><a href="#1-Lambda表达式的使用" class="headerlink" title="1.Lambda表达式的使用"></a>1.Lambda表达式的使用</h2><ul><li>举例： (o1,o2) -&gt; Integer.compare(o1,o2);</li><li>格式：<ul><li>-&gt; : lambda操作符 或 箭头操作符</li><li>-&gt;左边：lambda形参列表 （其实就是接口中的<strong>抽象方法的形参列表</strong>）</li><li>-&gt;右边：lambda体 （其实就是重写的<strong>抽象方法的方法体</strong>）</li></ul></li></ul><p>Lambda表达式的使用：（分为6种情况介绍）<br><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1660138795936-1efd116f-aa0d-4947-b899-aecb552ab601.png#clientId=u912af564-828b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ucdfc97fb&margin=%5Bobject%20Object%5D&name=image.png&originHeight=2050&originWidth=923&originalType=url&ratio=1&rotation=0&showTitle=false&size=197169&status=done&style=none&taskId=uf234a87b-65e1-4b29-bba1-68842354598&title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1660138786691-0275580e-e4dc-4e4f-9693-a43589306b22.png#clientId=u912af564-828b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u08cbedd3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=2324&originWidth=981&originalType=url&ratio=1&rotation=0&showTitle=false&size=253253&status=done&style=none&taskId=u69a3b82d-0123-4eed-8202-0377900d3e7&title=" alt="image.png"></p><h2 id="2-总结"><a href="#2-总结" class="headerlink" title="2.总结"></a>2.总结</h2><ul><li>-&gt;左边：lambda形参列表的参数类型可以省略(类型推断)；<strong>如果lambda形参列表只有一个参数，其一对()也可以省略</strong></li><li>-&gt;右边：lambda体应该使用一对{}包裹；如果lambda体只有一条执行语句（可能是return语句），省略这一对{}和return关键字</li></ul><h1 id="三-函数式-Functional-接口"><a href="#三-函数式-Functional-接口" class="headerlink" title="三.函数式(Functional)接口"></a>三.函数式(Functional)接口</h1><h2 id="1-函数式接口介绍"><a href="#1-函数式接口介绍" class="headerlink" title="1.函数式接口介绍"></a>1.函数式接口介绍</h2><ul><li>Lambda表达式的本质：作为函数式接口的实例</li><li>如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口。我们可以在一个接口上使用    </li><li>@FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口</li><li>在java.util.function包下定义了Java 8 的丰富的函数式接口</li><li>在函数式编程语言当中，函数被当做一等公民对待。在将函数作为一等公民的编程语言中，Lambda表达式的类型是函数。但是在Java8中，有所不同。<strong>在Java8中，Lambda表达式是对象，而不是函数，它们必须依附于一类特别的对象类型——函数式接口</strong></li><li>简单的说，在Java8中，Lambda表达式就是一个函数式接口的实例。这就是Lambda表达式和函数式接口的关系。也就是说，<strong>只要一个对象是函数式接口的实例，那么该对象就可以用Lambda表达式来表示。</strong></li><li><strong>所以以前用匿名实现类表示的现在都可以用Lambda表达式来写</strong></li></ul><h2 id="2-Java内置的函数式接口介绍及使用举例"><a href="#2-Java内置的函数式接口介绍及使用举例" class="headerlink" title="2.Java内置的函数式接口介绍及使用举例"></a>2.Java内置的函数式接口介绍及使用举例</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1660139081593-e83aa5d9-8c1f-4d87-a0d4-018c52439f67.png#clientId=u912af564-828b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u88a8762b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1215&originWidth=1075&originalType=url&ratio=1&rotation=0&showTitle=false&size=168507&status=done&style=none&taskId=ua942a4ef-2d68-4b5a-8b7e-c5f8c0b9f8b&title=" alt="image.png"><br>** java内置的4大核心函数式接口：**</p><ul><li><strong>消费型接口 Consumer<T>     void accept(T t)</strong></li><li><strong>供给型接口 Supplier<T>     T get()</strong></li><li><strong>函数型接口 Function&lt;T,R&gt;   R apply(T t)</strong></li><li><strong>断定型接口 Predicate<T>    boolean test(T t)</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1660139168652-6fc65f3f-7108-458f-8851-deb235d20ffb.png#clientId=u912af564-828b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u39a286d2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1637&originWidth=1009&originalType=url&ratio=1&rotation=0&showTitle=false&size=175119&status=done&style=none&taskId=ud22c16ef-067d-4873-9571-3ebba043d83&title=" alt="image.png"></p><h1 id="四-方法引用与构造器引用"><a href="#四-方法引用与构造器引用" class="headerlink" title="四.方法引用与构造器引用"></a>四.方法引用与构造器引用</h1><ul><li><strong>当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！</strong></li><li>方法引用可以看做是Lambda表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖。</li><li>要求：实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致！</li><li>格式：使用操作符“::” 将类(或对象) 与方法名分隔开来。</li><li>如下三种主要使用情况：<ul><li><strong>对象 :: 实例方法名</strong></li><li><strong>类 :: 静态方法名</strong></li><li><strong>类 :: 实例方法名</strong></li></ul></li></ul><h2 id="1-方法引用的使用情况"><a href="#1-方法引用的使用情况" class="headerlink" title="1. 方法引用的使用情况"></a>1. 方法引用的使用情况</h2><p><strong>方法引用使用的要求</strong></p><ul><li>要求接口中的抽象方法的形参列表和返回值类型与方法引用的方法的形参列表和返回值类型相同！（针对于情况1和情况2）</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1660139401875-80ed70cb-821e-48a0-9da0-239bf10cc885.png#clientId=u912af564-828b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u6a4b62a2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=961&originWidth=976&originalType=url&ratio=1&rotation=0&showTitle=false&size=109546&status=done&style=none&taskId=ud6ff3dfe-678d-4953-a248-14bec9989b3&title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1660139401893-f9560bd2-e960-438c-bdb7-b1516912efe4.png#clientId=u912af564-828b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u3cf6d12b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1258&originWidth=976&originalType=url&ratio=1&rotation=0&showTitle=false&size=129194&status=done&style=none&taskId=ue6c7eba9-932a-448f-b540-8672c412f04&title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1660139415332-3f056c4f-6144-43cf-9705-1fd89107675c.png#clientId=u912af564-828b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u20982cd9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1452&originWidth=951&originalType=url&ratio=1&rotation=0&showTitle=false&size=178343&status=done&style=none&taskId=u6cb0b47f-b6ab-41fa-bbfd-dd22b4db6aa&title=" alt="image.png"></p><h2 id="2-构造器引用与数组引用的使用"><a href="#2-构造器引用与数组引用的使用" class="headerlink" title="2. 构造器引用与数组引用的使用"></a>2. 构造器引用与数组引用的使用</h2><p><strong>格式：ClassName::new</strong><br>与函数式接口相结合，自动与函数式接口中方法兼容。<br>可以把构造器引用赋值给定义的方法，<strong>要求构造器参数列表要与接口中抽象方法的参数列表一致！且方法的返回值即为构造器对应类的对象</strong>。</p><ol><li>构造器引用<ol><li>和方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致。</li><li>抽象方法的返回值类型即为构造器所属的类的类型</li></ol></li><li>数组引用<ol><li>可以把数组看做是一个特殊的类，则写法与构造器引用一致。</li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1660139503672-90645e5e-f2f9-48c9-9c0b-341e9dc3d681.png#clientId=u912af564-828b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u4f87ebc1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=2140&originWidth=1017&originalType=url&ratio=1&rotation=0&showTitle=false&size=229786&status=done&style=none&taskId=ue9d9f4a0-ab6e-4691-bb94-05e2637b55d&title=" alt="image.png"></p><h1 id="五-Stream-API"><a href="#五-Stream-API" class="headerlink" title="五. Stream API"></a>五. Stream API</h1><h2 id="1-Stream-API的概述"><a href="#1-Stream-API的概述" class="headerlink" title="1. Stream API的概述"></a>1. Stream API的概述</h2><ul><li>Java8中有两大最为重要的改变。<strong>第一个是Lambda 表达式；另外一个则是Stream API。</strong></li><li>Stream API ( java.util.stream)把真正的函数式编程风格引入到Java中。这是目前为止对Java类库最好的补充，因为Stream API可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</li><li><strong>Stream 是Java8 中处理集合的关键抽象概念</strong>，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用Stream API 对集合数据进行操作，就类似于使用SQL 执行的数据库查询。也可以使用Stream API 来并行执行操作。简言之，<strong>Stream API 提供了一种高效且易于使用的处理数据的方式。</strong></li><li>为什么要使用Stream API<ul><li>实际开发中，项目中多数数据源都来自于Mysql，Oracle等。但现在数据源可以更多了，有MongDB，Radis等，而这些NoSQL的数据就需要Java层面去处理。</li><li><strong>Stream 和Collection 集合的区别：Collection 是一种静态的内存数据结构，而Stream 是有关计算的。前者是主要面向内存，存储在内存中，后者主要是面向CPU，通过CPU 实现计算。</strong></li></ul></li></ul><p>:::tips</p><ol><li><p>Stream 和Collection 集合的区别</p><ol><li>Stream关注的是对数据的运算，与CPU打交道</li><li>集合关注的是数据的存储，与内存打交道</li></ol></li><li><ol><li>Stream 自己不会存储元素。</li><li>Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</li><li>Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行</li></ol></li><li><p>Stream 执行流程</p><ol><li>Stream的实例化</li><li>一系列的中间操作（过滤、映射、…)</li><li>终止操作</li></ol></li><li><p>说明</p><ol><li>一个中间操作链，对数据源的数据进行处理</li><li>一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用</li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1660139944193-9dd41f2d-c8e4-4261-84b9-e156717b535c.png#clientId=u912af564-828b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u6240f90e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=239&originWidth=1222&originalType=url&ratio=1&rotation=0&showTitle=false&size=47553&status=done&style=none&taskId=u4e09baa0-cd03-4024-a679-57235349c36&title=" alt="image.png"><br>:::</p><h2 id="2-Stream的实例化"><a href="#2-Stream的实例化" class="headerlink" title="2. Stream的实例化"></a>2. Stream的实例化</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1660140011912-25f90e85-1cb4-4cc8-8383-77233b819efb.png#clientId=u912af564-828b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uf0d8922c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1618&originWidth=1007&originalType=url&ratio=1&rotation=0&showTitle=false&size=196375&status=done&style=none&taskId=ua70b0293-4033-4458-829a-ef9102279a3&title=" alt="image.png"></p><h2 id="3-Stream的中间操作"><a href="#3-Stream的中间操作" class="headerlink" title="3. Stream的中间操作"></a>3. Stream的中间操作</h2><h3 id="3-1-筛选与切片"><a href="#3-1-筛选与切片" class="headerlink" title="3.1 筛选与切片"></a>3.1 筛选与切片</h3><p>多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“<strong>惰性求值</strong>”。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1660140123717-fe90629d-1172-4e36-8999-34002ec5da34.png#clientId=u912af564-828b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ue5234460&margin=%5Bobject%20Object%5D&name=image.png&originHeight=398&originWidth=1070&originalType=url&ratio=1&rotation=0&showTitle=false&size=42797&status=done&style=none&taskId=uf7798b79-cfbe-4f20-83e6-9b055835bb8&title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1660140133837-531619ca-b832-4637-ae9e-58606d2761dc.png#clientId=u912af564-828b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u191d4711&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1079&originWidth=1001&originalType=url&ratio=1&rotation=0&showTitle=false&size=161664&status=done&style=none&taskId=u93120a24-4481-48f8-b179-1603c0a8341&title=" alt="image.png"></p><h3 id="3-2-映射"><a href="#3-2-映射" class="headerlink" title="3.2 映射"></a>3.2 映射</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1660140154591-c4422da0-0741-48da-b20b-c9e7eef034e1.png#clientId=u912af564-828b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua00edae1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=518&originWidth=1069&originalType=url&ratio=1&rotation=0&showTitle=false&size=66608&status=done&style=none&taskId=u08912a69-f897-4d5a-b7f7-ca8f2fb612f&title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1660140161748-3f74feab-3ad4-4276-9784-a45dde54f7a0.png#clientId=u912af564-828b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u3bf89f4f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1879&originWidth=1012&originalType=url&ratio=1&rotation=0&showTitle=false&size=223383&status=done&style=none&taskId=u6e72e2d3-9188-4d44-b05e-47c189f64a1&title=" alt="image.png"></p><h3 id="3-3-排序"><a href="#3-3-排序" class="headerlink" title="3.3 排序"></a>3.3 排序</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1660140281979-7d9c7299-908e-4c43-8cbf-963a5a8fbe43.png#clientId=u912af564-828b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u15b63862&margin=%5Bobject%20Object%5D&name=image.png&originHeight=184&originWidth=1067&originalType=url&ratio=1&rotation=0&showTitle=false&size=17684&status=done&style=none&taskId=ue1a4f69d-01a9-47f0-9bb7-150c0509a55&title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1660140286518-470c8d82-c6b0-4cb5-be54-f4aee8b4bac7.png#clientId=u912af564-828b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u4fabd3c0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1029&originWidth=985&originalType=url&ratio=1&rotation=0&showTitle=false&size=120176&status=done&style=none&taskId=uf68d3bd0-aa89-42f9-a64c-da3dc6c60c3&title=" alt="image.png"></p><h2 id="4-Stream的终止操作"><a href="#4-Stream的终止操作" class="headerlink" title="4. Stream的终止操作"></a>4. Stream的终止操作</h2><h3 id="4-1-匹配与查找"><a href="#4-1-匹配与查找" class="headerlink" title="4.1 匹配与查找"></a>4.1 匹配与查找</h3><ul><li>终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是void 。</li><li><strong>流进行了终止操作后，不能再次使用。</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1660140381095-e4096e96-119d-4abf-ae2d-2467077bff75.png#clientId=u912af564-828b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9e8b63cc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=728&originWidth=1067&originalType=url&ratio=1&rotation=0&showTitle=false&size=67663&status=done&style=none&taskId=ud29bff99-ea18-413e-bbfb-b73aa9502e2&title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1660140390926-4099f0f2-cee4-4dd3-95f4-d3571130d67c.png#clientId=u912af564-828b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ud09df9f6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1875&originWidth=995&originalType=url&ratio=1&rotation=0&showTitle=false&size=266457&status=done&style=none&taskId=u9d90e856-7e65-4fe7-9205-2f7371464e0&title=" alt="image.png"></p><h3 id="4-2-归约"><a href="#4-2-归约" class="headerlink" title="4.2 归约"></a>4.2 归约</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1660140430222-67b977a5-905f-4fc8-b2df-ca8c8cf755e1.png#clientId=u912af564-828b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uc0046983&margin=%5Bobject%20Object%5D&name=image.png&originHeight=332&originWidth=1067&originalType=url&ratio=1&rotation=0&showTitle=false&size=46834&status=done&style=none&taskId=uc9bfff67-273f-4bcd-bd96-85e5cf27bd9&title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1660140435994-6fe02924-bbc7-49ee-9619-6b67c786cc13.png#clientId=u912af564-828b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u3efccdcd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=660&originWidth=1001&originalType=url&ratio=1&rotation=0&showTitle=false&size=110087&status=done&style=none&taskId=u125fb990-c7ce-410b-bd7c-c526484893b&title=" alt="image.png"></p><h3 id="4-3-收集"><a href="#4-3-收集" class="headerlink" title="4.3 收集"></a>4.3 收集</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1660140462754-76ea6d61-ce82-4657-a516-6a44fa3fc8cb.png#clientId=u912af564-828b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u604ce99f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=153&originWidth=1077&originalType=url&ratio=1&rotation=0&showTitle=false&size=18700&status=done&style=none&taskId=udbafde54-e546-434f-b393-d85cbd7c539&title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1660140466895-1f568309-35c8-461c-8195-80fec03be460.png#clientId=u912af564-828b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u931d415f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=644&originWidth=977&originalType=url&ratio=1&rotation=0&showTitle=false&size=73026&status=done&style=none&taskId=uaf6d3627-2b65-4361-ab63-c8d7ecdadd9&title=" alt="image.png"><br>Collector 接口中方法的实现决定了如何对流执行收集的操作(如收集到List、Set、Map)。<br>Collectors实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下表：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1660140487183-6f322f56-448e-4603-b95a-8ad579cfe2b1.png#clientId=u912af564-828b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u0377f969&margin=%5Bobject%20Object%5D&name=image.png&originHeight=721&originWidth=1386&originalType=url&ratio=1&rotation=0&showTitle=false&size=259325&status=done&style=none&taskId=ubaf64c1b-4663-45c5-9543-022ec878ce1&title=" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1660140487275-0647aa4a-6f43-47d2-82ca-b4938aba84e5.png#clientId=u912af564-828b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u0f672f2b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=744&originWidth=1348&originalType=url&ratio=1&rotation=0&showTitle=false&size=347534&status=done&style=none&taskId=u17a8bd9f-5d64-4b23-917f-1535da39231&title=" alt="image.png"></p><h1 id="六-Optional类"><a href="#六-Optional类" class="headerlink" title="六.Optional类"></a>六.Optional类</h1><ul><li><strong>Optional 类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。原来用null 表示一个值不存在，现在Optional 可以更好的表达这个概念。并且可以避免空指针异常。</strong></li><li><strong>Optional类的Javadoc描述如下：这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</strong></li><li>Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</li><li><strong>创建Optional类对象的方法：</strong><ul><li>Optional.of(T t): 创建一个Optional 实例，t必须非空；</li><li>Optional.empty() : 创建一个空的Optional 实例</li><li>Optional.ofNullable(T t)：t可以为null</li></ul></li><li><strong>判断Optional容器中是否包含对象：</strong><ul><li>boolean isPresent() : 判断是否包含对象</li><li>void ifPresent(Consumer&lt;? super T&gt; consumer) ：如果有值，就执行Consumer接口的实现代码，并且该值会作为参数传给它。</li></ul></li><li><strong>获取Optional容器的对象：</strong><ul><li>T get(): 如果调用对象包含值，返回该值，否则抛异常</li><li>T orElse(T other) ：如果有值则将其返回，否则返回指定的other对象。</li><li>T orElseGet(Supplier&lt;? extends T&gt; other) ：如果有值则将其返回，否则返回由Supplier接口实现提供的对象。</li><li>T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) ：如果有值则将其返回，否则抛出由Supplier接口实现提供的异常。</li></ul></li></ul><h2 id="1-使用举例"><a href="#1-使用举例" class="headerlink" title="1. 使用举例"></a>1. 使用举例</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1660140632945-8351e1c3-57e6-4a87-b31b-749f0d999384.png#clientId=u912af564-828b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u7324b3e4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=872&originWidth=1293&originalType=url&ratio=1&rotation=0&showTitle=false&size=46019&status=done&style=none&taskId=u58250f31-94e1-4e7f-8724-0e16cc2f6e0&title=" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1660140632986-309bf1a1-cf54-4695-8c43-f6780987cade.png#clientId=u912af564-828b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u0a87cc22&margin=%5Bobject%20Object%5D&name=image.png&originHeight=848&originWidth=1304&originalType=url&ratio=1&rotation=0&showTitle=false&size=47601&status=done&style=none&taskId=uba4402c9-4e30-45ff-98a5-bec22fd04fd&title=" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1660140633148-e0a8512d-f6db-4e6c-b07d-732e05a701c1.png#clientId=u912af564-828b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uba167b2c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1173&originWidth=1311&originalType=url&ratio=1&rotation=0&showTitle=false&size=114772&status=done&style=none&taskId=u74d61778-3ff3-491c-9e1c-7bff10dcc11&title=" alt="image.png"></p><h3 id="1-1-Optional类的使用举例"><a href="#1-1-Optional类的使用举例" class="headerlink" title="1.1 Optional类的使用举例"></a>1.1 Optional类的使用举例</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1660140633242-31218bb3-85dc-48a1-93b1-5782b7e18a4d.png#clientId=u912af564-828b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uae7d7b33&margin=%5Bobject%20Object%5D&name=image.png&originHeight=2066&originWidth=1305&originalType=url&ratio=1&rotation=0&showTitle=false&size=178167&status=done&style=none&taskId=ucaaa3468-c219-4bea-b026-0474183a94f&title=" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Lambda表达式 </tag>
            
            <tag> Stream API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker基础篇</title>
      <link href="/coderbin/2b6e1edf.html"/>
      <url>/coderbin/2b6e1edf.html</url>
      
        <content type="html"><![CDATA[<p>尚硅谷2022版Docker实战教程官方课程资料：<a href="https://pan.baidu.com/s/1AyYbnDRoD-m2xBPvfvjh7Q?pwd=8gfh">https://pan.baidu.com/s/1AyYbnDRoD-m2xBPvfvjh7Q?pwd=8gfh</a><br>提取码：8gfh </p><h1 id="一-Docker简介与安装"><a href="#一-Docker简介与安装" class="headerlink" title="一.Docker简介与安装"></a>一.Docker简介与安装</h1><p>Docker 两个主要部件：</p><ul><li>Docker: 开源的容器虚拟化平台：<a href="http://www.docker.com/">http://www.docker.com</a></li><li>Docker Hub: 用于分享、管理 Docker 容器的 Docker SaaS 平台 – <a href="https://registry.hub.docker.com/search?q=library">Docker Hub</a></li></ul><p><strong>Docker为什么出现？</strong></p><p>解决了<strong>运行环境和配置问题的软件容器</strong>，方便做持续集成并有助于整体发布的容器虚拟化技术。</p><h2 id="1-Docker-基本组成"><a href="#1-Docker-基本组成" class="headerlink" title="1. Docker 基本组成"></a>1. Docker 基本组成</h2><h4 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h4><p>Docker 镜像是 Docker 容器运行时的只读模板，每一个镜像由一系列的层 (layers) 组成。<strong>相当于容器的“源代码”，docker镜像文件类似于Java的类模板，而docker容器实例类似于java中new出来的实例对象。</strong></p><h4 id="Docker-仓库"><a href="#Docker-仓库" class="headerlink" title="Docker 仓库"></a>Docker 仓库</h4><p>Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。</p><h4 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h4><p>Docker 容器和文件夹很类似，一个Docker容器包含了所有的某个应用运行所需要的环境。每一个 Docker 容器都是从 Docker 镜像创建的。</p><h2 id="2-Docker的安装"><a href="#2-Docker的安装" class="headerlink" title="2. Docker的安装"></a>2. Docker的安装</h2><p>参考官方网站：<a href="https://docs.docker.com/engine/install/centos/">Install Docker Engine on CentOS | Docker Documentation</a></p><p>以下操作均需要管理员权限，如果不是root角色下，需要在每条命令前加sudo</p><ol><li>卸载旧版本</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220809205826182.png" alt="image-20220809205826182"></p><ol start="2"><li>安装需要的软件包</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils</span><br></pre></td></tr></table></figure><ol start="3"><li>设置stable镜像仓库</li></ol><p><strong>这里不能按照官网的操作，因为我们要设置自己的阿里云镜像仓库！！</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220809211055365.png" alt="image-20220809211055365"></p><ol start="4"><li>更新yum软件包索引</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220809211114613.png" alt="image-20220809211114613"></p><ol start="5"><li>安装DOCKER CE</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure><ol start="6"><li>启动Docker、查看docker版本</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line">docker -v</span><br></pre></td></tr></table></figure><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220809211514002.png" alt="image-20220809211514002"></p><ol start="7"><li>HelloWorld</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220809211641013.png" alt="image-20220809211641013"></p><h2 id="3-配置阿里云镜像加速"><a href="#3-配置阿里云镜像加速" class="headerlink" title="3. 配置阿里云镜像加速"></a>3. 配置阿里云镜像加速</h2><ol><li>注册一个阿里云账号，进入控制台，选择<strong>容器镜像服务</strong></li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220809211915067.png" alt="image-20220809211915067"></p><ol start="2"><li>直接复制粘贴官方的代码</li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220809212040354.png" alt="image-20220809212040354"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220809212114262.png" alt="image-20220809212114262"></p><h2 id="4-底层原理"><a href="#4-底层原理" class="headerlink" title="4.底层原理"></a>4.底层原理</h2><p>为什么 docker 比 VM虚拟机 快？</p><ol><li>docker有着比虚拟机更少的抽象层<ul><li>由于docker不需要Hypervisor(虚拟机)实现硬件资源虚拟化,运行在docker容器上的程序<strong>直接使用的都是实际物理机的硬件资源</strong>。因此在CPU、内存利用率上docker将会在效率上有明显优势。</li></ul></li><li>docker利用的是宿主机的内核,而不需要加载操作系统OS内核<ul><li>当新建一个容器时,docker<strong>不需要和虚拟机一样重新加载一个操作系统内核</strong>。进而避免引寻、加载操作系统内核返回等比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载OS,返回新建过程是分钟级别的。而<strong>docker由于直接利用宿主机的操作系统</strong>,则省略了返回过程,因此新建一个docker容器只需要几秒钟。</li></ul></li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220809212613336.png" alt="image-20220809212613336"></p><h1 id="二-Docker常用命令"><a href="#二-Docker常用命令" class="headerlink" title="二. Docker常用命令"></a>二. Docker常用命令</h1><h2 id="1-帮助启动类命令"><a href="#1-帮助启动类命令" class="headerlink" title="1. 帮助启动类命令"></a>1. 帮助启动类命令</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>systemctl start docker</td><td>启动docker</td></tr><tr><td>systemctl stop docker</td><td>停止docker</td></tr><tr><td>systemctl restart docker</td><td>重启docker</td></tr><tr><td>systemctl status docker</td><td>查看docker状态</td></tr><tr><td>systemctl enable docker</td><td>开机启动</td></tr><tr><td>docker info</td><td>查看docker概要信息</td></tr><tr><td>docker –help</td><td>查看docker总体帮助文档</td></tr><tr><td>docker 具体命令 –help</td><td>查看docker命令帮助文档</td></tr></tbody></table><h2 id="2-镜像命令"><a href="#2-镜像命令" class="headerlink" title="2. 镜像命令"></a>2. 镜像命令</h2><table><thead><tr><th>命令</th><th>描述</th><th>说明</th></tr></thead><tbody><tr><td>docker images</td><td>列出本地主机上的镜像</td><td><strong>-a</strong> :列出本地所有的镜像 <br/><strong>-q</strong> :只显示镜像ID。</td></tr><tr><td>docker search XXX</td><td>在仓库中搜索某个镜像</td><td><strong>–limit</strong> : 只列出N个镜像，默认25个</td></tr><tr><td>docker pull XXX:[tag]</td><td>下载某个镜像</td><td>没有TAG就是最新版</td></tr><tr><td>docker system df</td><td>查看镜像&#x2F;容器&#x2F;数据卷所占的空间</td><td>无</td></tr><tr><td>docker rmi XXX</td><td>删除某个镜像 （名字&#x2F;ID）</td><td>-f 强制删除 ， 可以一次删除多个</td></tr><tr><td><strong>docker commit -m&#x3D;”提交的描述信息” -a&#x3D;”作者” 容器ID 要创建的目标镜像名:[标签名]</strong></td><td><strong>提交容器副本使之成为一个新的镜像</strong></td><td></td></tr></tbody></table><h2 id="3-容器命令"><a href="#3-容器命令" class="headerlink" title="3. 容器命令"></a>3. 容器命令</h2><p><strong>有镜像才能创建容器，这是根本前提。</strong></p><table><thead><tr><th>命令</th><th>描述</th><th>说明</th></tr></thead><tbody><tr><td><strong>docker run [OPTIONS] IMAGE [COMMAND] [ARG…]</strong></td><td>新建+启动容器</td><td><strong>–name&#x3D;”xxx”</strong>:为容器指定一个名称;<br/><strong>-d</strong>: 后台运行容器并返回容器ID，也即启动守护式容器(后台运行)；<br/><strong>-i</strong>：以交互模式运行容器，通常与 -t 同时使用；<br/><strong>-t</strong>：为容器重新分配一个伪输入终端，通常与 -i 同时使用；<br/><strong>-P</strong>: 随机端口映射，大写P<br/><strong>-p</strong>: 指定端口映射，小写p</td></tr><tr><td>docker ps [OPTIONS]</td><td>列出当前所有<strong>正在运行</strong>的容器</td><td><strong>-a</strong> :列出当前所有正在运行的容器+历史上运行过的<br/><strong>-l</strong> :显示最近创建的容器。<br/><strong>-n</strong>：显示最近n个创建的容器。<br/><strong>-q</strong> :静默模式，只显示容器编号。</td></tr><tr><td>exit;ctrl+p+q</td><td>退出容器</td><td>exit退出，容器停止；ctrl+p+q退出，容器不停止</td></tr><tr><td>docker start ID&#x2F;name</td><td>启动已停止运行的容器</td><td></td></tr><tr><td>docker restart ID&#x2F;name</td><td>重启容器</td><td></td></tr><tr><td>docker stop ID&#x2F;name</td><td>停止容器</td><td></td></tr><tr><td>docker kill ID&#x2F;name</td><td>强制停止容器</td><td></td></tr><tr><td>docker rm ID</td><td>删除已停止的容器</td><td></td></tr><tr><td><strong>docker logs ID</strong></td><td><strong>查看容器日志</strong></td><td></td></tr><tr><td><strong>docker top ID</strong></td><td><strong>查看容器内运行的进程</strong></td><td></td></tr><tr><td><strong>docker inspect ID</strong></td><td><strong>查看容器内部细节</strong></td><td></td></tr><tr><td><strong>docker exec -it 容器ID bashShell<br/>docker attach 容器ID</strong></td><td><strong>进入正在运行的容器并以命令行交互</strong></td><td><strong>attach 直接进入容器启动命令的终端，不会启动新的进程,用exit退出，会导致容器的停止。<br/>exec 是在容器中打开新的终端，并且可以启动新的进程用exit退出，不会导致容器的停止。（推荐）</strong></td></tr><tr><td><strong>docker cp  容器ID:容器内路径    目的主机路径</strong></td><td><strong>从容器内拷贝文件到主机上</strong></td><td></td></tr><tr><td><strong>docker export 容器ID &gt; 文件名.tar</strong></td><td><strong>导出容器</strong></td><td></td></tr><tr><td><strong>cat 文件名.tar | docker import - 镜像用户&#x2F;镜像名:镜像版本号</strong></td><td><strong>导入容器</strong></td><td></td></tr></tbody></table><h1 id="三-Docker容器数据卷"><a href="#三-Docker容器数据卷" class="headerlink" title="三. Docker容器数据卷"></a>三. Docker容器数据卷</h1><p>是什么？</p><p>类似Redis的rdb和aof文件，类似Linux虚拟机和win宿主机共享文件夹。<strong>将docker容器内的数据保存进宿主机的磁盘中</strong>，<strong>运行一个带有容器卷存储功能的容器实例</strong>。</p><h2 id="1-宿主和容器间映射添加容器卷"><a href="#1-宿主和容器间映射添加容器卷" class="headerlink" title="1.宿主和容器间映射添加容器卷"></a>1.宿主和容器间映射添加容器卷</h2><ol><li>通过命令直接挂载</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --privileged=<span class="literal">true</span> -v /宿主机绝对路径目录:/容器内目录   镜像名</span><br></pre></td></tr></table></figure><ol start="2"><li>查看数据卷是否挂载成功</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器ID</span><br></pre></td></tr></table></figure><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220809220356160.png" alt="image-20220809220356160"></p><ol start="3"><li>此时在宿主机或容器的对应挂载目录中修改数据都是同步的。</li></ol><h2 id="2-读写规则映射添加"><a href="#2-读写规则映射添加" class="headerlink" title="2.读写规则映射添加"></a>2.读写规则映射添加</h2><ul><li><p>读写（默认）：re</p><ul><li>docker run -it –privileged&#x3D;true -v &#x2F;宿主机绝对路径目录:&#x2F;容器内目录  镜像名</li></ul></li><li><p>只读：ro</p><ul><li>docker run -it –privileged&#x3D;true -v &#x2F;宿主机绝对路径目录:&#x2F;容器内目录:rw  镜像名</li></ul></li></ul><p>设置了只读之后，在容器中就无法写入内容了。</p><p>此时如果<strong>宿主机写入内容，可以同步给容器内，容器可以读取到</strong>。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220809220741978.png" alt="image-20220809220741978"></p><h2 id="3-卷的继承和共享"><a href="#3-卷的继承和共享" class="headerlink" title="3.卷的继承和共享"></a>3.卷的继承和共享</h2><ol><li>容器1完成和宿主机的映射</li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220809220845322.png" alt="image-20220809220845322"></p><ol start="2"><li>容器2继承容器1的卷规则</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it  --privileged=<span class="literal">true</span> --volumes-from 父类  --name u2 ubuntu</span><br></pre></td></tr></table></figure><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220809220906942.png" alt="image-20220809220906942"></p><h1 id="四-Docker常规安装简介"><a href="#四-Docker常规安装简介" class="headerlink" title="四.Docker常规安装简介"></a>四.Docker常规安装简介</h1><p>总体步骤：</p><ul><li>搜索镜像<ul><li>docker seacher xxx</li></ul></li><li>拉取镜像<ul><li>docker pull xxx</li></ul></li><li>查看镜像<ul><li>docker images</li></ul></li><li>启动镜像<ul><li>服务端口映射</li><li>docker run -it -p xxxx:xxxx xxx</li></ul></li><li>停止容器<ul><li>docker stop xxx</li></ul></li><li>移除容器<ul><li>docker rm xxx(ID)</li></ul></li></ul><p>相关的应用安装参考：</p><ul><li><p><a href="https://www.runoob.com/docker/docker-tutorial.html">Docker 教程 | 菜鸟教程 (runoob.com)</a></p></li><li><p><a href="https://www.w3cschool.cn/docker/">Docker 教程_w3cschool</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的Java客户端</title>
      <link href="/coderbin/bee538b8.html"/>
      <url>/coderbin/bee538b8.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>目前我了解到的有以下4种。</p><ul><li><p>Spring-Data-Redis：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p></li><li><p>Jedis：<a href="https://github.com/redis/jedis/wiki">https://github.com/redis/jedis/wiki</a></p></li><li><p>Lettuce：<a href="https://lettuce.io/">https://lettuce.io/</a> ，这里不做介绍，太高级了，估计hold不住。</p></li><li><p>Redisson ：<a href="https://github.com/redisson/redisson/wiki">https://github.com/redisson/redisson/wiki</a></p></li></ul><h1 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h1><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p> SpringData是Spring中数据操作的模块，包含对各种数据库的集成，相当于定义了一些如增删改查的抽象接口，继而有对应不同数据库的实现。</p><ul><li><a href="https://spring.io/projects/spring-data-jdbc">Spring Data JDBC</a></li><li><a href="https://spring.io/projects/spring-data-jpa">Spring Data JPA</a></li><li><a href="https://spring.io/projects/spring-data-mongodb">Spring Data MongoDB</a></li><li><a href="https://spring.io/projects/spring-data-redis">Spring Data Redis</a></li><li>。。。</li></ul><p> 其中对redis集成模块就叫做Spring Data Redis。</p><ul><li>提供了对不同Redis客户端的整合（Lettuce和Jedis）</li><li>提供了RedisTemplate统一API来操作Redis</li><li>支持Redis的发布订阅模型</li><li>支持Redis哨兵和Redis集群</li><li>支持基于Lettuce的响应式编程</li><li>支持基于JDK.JSON.字符串.Spring对象的数据序列化及反序列化</li><li>支持基于Redis的JDKCollection实现</li></ul><p>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/1652976773295.png" alt="1652976773295"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220808215611419.png" alt="image-20220808215611419"></p><h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h2><h3 id="2-1-引入依赖"><a href="#2-1-引入依赖" class="headerlink" title="2.1 引入依赖"></a>2.1 引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">&lt;!--连接池依赖--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Jackson依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-编写配置文件"><a href="#2-2-编写配置文件" class="headerlink" title="2.2 编写配置文件"></a>2.2 编写配置文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">yourPassword</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span> <span class="comment">#最大连接</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span> <span class="comment">#最大空闲连接</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span> <span class="comment">#最小空闲连接</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">100ms</span> <span class="comment">#连接等待时间</span></span><br></pre></td></tr></table></figure><h3 id="2-3-测试与问题"><a href="#2-3-测试与问题" class="headerlink" title="2.3 测试与问题"></a>2.3 测试与问题</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220808220320953.png" alt="image-20220808220320953"></p><p>可以看到是可以正常写入和获取的，那么我们来看看数据库。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220808220418512.png" alt="image-20220808220418512"></p><p>发现问题：</p><ol><li>插入进来的怎么不是“coderbin”，多了前面一坨东西呢？</li><li>为什么查不到值呢？</li></ol><p>追溯问题：</p><p><strong>RedisTemplate可以接收任意Object作为值写入Redis，只不过写入前会把Object序列化为字节形式，<code>默认是采用JDK序列化</code>，得到的结果就是上图所示</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220808223410139.png" alt="image-20220808223410139"></p><h3 id="2-4-解决序列化问题"><a href="#2-4-解决序列化问题" class="headerlink" title="2.4 解决序列化问题"></a>2.4 解决序列化问题</h3><p>简单方法：直接不用RedisTemplate，我们用<strong>StringRedisTemplate.</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220808223818068.png" alt="image-20220808223818068"></p><p>正常输出，再去看数据库。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220808223858701.png" alt="image-20220808223858701"></p><p>键值的数据也是正常的，但是！这里又有问题。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220808224023585.png" alt="image-20220808224023585"></p><p>stringRedisTemplate的set方法要求键值都为string类型，这就无法满足我们的需求。</p><p><strong>那么我们就要自定义RedisTemplate的序列化方式啦！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 创建JSON序列化工具</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">jsonRedisSerializer</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        <span class="comment">// 设置Key的序列化</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// 设置Value的序列化</span></span><br><span class="line">        template.setValueSerializer(jsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jsonRedisSerializer);</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220808225246034.png" alt="image-20220808225246034"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220808225305305.png" alt="image-20220808225305305"></p><p>可以看到已经大功告成了。</p><p>总结一下：</p><p>RedisTemplate的两种序列化实践方案：</p><ul><li><p>方案一：</p><ul><li>自定义RedisTemplate</li><li>修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer</li></ul></li><li><p>方案二：</p><ul><li>使用StringRedisTemplate</li><li>写入Redis时，手动把对象序列化为JSON</li><li>读取Redis时，手动把读取到的JSON反序列化为对象</li></ul></li></ul><h1 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h1><p><a href="https://blog.csdn.net/zhangguanghui002/article/details/78770071">(25条消息) Jedis常用方法API_遛狗大师的博客-CSDN博客_jedis方法</a></p><p>使用<strong>阻塞的I&#x2F;O，且其方法调用都是同步的（慢！）</strong>，程序流需要等到sockets处理完I&#x2F;O才能执行，不支持异步。Jedis客户端实例不是线程安全的，所以需要通过连接池来使用Jedis。</p><h2 id="1-快速入门"><a href="#1-快速入门" class="headerlink" title="1.快速入门"></a>1.快速入门</h2><h3 id="1-1引入依赖"><a href="#1-1引入依赖" class="headerlink" title="1.1引入依赖"></a>1.1引入依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--jedis--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.7.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="1-2-创建连接池"><a href="#1-2-创建连接池" class="headerlink" title="1.2 创建连接池"></a>1.2 创建连接池</h3><blockquote><p>Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式</p><p>有关池化思想，并不仅仅是这里会使用，很多地方都有，比如说我们的数据库连接池，比如我们tomcat中的线程池，这些都是池化思想的体现。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConnectionFacotry</span> &#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">static</span> &#123;</span><br><span class="line">         <span class="comment">//配置连接池</span></span><br><span class="line">         <span class="type">JedisPoolConfig</span> <span class="variable">poolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">         poolConfig.setMaxTotal(<span class="number">8</span>);</span><br><span class="line">         poolConfig.setMaxIdle(<span class="number">8</span>);</span><br><span class="line">         poolConfig.setMinIdle(<span class="number">0</span>);</span><br><span class="line">         poolConfig.setMaxWaitMillis(<span class="number">1000</span>);</span><br><span class="line">         <span class="comment">//创建连接池对象</span></span><br><span class="line">         jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(poolConfig,</span><br><span class="line">                 <span class="string">&quot;localhost&quot;</span>,<span class="number">6379</span>,<span class="number">1000</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-测试"><a href="#1-3-测试" class="headerlink" title="1.3 测试"></a>1.3 测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="comment">//建立连接</span></span><br><span class="line">      <span class="comment">/*jedis = new Jedis(&quot;127.0.0.1&quot;,6379);*/</span></span><br><span class="line">      jedis = JedisConnectionFacotry.getJedis();</span><br><span class="line">       <span class="comment">//选择库</span></span><br><span class="line">      jedis.select(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// 插入hash数据</span></span><br><span class="line">      jedis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">      jedis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获取</span></span><br><span class="line">      Map&lt;String, String&gt; map = jedis.hgetAll(<span class="string">&quot;user:1&quot;</span>);</span><br><span class="line">      System.out.println(map);</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="meta">@AfterEach</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">          jedis.close();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220808230515826.png" alt="image-20220808230515826"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220808230527191.png" alt="image-20220808230527191"></p><p>测试成功！</p><h1 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h1><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多<strong>分布式服务</strong>。Redisson的宗旨是<strong>促进使用者对Redis的关注分离</strong>（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。</p><h2 id="1-快速入门-1"><a href="#1-快速入门-1" class="headerlink" title="1.快速入门"></a>1.快速入门</h2><h3 id="1-1-引入依赖"><a href="#1-1-引入依赖" class="headerlink" title="1.1 引入依赖"></a>1.1 引入依赖</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">3.13</span><span class="number">.6</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="1-2-配置Redisson客户端"><a href="#1-2-配置Redisson客户端" class="headerlink" title="1.2 配置Redisson客户端"></a>1.2 配置Redisson客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 配置</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.150.101:6379&quot;</span>)</span><br><span class="line">            .setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建RedissonClient对象</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-3-使用Redission的分布式锁"><a href="#1-3-使用Redission的分布式锁" class="headerlink" title="1.3 使用Redission的分布式锁"></a>1.3 使用Redission的分布式锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissionClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testRedisson</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//获取锁(可重入)，指定锁的名称</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;anyLock&quot;</span>);</span><br><span class="line">    <span class="comment">//尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁自动释放时间，时间单位</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1</span>,<span class="number">10</span>,TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">//判断获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span>(isLock)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行业务&quot;</span>);          </span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redisson有非常多的分布式服务：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220808232552996.png" alt="image-20220808232552996"></p><p>具体的各个用法需要结合官网和你的具体业务实现。</p><h1 id="Java客户端总结"><a href="#Java客户端总结" class="headerlink" title="Java客户端总结"></a>Java客户端总结</h1><ul><li>如果<strong>使用了Spring</strong>，并且没有过多的定制化要求，那么大可以<strong>选择Spring Data Redis</strong></li><li>如果<strong>没有使用Spring</strong>，只需要实现简单的业务，也<strong>没有过高的性能要求</strong>，那么可以<strong>选择Jedis</strong></li><li>如果<strong>没有使用Spring</strong>，并且<strong>追求高性能、高定制化</strong>，可以<strong>用 Lettuce</strong>，支持异步、连接池</li><li>如果项目是<strong>分布式架构</strong>，<strong>需要一些分布式服务</strong>（分布式锁，分布式集合等等），那么可以<strong>选择Redisson</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> Java </tag>
            
            <tag> Jedis </tag>
            
            <tag> Spring Data Redis </tag>
            
            <tag> Redisson </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础实战</title>
      <link href="/coderbin/3e609eef.html"/>
      <url>/coderbin/3e609eef.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="一-Redis入门"><a href="#一-Redis入门" class="headerlink" title="一.Redis入门"></a>一.Redis入门</h1><h1 id="1-初识Redis"><a href="#1-初识Redis" class="headerlink" title="1.初识Redis"></a>1.初识Redis</h1><p>Redis 是一种<strong>键值型</strong>的<strong>NoSql</strong>数据库。</p><blockquote><p><strong>键值型</strong>：是指Redis中存储的数据都是<strong>以key、value对的形式存储</strong>，而value的形式多种多样，可以是字符串、数值、甚至json</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/6U1Rhxo.png#crop=0&crop=0&crop=1&crop=1&id=dJPXr&originHeight=468&originWidth=1112&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p></blockquote><h2 id="1-1-认识NoSQL"><a href="#1-1-认识NoSQL" class="headerlink" title="1.1 认识NoSQL"></a>1.1 认识NoSQL</h2><h3 id="1-1-1-什么是NoSQL"><a href="#1-1-1-什么是NoSQL" class="headerlink" title="1.1.1 什么是NoSQL"></a>1.1.1 什么是NoSQL</h3><hr><ul><li>NoSQL最常见的解释是”<code>non-relational</code>“， 很多人也说它是”<strong><em>Not Only SQL</em></strong>“</li><li>NoSQL仅仅是一个概念，泛指<strong>非关系型的数据库</strong></li><li>区别于关系数据库，它们不保证关系数据的ACID特性</li><li>NoSQL是一项全新的数据库革命性运动，提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入</li><li>常见的NoSQL数据库有：<code>Redis</code>、<code>MemCache</code>、<code>MongoDB</code>等</li></ul><h3 id="1-1-2-NoSQL与SQL的差异"><a href="#1-1-2-NoSQL与SQL的差异" class="headerlink" title="1.1.2 NoSQL与SQL的差异"></a>1.1.2 NoSQL与SQL的差异</h3><hr><table><thead><tr><th></th><th>SQL</th><th>NoSQL</th></tr></thead><tbody><tr><td>数据结构</td><td>结构化</td><td>非结构化</td></tr><tr><td>数据关联</td><td>关联的</td><td>无关联的</td></tr><tr><td>查询方式</td><td>SQL查询</td><td>非SQL</td></tr><tr><td>事务特性</td><td>ACID</td><td>BASE</td></tr><tr><td>存储方式</td><td>磁盘</td><td>内存</td></tr><tr><td>扩展性</td><td>垂直</td><td>水平</td></tr><tr><td>使用场景</td><td>1）数据结构固定</td><td>1）数据结构不固定</td></tr><tr><td></td><td></td><td>2）相关业务对数据安全性、一致性要求较高</td></tr><tr><td></td><td></td><td>3）对性能要求</td></tr></tbody></table><h1 id="2-Redis常见命令"><a href="#2-Redis常见命令" class="headerlink" title="2.Redis常见命令"></a>2.Redis常见命令</h1><blockquote><p>我们可以通过Redis的中文文档：<a href="http://www.redis.cn/commands.html%EF%BC%8C%E6%9D%A5%E5%AD%A6%E4%B9%A0%E5%90%84%E7%A7%8D%E5%91%BD%E4%BB%A4%E3%80%82">http://www.redis.cn/commands.html，来学习各种命令。</a></p><p>也可以通过菜鸟教程官网来学习：<a href="https://www.runoob.com/redis/redis-keys.html">https://www.runoob.com/redis/redis-keys.html</a></p></blockquote><h2 id="2-1-Redis数据类型"><a href="#2-1-Redis数据类型" class="headerlink" title="2.1 Redis数据类型"></a>2.1 Redis数据类型</h2><blockquote><p>Redis 是一种key-value数据库，一般key都是String，value的类型五花八门。</p></blockquote><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/8tli2o9.png#crop=0&crop=0&crop=1&crop=1&id=ASqtX&originHeight=673&originWidth=1299&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="2-2-Redis基本命令"><a href="#2-2-Redis基本命令" class="headerlink" title="2.2 Redis基本命令"></a>2.2 Redis基本命令</h2><blockquote><p>通用指令是部分数据类型的，都可以使用的指令</p></blockquote><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>KEYS</td><td>查看符合模板的所有key</td></tr><tr><td>DEL</td><td>删除一个指定的key</td></tr><tr><td>EXISTS</td><td>判断key是否存在</td></tr><tr><td>EXPIRE</td><td>给一个key设置有效期，有效期到期时该key会被自动删除</td></tr><tr><td>TTL</td><td>查看一个KEY的剩余有效期</td></tr></tbody></table><p><strong>通过help [command] 可以查看一个命令的具体用法</strong></p><h2 id="2-3-String类型"><a href="#2-3-String类型" class="headerlink" title="2.3 String类型"></a>2.3 String类型</h2><p>字符串类型，Redis中最简单的存储类型。</p><p>其value是字符串，但是根据字符串的格式不同，可以分为三类：</p><ul><li>string：普通字符串</li><li>int：整数类型，可以做自增、自减操作。</li><li>float：浮点类型，可以做自增、自减操作。</li></ul><p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m.</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/VZqpv73.png#crop=0&crop=0&crop=1&crop=1&id=N5h6p&originHeight=268&originWidth=1184&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="2-3-1-String类型常用命令"><a href="#2-3-1-String类型常用命令" class="headerlink" title="2.3.1 String类型常用命令"></a>2.3.1 String类型常用命令</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>SET</td><td>添加或者修改已经存在的一个String类型的键值对</td></tr><tr><td>GET</td><td>根据key获取String类型的value</td></tr><tr><td>MSET</td><td>批量添加多个String类型的键值对</td></tr><tr><td>MGET</td><td>根据多个key获取多个String类型的value</td></tr><tr><td>INCR</td><td>让一个整型的key自增1</td></tr><tr><td>INCRBY</td><td>让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</td></tr><tr><td>INCRBYFLOAT</td><td>让一个浮点类型的数字自增并指定步长</td></tr><tr><td><strong>SETNX</strong></td><td>添加一个String类型的键值对，前提是这个key不存在，否则不执行</td></tr><tr><td>SETEX</td><td>添加一个String类型的键值对，并且指定有效期</td></tr></tbody></table><h2 id="2-4-Hash类型"><a href="#2-4-Hash类型" class="headerlink" title="2.4 Hash类型"></a>2.4 Hash类型</h2><blockquote><p><strong>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的</strong><code>**HashMap**</code><strong>结构。</strong></p></blockquote><ul><li><strong>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD</strong> <img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220525001227167.png#crop=0&crop=0&crop=1&crop=1&id=WqQ2c&originHeight=296&originWidth=693&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="> </li><li><strong>Hash的常见命令有：</strong>  <table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>HSET key field value</td><td>添加或者修改hash类型key的field的值</td></tr><tr><td>HGET key field</td><td>获取一个hash类型key的field的值</td></tr><tr><td>HMSET</td><td>hmset 和 hset 效果相同 ，4.0之后hmset可以弃用了</td></tr><tr><td>HMGET</td><td>批量获取多个hash类型key的field的值</td></tr><tr><td>HGETALL</td><td>获取一个hash类型的key中的所有的field和value</td></tr><tr><td>HKEYS</td><td>获取一个hash类型的key中的所有的field</td></tr><tr><td>HVALS</td><td>获取一个hash类型的key中的所有的value</td></tr><tr><td>HINCRBY</td><td>让一个hash类型key的字段值自增并指定步长</td></tr><tr><td>HSETNX</td><td>添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</td></tr></tbody></table></li></ul><h2 id="2-5-List类型"><a href="#2-5-List类型" class="headerlink" title="2.5 List类型"></a>2.5 List类型</h2><blockquote><p><strong>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</strong></p></blockquote><p><strong>特征也与</strong><code>**LinkedList**</code><strong>类似：</strong></p><ul><li>有序</li><li>元素可以重复</li><li>插入和删除快</li><li>查询速度一般</li></ul><p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等.</p><blockquote><p><strong>List的常见命令有</strong></p></blockquote><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>LPUSH key  element …</td><td>向列表左侧插入一个或多个元素</td></tr><tr><td>LPOP key</td><td>移除并返回列表左侧的第一个元素，没有则返回nil</td></tr><tr><td><strong>RPUSH key  element …</strong></td><td>向列表右侧插入一个或多个元素</td></tr><tr><td>RPOP key</td><td>移除并返回列表右侧的第一个元素</td></tr><tr><td>LRANGE key star end</td><td>返回一段角标范围内的所有元素</td></tr><tr><td>BLPOP和BRPOP</td><td>与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</td></tr></tbody></table><h2 id="2-6-Set类型"><a href="#2-6-Set类型" class="headerlink" title="2.6 Set类型"></a>2.6 Set类型</h2><blockquote><p><strong>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征</strong></p></blockquote><ul><li>无序</li><li>元素不可重复</li><li>查找快</li><li>支持交集、并集、差集等功能</li></ul><blockquote><p><strong>Set的常见命令有</strong></p></blockquote><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>SADD key member …</td><td>向set中添加一个或多个元素</td></tr><tr><td>SREM key member …</td><td>移除set中的指定元素</td></tr><tr><td>SCARD key</td><td>返回set中元素的个数</td></tr><tr><td>SISMEMBER key member</td><td>判断一个元素是否存在于set中</td></tr><tr><td>SMEMBERS</td><td>获取set中的所有元素</td></tr><tr><td>SINTER key1 key2 …</td><td>求key1与key2的交集</td></tr><tr><td>SDIFF key1 key2 …</td><td>求key1与key2的差集</td></tr><tr><td>SUNION key1 key2 ..</td><td>求key1和key2的并集</td></tr></tbody></table><h2 id="2-7-SortedSet-zset-类型"><a href="#2-7-SortedSet-zset-类型" class="headerlink" title="2.7 SortedSet(zset)类型"></a>2.7 SortedSet(zset)类型</h2><blockquote><p><strong>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</strong></p></blockquote><p><strong>SortedSet具备下列特性：</strong></p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p><blockquote><p><strong>SortedSet的常见命令有</strong></p></blockquote><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>ZADD key score member</td><td>添加一个或多个元素到sorted set ，如果已经存在则更新其score值</td></tr><tr><td>ZREM key member</td><td>删除sorted set中的一个指定元素</td></tr><tr><td>ZSCORE key member</td><td>获取sorted set中的指定元素的score值</td></tr><tr><td>ZRANK key member</td><td>获取sorted set 中的指定元素的排名</td></tr><tr><td>ZCARD key</td><td>获取sorted set中的元素个数</td></tr><tr><td>ZCOUNT key min max</td><td>统计score值在给定范围内的所有元素的个数</td></tr><tr><td>ZINCRBY key increment member</td><td>让sorted set中的指定元素自增，步长为指定的increment值</td></tr><tr><td>ZRANGE key min max</td><td>按照score排序后，获取指定排名范围内的元素</td></tr><tr><td>ZRANGEBYSCORE key min max</td><td>按照score排序后，获取指定score范围内的元素</td></tr><tr><td>ZDIFF、ZINTER、ZUNION</td><td>求差集、交集、并集</td></tr></tbody></table><p><strong>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加</strong><code>**REV**</code><strong>即可</strong></p><blockquote><p><strong>跳跃表</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220725164212963.png#crop=0&crop=0&crop=1&crop=1&id=YPvjN&originHeight=254&originWidth=865&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>从第2层开始，1节点比51节点小，向后比较。</p><p>21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层</p><p>在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下</p><p>在第0层，51节点为要查找的节点，节点被找到，共查找4次。</p><p>从此可以看出跳跃表比有序链表效率要高</p></blockquote><h1 id="3-Redis-客户端"><a href="#3-Redis-客户端" class="headerlink" title="3.Redis 客户端"></a>3.Redis 客户端</h1><h2 id="3-Java客户端"><a href="#3-Java客户端" class="headerlink" title="3.Java客户端"></a>3.Java客户端</h2><h3 id="3-1Jedis快速入门"><a href="#3-1Jedis快速入门" class="headerlink" title="3.1Jedis快速入门"></a>3.1Jedis快速入门</h3><hr><blockquote><p>该部分参考：<a href="https://www.oz6.cn/articles/58">https://www.oz6.cn/articles/58</a><br>Jedis的官网地址： <a href="https://github.com/redis/jedis%EF%BC%8C%E6%88%91%E4%BB%AC%E5%85%88%E6%9D%A5%E4%B8%AA%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%9A">https://github.com/redis/jedis，我们先来个快速入门：</a></p></blockquote><ul><li><p><strong>新建一个Maven工程并引入以下依赖</strong> </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入Jedis依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--引入单元测试依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>编写测试类并与Redis建立连接</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BeforeEach</span> <span class="comment">//被该注解修饰的方法每次执行其他方法前自动执行</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1. 获取连接</span></span><br><span class="line">    jedis = <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.230.88&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">    <span class="comment">// 2. 设置密码</span></span><br><span class="line">    jedis.auth(<span class="string">&quot;132537&quot;</span>);</span><br><span class="line">    <span class="comment">// 3. 选择库（默认是下标为0的库）</span></span><br><span class="line">    jedis.select(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>编写一个操作数据的方法（这里以操作String类型为例）</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1.往redis中存放一条String类型的数据并获取返回结果</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(<span class="string">&quot;url&quot;</span>, <span class="string">&quot;www.oz6.cn&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.从redis中获取一条数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;url = &quot;</span> + url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>最后不要忘记编写一个释放资源的方法</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterEach</span> <span class="comment">//被该注解修饰的方法会在每次执行其他方法后执行</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1.释放资源</span></span><br><span class="line">    <span class="keyword">if</span> (jedis != <span class="literal">null</span>)&#123;</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>执行</strong><code>**testString()**</code><strong>方法后测试结果如图所示</strong><br><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220525131017888.png#crop=0&crop=0&crop=1&crop=1&id=GGLks&originHeight=201&originWidth=808&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p></li></ul><h3 id="3-2Jedis连接池"><a href="#3-2Jedis连接池" class="headerlink" title="3.2Jedis连接池"></a>3.2Jedis连接池</h3><hr><blockquote><p><strong>Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConnectionFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//配置连接池</span></span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">jedisPoolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        jedisPoolConfig.setMaxTotal(<span class="number">8</span>);</span><br><span class="line">        jedisPoolConfig.setMaxIdle(<span class="number">8</span>);</span><br><span class="line">        jedisPoolConfig.setMinIdle(<span class="number">0</span>);</span><br><span class="line">        jedisPoolConfig.setMaxWaitMillis(<span class="number">200</span>);</span><br><span class="line">        <span class="comment">//创建连接池对象</span></span><br><span class="line">        jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(jedisPoolConfig,<span class="string">&quot;192.168.230.88&quot;</span>,<span class="number">6379</span>,<span class="number">1000</span>,<span class="string">&quot;132537&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3SpringDataRedis介绍"><a href="#3-3SpringDataRedis介绍" class="headerlink" title="3.3SpringDataRedis介绍"></a>3.3SpringDataRedis介绍</h3><hr><blockquote><p><strong>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做</strong><code>**SpringDataRedis**</code></p><p><strong>官网地址</strong>：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p></blockquote><ul><li>提供了对不同Redis客户端的整合（<code>Lettuce</code>和<code>Jedis</code>）</li><li>提供了<code>RedisTemplate</code>统一API来操作Redis</li><li>支持Redis的发布订阅模型</li><li>支持Redis哨兵和Redis集群</li><li>支持基于Lettuce的响应式编程</li><li>支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化</li><li>支持基于Redis的JDKCollection实现</li></ul><blockquote><p><strong>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</strong></p></blockquote><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220525140217446.png#crop=0&crop=0&crop=1&crop=1&id=GkakR&originHeight=364&originWidth=1091&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="3-4-SpringDataRedis快速入门"><a href="#3-4-SpringDataRedis快速入门" class="headerlink" title="3.4 SpringDataRedis快速入门"></a>3.4 SpringDataRedis快速入门</h3><hr><blockquote><p><code>**SpringBoot**</code><strong>已经提供了对</strong><code>**SpringDataRedis**</code><strong>的支持，使用非常简单</strong></p></blockquote><ul><li><p><strong>首先新建一个Spring Boot工程</strong><br><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220525141608974.png#crop=0&crop=0&crop=1&crop=1&id=fVBRk&originHeight=594&originWidth=1042&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="> </p></li><li><p><strong>然后引入连接池依赖</strong> </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--连接池依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>编写配置文件</strong><code>**application.yml**</code><strong>（连接池的配置在实际开发中是根据需求来的）</strong> </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.230</span><span class="number">.88</span> <span class="comment">#指定redis所在的host</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span>  <span class="comment">#指定redis的端口</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">132537</span>  <span class="comment">#设置redis密码</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span> <span class="comment">#最大连接数</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span> <span class="comment">#最大空闲数</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span> <span class="comment">#最小空闲数</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">100ms</span> <span class="comment">#连接等待时间</span></span><br></pre></td></tr></table></figure></li><li><p><strong>编写测试类执行测试方法</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisDemoApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 1.通过RedisTemplate获取操作String类型的ValueOperations对象</span></span><br><span class="line"><span class="type">ValueOperations</span> <span class="variable">ops</span> <span class="operator">=</span> redisTemplate.opsForValue();</span><br><span class="line"><span class="comment">// 2.插入一条数据</span></span><br><span class="line">ops.set(<span class="string">&quot;blogName&quot;</span>,<span class="string">&quot;Vz-Blog&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.获取数据</span></span><br><span class="line"><span class="type">String</span> <span class="variable">blogName</span> <span class="operator">=</span> (String) ops.get(<span class="string">&quot;blogName&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;blogName = &quot;</span> + blogName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-5RedisSerializer配置"><a href="#3-5RedisSerializer配置" class="headerlink" title="3.5RedisSerializer配置"></a>3.5RedisSerializer配置</h3><hr><blockquote><p><strong>RedisTemplate可以接收任意Object作为值写入Redis，只不过写入前会把Object序列化为字节形式，</strong><code>**默认是采用JDK序列化**</code><strong>，得到的结果是这样的</strong></p></blockquote><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220525170205272.png#crop=0&crop=0&crop=1&crop=1&id=KXcNr&originHeight=248&originWidth=784&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p><strong>缺点：</strong></p><ul><li>可读性差</li><li>内存占用较大</li></ul><blockquote><p><strong>那么如何解决以上的问题呢？我们可以通过自定义RedisTemplate序列化的方式来解决。</strong></p></blockquote><ul><li><p><strong>编写一个配置类</strong><code>**RedisConfig**</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String,Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String ,Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 2.设置连接工厂</span></span><br><span class="line">        redisTemplate.setConnectionFactory(factory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.创建序列化对象</span></span><br><span class="line">        <span class="type">StringRedisSerializer</span> <span class="variable">stringRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">genericJackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.设置key和hashKey采用String的序列化方式</span></span><br><span class="line">        redisTemplate.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        redisTemplate.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.设置value和hashValue采用json的序列化方式</span></span><br><span class="line">        redisTemplate.setValueSerializer(genericJackson2JsonRedisSerializer);</span><br><span class="line">        redisTemplate.setHashValueSerializer(genericJackson2JsonRedisSerializer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>此时我们已经将RedisTemplate的key设置为</strong><code>**String序列化**</code><strong>，value设置为</strong><code>**Json序列化**</code><strong>的方式，再来执行方法测试</strong><br><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220525170925364.png#crop=0&crop=0&crop=1&crop=1&id=yBQO0&originHeight=244&originWidth=785&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="> </p></li><li><p><strong>由于我们设置的value序列化方式是Json的，因此我们可以直接向redis中插入一个对象</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> &#123;</span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;user:100&quot;</span>, <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Vz&quot;</span>, <span class="number">21</span>));</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) redisTemplate.opsForValue().get(<span class="string">&quot;user:100&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;User = &quot;</span> + user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220525171340322.png#crop=0&crop=0&crop=1&crop=1&id=Z7tp9&originHeight=333&originWidth=788&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>尽管Json序列化可以满足我们的需求，但是依旧存在一些问题。<br>如上图所示，为了在反序列化时知道对象的类型，JSON序列化器会将类的class类型写入json结果中，存入Redis，会带来额外的内存开销。<br>那么我们如何解决这个问题呢？我们可以通过下文的<code>StringRedisTemplate</code>来解决这个问题。 </p><h3 id="3-6StringRedisTemplate"><a href="#3-6StringRedisTemplate" class="headerlink" title="3.6StringRedisTemplate"></a>3.6StringRedisTemplate</h3><hr><blockquote><p><strong>为了节省内存空间，我们并不会使用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，手动完成对象的序列化和反序列化。</strong></p></blockquote><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220525172001057.png#crop=0&crop=0&crop=1&crop=1&id=kmcQH&originHeight=385&originWidth=1161&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><blockquote><p><strong>Spring默认提供了一个StringRedisTemplate类，它的key和value的序列化方式默认就是String方式。省去了我们自定义RedisTemplate的过程</strong></p></blockquote><ul><li><p><strong>我们可以直接编写一个测试类使用StringRedisTemplate来执行以下方法</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisStringTemplateTest</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line"><span class="comment">// 1.创建一个Json序列化对象</span></span><br><span class="line"><span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"><span class="comment">// 2.将要存入的对象通过Json序列化对象转换为字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">userJson1</span> <span class="operator">=</span> objectMapper.writeValueAsString(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Vz&quot;</span>, <span class="number">21</span>));</span><br><span class="line"><span class="comment">// 3.通过StringRedisTemplate将数据存入redis</span></span><br><span class="line">stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:100&quot;</span>,userJson1);</span><br><span class="line"><span class="comment">// 4.通过key取出value</span></span><br><span class="line"><span class="type">String</span> <span class="variable">userJson2</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:100&quot;</span>);</span><br><span class="line"><span class="comment">// 5.由于取出的值是String类型的Json字符串，因此我们需要通过Json序列化对象来转换为java对象</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> objectMapper.readValue(userJson2, User.class);</span><br><span class="line"><span class="comment">// 6.打印结果</span></span><br><span class="line">System.out.println(<span class="string">&quot;user = &quot;</span> + user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>执行完毕回到Redis的图形化客户端查看结果</strong><br><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220525172508234.png#crop=0&crop=0&crop=1&crop=1&id=AuuKA&originHeight=302&originWidth=786&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p></li></ul><h3 id="3-7总结"><a href="#3-7总结" class="headerlink" title="3.7总结"></a>3.7总结</h3><hr><blockquote><p>RedisTemplate的两种序列化实践方案，两种方案各有各的优缺点，可以根据实际情况选择使用。</p></blockquote><p>方案一：</p><ol><li>自定义RedisTemplate</li><li>修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer</li></ol><p>方案二：</p><ol><li>使用StringRedisTemplate</li><li>写入Redis时，手动把对象序列化为JSON</li><li>读取Redis时，手动把读取到的JSON反序列化为对象</li></ol><h1 id="二-Redis实战"><a href="#二-Redis实战" class="headerlink" title="二.Redis实战"></a>二.Redis实战</h1><h1 id="1-缓存"><a href="#1-缓存" class="headerlink" title="1.缓存"></a>1.缓存</h1><h2 id="1-1-为什么用缓存"><a href="#1-1-为什么用缓存" class="headerlink" title="1.1 为什么用缓存"></a>1.1 为什么用缓存</h2><p><strong>速度快，好用</strong></p><p>缓存数据存储于代码中,而代码运行在内存中,<strong>内存的读写性能远高于磁盘</strong>,缓存可以大大降低<strong>用户访问并发量带来的</strong>服务器读写压力</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/image-20220523214414123.png#crop=0&crop=0&crop=1&crop=1&id=j0BAi&originHeight=518&originWidth=1341&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="1-2-缓存模型与思路"><a href="#1-2-缓存模型与思路" class="headerlink" title="1.2 缓存模型与思路"></a>1.2 缓存模型与思路</h2><p>标准的操作方式就是<strong>查询数据库之前先查询缓存</strong>，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，然后将数据存入redis。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/1653322097736.png#crop=0&crop=0&crop=1&crop=1&id=PZRHb&originHeight=768&originWidth=1514&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>代码如下：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/1653322190155.png#crop=0&crop=0&crop=1&crop=1&id=MGHyo&originHeight=768&originWidth=1063&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="1-3-缓存更新策略"><a href="#1-3-缓存更新策略" class="headerlink" title="1.3 缓存更新策略"></a>1.3 缓存更新策略</h2><p>缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适。</p><ul><li><strong>内存淘汰</strong>：当redis内存达到我们设置的阈值（max-memery）时，自动触发淘汰机制。</li><li><strong>超时剔除</strong>：给数据添加TTL时间，到时间自动剔除。</li><li><strong>主动更新</strong>：我们可以手动调用方法把缓存删掉，<strong>通常用于解决缓存和数据库不一致问题</strong></li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/1653322506393.png#crop=0&crop=0&crop=1&crop=1&id=Ku1Ww&originHeight=729&originWidth=1564&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="1-3-1-缓存与数据库数据不一致解决方案及选择"><a href="#1-3-1-缓存与数据库数据不一致解决方案及选择" class="headerlink" title="1.3.1 缓存与数据库数据不一致解决方案及选择"></a>1.3.1 缓存与数据库数据不一致解决方案及选择</h3><p><strong>缓存中的数据是来自于数据库</strong>的，但是<strong>数据库的数据是会改变</strong>的，如果<strong>数据库数据改变，缓存的数据没有改变</strong>，就会<strong>导致一致性问题</strong>，就会导致用户使用的是过时的数据，影响用户体验，有如下三种解决方案：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>Cache Aside Pattern ✔</td><td>人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为<strong>双写方案</strong></td></tr><tr><td>Read&#x2F;Write Through Pattern</td><td>由系统本身完成，数据库与缓存的问题交由系统本身去处理</td></tr><tr><td>Write Behind Caching Pattern</td><td>调用者只操作缓存，其他线程去异步处理数据库，实现最终一致</td></tr></tbody></table><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/1653322857620.png#crop=0&crop=0&crop=1&crop=1&id=aTszM&originHeight=550&originWidth=1547&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>这里综合考虑我们选择<strong>方案一！</strong>✔</p><p>操作缓存和数据库时有三个问题需要考虑：</p><p>如果采用第一个方案，那么假设我们每次操作数据库后，都操作缓存，但是中间如果没有人查询，那么这个更新动作实际上只有最后一次生效，中间的更新动作意义并不大，我们可以<strong>把缓存删除，等待再次查询时，将缓存中的数据加载出来</strong></p><ul><li><strong>删除缓存还是更新缓存？</strong> <ul><li>更新缓存：每次更新数据库都更新缓存，无效写操作较多</li><li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存 ✔</li></ul></li><li><strong>如何保证缓存与数据库的操作的同时成功或失败？</strong> <ul><li>单体系统，将缓存与数据库操作放在一个事务</li><li>分布式系统，利用TCC等分布式事务方案</li></ul></li></ul><p>应该具体操作缓存还是操作数据库，我们应当是<strong>先操作数据库，再删除缓存</strong>，原因在于，如果你选择第一种方案，在两个线程并发来访问时，假设线程1先来，他先把缓存删了，此时线程2过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上写入的就是旧的数据，新的数据被旧数据覆盖了。</p><ul><li><strong>先操作缓存还是先操作数据库？</strong> <ul><li>先删除缓存，再操作数据库</li><li>先操作数据库，再删除缓存✔</li></ul></li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/1653323595206.png#crop=0&crop=0&crop=1&crop=1&id=yOh5J&originHeight=804&originWidth=1466&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="1-4-缓存穿透"><a href="#1-4-缓存穿透" class="headerlink" title="1.4 缓存穿透"></a>1.4 缓存穿透</h2><p>缓存穿透 ：缓存穿透是指客户端请求的<strong>数据在缓存中和数据库中都不存在</strong>，这样缓存永远不会生效，这些请求都会打到数据库。</p><p>解决方案：</p><ul><li><strong>缓存空对象</strong> <ul><li>优点：实现简单，维护方便</li><li>缺点： <ul><li>额外的内存消耗</li><li>可能造成短期的不一致</li></ul></li></ul></li><li><strong>布隆过滤</strong> <ul><li>优点：内存占用较少，没有多余key</li><li>缺点： <ul><li>实现复杂</li><li>存在误判可能（布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突）</li></ul></li></ul></li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/1653326156516.png#crop=0&crop=0&crop=1&crop=1&id=piznd&originHeight=569&originWidth=1012&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>编码思路：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/1653327124561.png#crop=0&crop=0&crop=1&crop=1&id=FrhB4&originHeight=682&originWidth=1570&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p><strong>小总结：</strong></p><p><strong>缓存穿透产生的原因是什么？</strong></p><ul><li>用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大压力</li></ul><p><strong>缓存穿透的解决方案有哪些？</strong></p><ul><li>缓存null值</li><li>布隆过滤</li><li>增强id的复杂度，避免被猜测id规律</li><li>做好数据的基础格式校验</li><li>加强用户权限校验</li><li>做好热点参数的限流</li><li>进行实时监控：当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务</li><li>设置可访问的名单（白名单）：使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问。</li></ul><h2 id="1-5-缓存击穿"><a href="#1-5-缓存击穿" class="headerlink" title="1.5 缓存击穿"></a>1.5 缓存击穿</h2><p>缓存击穿问题也叫<strong>热点Key问题</strong>，就是<strong>一个</strong>被高并发访问并且缓存重建业务较复杂的<strong>key突然失效了</strong>，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p><p>常见的解决方案有两种：</p><ul><li><strong>预先设置热门数据：</strong>把一些热门数据提前存入到redis里面，加大这些热门数据key的时长 </li><li><strong>互斥锁</strong> </li><li><strong>逻辑过期</strong></li></ul><p>逻辑分析：当多个线程过来查询缓存，发现都没有命中，于是乎都去查数据库，然后数据库就压力山大，直接爆炸。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/1653328022622.png#crop=0&crop=0&crop=1&crop=1&id=vfUs1&originHeight=600&originWidth=1008&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="1-5-1-互斥锁解决缓存击穿"><a href="#1-5-1-互斥锁解决缓存击穿" class="headerlink" title="1.5.1 互斥锁解决缓存击穿"></a>1.5.1 互斥锁解决缓存击穿</h3><p>可以利用锁来防止多个线程同时去查询数据库，写缓存，<strong>只有拿到互斥锁的线程才能去查询数据库写缓存操作</strong>，其他线程拿不到互斥锁就休眠重试，等缓存中写入了之后，自然就能拿到数据。</p><p>加锁会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用tryLock方法 + double check来解决这样的问题。</p><p>这里的互斥锁<strong>通过setnx的特性可以实现</strong>，setnx只有在不存在数据时才能添加，有数据时添加失败。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/1653328288627.png#crop=0&crop=0&crop=1&crop=1&id=WCiKj&originHeight=723&originWidth=569&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="1-5-2-逻辑过期解决缓存击穿"><a href="#1-5-2-逻辑过期解决缓存击穿" class="headerlink" title="1.5.2 逻辑过期解决缓存击穿"></a>1.5.2 逻辑过期解决缓存击穿</h3><p>之所以会发生缓存击穿，是因为我们设置的key有过期时间，那么我们可以不给key设置过期时间啊，那这就有人会问，这不是会一直占用内存吗？，所以我们可以采用逻辑过期时间，<strong>把过期时间写入value中</strong>，用代码逻辑来判断该key是否过期。</p><p>这种方案巧妙在于，<strong>异步的构建缓存</strong>，缺点在于在构建完缓存之前，返回的都是脏数据。</p><h3 id="1-5-3-两种方案的对比"><a href="#1-5-3-两种方案的对比" class="headerlink" title="1.5.3 两种方案的对比"></a>1.5.3 两种方案的对比</h3><p><strong>互斥锁方案：</strong>由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁就有死锁问题的发生，且只能串行执行性能肯定受到影响</p><p><strong>逻辑过期方案：</strong> 线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据，但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来麻烦</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/1653357522914.png#crop=0&crop=0&crop=1&crop=1&id=rY3Mr&originHeight=425&originWidth=1044&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="1-5-4-业务代码实现"><a href="#1-5-4-业务代码实现" class="headerlink" title="1.5.4 业务代码实现"></a>1.5.4 业务代码实现</h3><p><strong>互斥锁方案：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/1653357860001.png#crop=0&crop=0&crop=1&crop=1&id=v24cc&originHeight=735&originWidth=1068&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p><strong>逻辑过期方案：</strong></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/1653360308731.png#crop=0&crop=0&crop=1&crop=1&id=mYsYE&originHeight=617&originWidth=1179&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="1-6-缓存雪崩"><a href="#1-6-缓存雪崩" class="headerlink" title="1.6 缓存雪崩"></a>1.6 缓存雪崩</h2><p>缓存雪崩是指在同一时段<strong>大量的缓存key同时失效</strong>或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p><p>解决方案：</p><ul><li>给不同的Key的TTL添加随机值</li><li>利用Redis集群提高服务的可用性</li><li>给缓存业务添加降级限流策略</li><li>给业务添加多级缓存：nginx缓存 + redis缓存 +其他缓存（ehcache等）</li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/1653327884526.png#crop=0&crop=0&crop=1&crop=1&id=QxIJM&originHeight=560&originWidth=1030&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h1 id="2-分布式锁"><a href="#2-分布式锁" class="headerlink" title="2.分布式锁"></a>2.分布式锁</h1><h2 id="2-1-基本原理和实现方式对比"><a href="#2-1-基本原理和实现方式对比" class="headerlink" title="2.1 基本原理和实现方式对比"></a>2.1 基本原理和实现方式对比</h2><p>分布式锁：满足分布式系统或集群模式下<strong>多进程可见</strong>并且互斥的锁。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/1653374296906.png#crop=0&crop=0&crop=1&crop=1&id=t9UWo&originHeight=808&originWidth=1616&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>分布式锁必须满足的条件：</p><ul><li>可见性：<strong>多个线程都能看到相同的结果，</strong>注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思</li><li><strong>互斥：互斥是分布式锁的最基本的条件，使得程序串行执行</strong></li><li>高可用：程序不易崩溃，时时刻刻都保证较高的可用性</li><li>高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能</li><li>安全性：安全也是程序中必不可少的一环</li></ul><p>常见的三种分布式锁以及对比：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/1653382219377.png#crop=0&crop=0&crop=1&crop=1&id=bSkqZ&originHeight=538&originWidth=1497&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="2-2-Redis实现分布式锁"><a href="#2-2-Redis实现分布式锁" class="headerlink" title="2.2 Redis实现分布式锁"></a>2.2 Redis实现分布式锁</h2><p>实现分布式锁时需要实现的两个基本方法：</p><ul><li>获取锁： <ul><li>互斥：确保只能有一个线程获取锁</li><li>非阻塞：尝试一次，成功返回true，失败返回false</li></ul></li><li>释放锁： <ul><li>手动释放（del key）</li><li><strong>超时释放：获取锁时添加一个超时时间</strong></li></ul></li></ul><h3 id="2-2-1-核心思路"><a href="#2-2-1-核心思路" class="headerlink" title="2.2.1 核心思路"></a>2.2.1 核心思路</h3><p>利用setnx的特性：只有当key不存在时才可以设置成功，来实现分布式锁的互斥性，释放锁即把这个key删除即可。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/1653382830810.png#crop=0&crop=0&crop=1&crop=1&id=ADgwh&originHeight=664&originWidth=629&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="2-2-2-实现分布式锁版本一"><a href="#2-2-2-实现分布式锁版本一" class="headerlink" title="2.2.2 实现分布式锁版本一"></a>2.2.2 实现分布式锁版本一</h3><p>Ilock接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ILock</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeoutSec 锁持有的超时时间，过期后自动释放</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true代表获取锁成功; false代表获取锁失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类<strong>SimpleRedisLock</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_PREFIX=<span class="string">&quot;lock:&quot;</span></span><br><span class="line"><span class="comment">//获取锁逻辑</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取线程标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId()</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">            .setIfAbsent(KEY_PREFIX + name, threadId + <span class="string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放锁逻辑</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;    </span><br><span class="line">     <span class="comment">//通过del删除锁    </span></span><br><span class="line">     stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-3-实现分布式锁版本二"><a href="#2-2-3-实现分布式锁版本二" class="headerlink" title="2.2.3 实现分布式锁版本二"></a>2.2.3 实现分布式锁版本二</h3><p>版本一面临的问题：因为<strong>线程可能阻塞导致锁超时自动释放</strong>，在释放锁时有可能<strong>释放的是别人的锁</strong></p><p>解决方案：在释放锁的时候先判断该锁是不是自己的锁，是自己的锁才释放，不是自己的锁不释放。</p><p>核心逻辑：在存入锁时，<strong>放入自己线程的标识（UUID）</strong>，在删除锁时，<strong>判断当前这把锁的标识是不是自己存入的</strong>，如果是，则进行删除，如果不是，则不进行删除。</p><p>具体代码修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在value上拼接UUID作为唯一标识</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ID_PREFIX</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>) + <span class="string">&quot;-&quot;</span>;</span><br><span class="line"><span class="comment">//加锁逻辑</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">   <span class="comment">// 获取线程标示</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">   <span class="comment">// 获取锁</span></span><br><span class="line">   <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">   <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放锁逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取线程标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">// 获取锁中的标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class="line">    <span class="comment">// 判断标示是否一致</span></span><br><span class="line">    <span class="keyword">if</span>(threadId.equals(id)) &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>有关代码实操说明：</strong></p><p>在我们修改完此处代码后，我们重启工程，然后启动两个线程，第一个线程持有锁后，手动释放锁，第二个线程 此时进入到锁内部，再放行第一个线程，此时第一个线程由于锁的value值并非是自己，所以不能释放锁，也就无法删除别人的锁，此时第二个线程能够正确释放锁，通过这个案例初步说明我们解决了锁误删的问题。</p><h3 id="2-2-4-实现分布式锁版本三"><a href="#2-2-4-实现分布式锁版本三" class="headerlink" title="2.2.4 实现分布式锁版本三"></a>2.2.4 实现分布式锁版本三</h3><p>考虑更加极端的情况：在删除锁的时候，已经判断成功唯一标识一致准备释放锁，在这之间进行了阻塞（JVM Full GC），那么仍然会导致误删的情况。</p><p>解决方案：让<strong>判断标志和释放锁两个动作具有原子性</strong>，保证一起进行中间不能停。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/1653387764938.png#crop=0&crop=0&crop=1&crop=1&id=mDrv1&originHeight=697&originWidth=1611&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>利用lua脚本来解决多条命令的原子性问题：这里不做讨论，我不会</p><p><strong>unlock.lua</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 比较线程标示与锁中的标示是否一致</span></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]) ==  ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 释放锁 del key</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">        UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 调用lua脚本</span></span><br><span class="line">    stringRedisTemplate.execute(</span><br><span class="line">            UNLOCK_SCRIPT,</span><br><span class="line">            Collections.singletonList(KEY_PREFIX + name),</span><br><span class="line">            ID_PREFIX + Thread.currentThread().getId());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//经过以上代码改造后，我们就能够实现 拿锁比锁删锁的原子性动作了~</span></span><br></pre></td></tr></table></figure><h3 id="2-2-5-小总结"><a href="#2-2-5-小总结" class="headerlink" title="2.2.5 小总结"></a>2.2.5 小总结</h3><p>基于Redis的分布式锁实现思路：</p><ul><li>利用set nx ex获取锁，并设置过期时间，保存线程标示</li><li>释放锁时先判断线程标示是否与自己一致，一致则删除锁 <ul><li>特性： <ul><li>利用set nx满足互斥性</li><li>利用set ex保证故障时锁依然能释放，避免死锁，提高安全性</li><li>利用Redis集群保证高可用和高并发特性</li></ul></li></ul></li></ul><p>我们一路走来，利用<strong>添加过期时间，防止死锁问题的发生</strong>，但是有了过期时间之后，可能<strong>出现误删别人锁的问题</strong>，这个问题我们开始是利用删之前 通过拿锁，比锁，删锁这个逻辑来解决的，也就是<strong>删之前判断一下当前这把锁是否是属于自己的</strong>，但是现在还有<strong>原子性问题</strong>，也就是我们没法保证拿锁比锁删锁是一个原子性的动作，最后<strong>通过lua表达式来解决这个问题</strong></p><p>但是目前还剩下一个问题，锁不住，什么是锁不住呢，你想一想，如果当过期时间到了之后，我们可以给他续期一下，比如续个30s，就好像是网吧上网， 网费到了之后，然后说，来，网管，再给我来10块的，是不是后边的问题都不会发生了，那么<strong>续期问题</strong>怎么解决呢，可以依赖于我们接下来要学习redission啦</p><h2 id="2-3-Redission"><a href="#2-3-Redission" class="headerlink" title="2.3 Redission"></a>2.3 Redission</h2><p><a href="#">Redission的github</a><br><a href="https://redisson.org/">Redisson官网</a></p><h3 id="2-3-1-setnx实现的分布式锁的问题"><a href="#2-3-1-setnx实现的分布式锁的问题" class="headerlink" title="2.3.1 setnx实现的分布式锁的问题"></a>2.3.1 setnx实现的分布式锁的问题</h3><ul><li><strong>重入问题</strong>：重入问题是指 <strong>获得锁的线程可以再次进入到相同的锁的代码块中</strong>，可重入锁的意义在于<strong>防止死锁</strong>，比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。</li><li><strong>不可重试</strong>：是指目前的分布式只能尝试一次，我们认为合理的情况是：<strong>当线程在获得锁失败后，他应该能再次尝试获得锁。</strong></li><li><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</li><li><strong>主从一致性：</strong> 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1659345998950-c7f8773e-78f2-43ba-bc56-25ecb5f43c8a.png#clientId=u44ccdc61-7dd1-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ub63ddc72&name=image.png&originHeight=621&originWidth=1541&originalType=url&ratio=1&rotation=0&showTitle=false&size=216476&status=done&style=none&taskId=u36ae097d-d6ff-4e4f-9066-2f5ec76cc8b&title=" alt="image.png"></p><h3 id="2-3-2-Redission是什么"><a href="#2-3-2-Redission是什么" class="headerlink" title="2.3.2 Redission是什么"></a>2.3.2 Redission是什么</h3><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1659345998831-8647441b-a1a7-4c50-8899-cb5709292636.png#clientId=u44ccdc61-7dd1-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u59e61eee&name=image.png&originHeight=402&originWidth=920&originalType=url&ratio=1&rotation=0&showTitle=false&size=50016&status=done&style=none&taskId=u5ad8fc26-4843-49a7-860c-c901451f0fc&title=" alt="image.png"></p><h3 id="2-3-3-Redission可重入锁原理"><a href="#2-3-3-Redission可重入锁原理" class="headerlink" title="2.3.3 Redission可重入锁原理"></a>2.3.3 Redission可重入锁原理</h3><p>就是将原本string类型的value转换成了hash类型，hash对应的field是线程名，value则是一个计数器，<strong>当前线程每获取一次锁，则value加一，删除锁value减一</strong>，若value等于零则del锁。利用lua脚本实现。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1659345999367-e24b3edb-aa66-437a-bff3-506a5d87c562.png#clientId=u44ccdc61-7dd1-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ueb5da414&name=image.png&originHeight=720&originWidth=1655&originalType=url&ratio=1&rotation=0&showTitle=false&size=489648&status=done&style=none&taskId=ucd83c961-f943-4df8-a75f-b5f6abe5427&title=" alt="image.png"></p><h3 id="2-3-4-Redission锁重试和WatchDog机制"><a href="#2-3-4-Redission锁重试和WatchDog机制" class="headerlink" title="2.3.4 Redission锁重试和WatchDog机制"></a>2.3.4 Redission锁重试和WatchDog机制</h3><p><a href="https://www.bilibili.com/video/BV1cr4y1671t?p=67&vd_source=665476c062292b64fa2949e9c935b109">实战篇-20.分布式锁-Redisson的锁重试和WatchDog机制哔哩哔哩bilibili</a></p><h3 id="2-3-5-Redission锁的MutiLock原理"><a href="#2-3-5-Redission锁的MutiLock原理" class="headerlink" title="2.3.5 Redission锁的MutiLock原理"></a>2.3.5 Redission锁的MutiLock原理</h3><p><a href="https://www.bilibili.com/video/BV1cr4y1671t?p=68&vd_source=665476c062292b64fa2949e9c935b109">实战篇-21.分布式锁-Redisson的multiLock原理哔哩哔哩bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
            <tag> 分布式锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务技术栈</title>
      <link href="/coderbin/44a1cd79.html"/>
      <url>/coderbin/44a1cd79.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="写代码步骤"><a href="#写代码步骤" class="headerlink" title="写代码步骤"></a>写代码步骤</h1><ol><li>建Module</li><li>改pom</li><li>写yml</li><li>主启动</li></ol><h1 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h1><h1 id="一-初识微服务"><a href="#一-初识微服务" class="headerlink" title="一.初识微服务"></a>一.初识微服务</h1><h2 id="1-三种架构"><a href="#1-三种架构" class="headerlink" title="1. 三种架构"></a>1. 三种架构</h2><h3 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h3><p>将业务的所有功能集中在一个项目中开发，打成一个包部署。<br><img src="https://cdn.nlark.com/yuque/0/2022/webp/27782283/1659354698593-3de8b89a-5025-4f08-9133-170a1c97b29a.webp#clientId=u3da4fb7e-948d-4&crop=0&crop=0&crop=1&crop=1&from=drop&id=u007d9e99&margin=%5Bobject%20Object%5D&name=20210901083809.webp&originHeight=416&originWidth=1203&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10126&status=done&style=none&taskId=u1f2d23ad-2af3-4c09-bc4d-cc8ceb476de&title=" alt="20210901083809.webp"><br><strong>优点：</strong>架构简单，部署成本低<br><strong>缺点：</strong>耦合度高（维护困难、升级困难），牵一发而动全身</p><h3 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h3><p>根据业务功能对系统做拆分，<strong>每个业务功能模块作为独立项目开发</strong>，称为一个服务。<br><img src="https://cdn.nlark.com/yuque/0/2022/webp/27782283/1659354811993-16f937da-f976-4867-81c4-53b6758df5b2.webp#clientId=u3da4fb7e-948d-4&crop=0&crop=0&crop=1&crop=1&from=drop&id=u6fab9ed8&margin=%5Bobject%20Object%5D&name=20210901092921.webp&originHeight=701&originWidth=1370&originalType=binary&ratio=1&rotation=0&showTitle=false&size=21844&status=done&style=none&taskId=u087c664f-4f29-41f0-8917-81a63032b2f&title=" alt="20210901092921.webp"><br><strong>优点：</strong>降低服务耦合，有利于服务升级和拓展<br><strong>缺点：</strong>服务调用关系错综复杂<br>分布式架构虽然降低了服务之间的耦合，但是服务拆分的时候也需要考虑很多问题：</p><ul><li>服务拆分的粒度如何界定？</li><li>服务之间如何调用？</li><li>服务的调用关系如何管理？</li></ul><p><strong>人们需要制定一套行之有效的标准来约束分布式架构</strong></p><h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><p>微服务架构特征：</p><ul><li>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责</li><li>自治：团队独立、技术独立、数据独立、独立部署和交付</li><li>面向服务：服务提供统一标准的接口，与语言和技术无关</li><li>隔离性强：服务调用做好隔离、容错、降级、避免出现级联问题</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/webp/27782283/1659355221827-6ea8cdcf-e7b3-4d36-a3ed-869906a7fa33.webp#clientId=u3da4fb7e-948d-4&crop=0&crop=0&crop=1&crop=1&from=drop&id=ub0f791c7&margin=%5Bobject%20Object%5D&name=202205162352847.webp&originHeight=355&originWidth=1000&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13666&status=done&style=none&taskId=ue1a88351-ed9f-4f8f-882d-2a3abbced13&title=" alt="202205162352847.webp"><br>微服务的上述特性其实是在<strong>给分布式架构制定一个标准</strong>，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。<br><strong>因此，可以认为微服务是一种经过良好架构设计的分布式架构方案 。</strong><br><strong>需要学习的微服务知识内容：</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/webp/27782283/1659355424091-66354c7a-b939-482a-bce5-073db3b3fa19.webp#clientId=u3da4fb7e-948d-4&crop=0&crop=0&crop=1&crop=1&from=drop&id=uc08b059b&margin=%5Bobject%20Object%5D&name=20210901092925.webp&originHeight=916&originWidth=1462&originalType=binary&ratio=1&rotation=0&showTitle=false&size=48318&status=done&style=none&taskId=u9b40b8db-322d-405b-b4c1-8c0e4f9dbc3&title=" alt="20210901092925.webp"></p><h2 id="2-SpringCloud"><a href="#2-SpringCloud" class="headerlink" title="2. SpringCloud"></a>2. SpringCloud</h2><p>技术栈：<img src="https://cdn.nlark.com/yuque/0/2022/webp/27782283/1659365650552-179b8154-16f5-4b26-a29f-85b921d05961.webp#clientId=u3da4fb7e-948d-4&crop=0&crop=0&crop=1&crop=1&from=drop&id=uf5c6f793&margin=%5Bobject%20Object%5D&name=20210901083717.webp&originHeight=573&originWidth=1332&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32556&status=done&style=none&taskId=u95be564c-46a8-414d-81a0-65cba7b24ca&title=" alt="20210901083717.webp"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1659355960118-bcd4f768-3336-4e84-a5b6-d36d1884881e.png#clientId=u3da4fb7e-948d-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=320&id=u8241f3a6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=480&originWidth=1475&originalType=binary&ratio=1&rotation=0&showTitle=false&size=266438&status=done&style=none&taskId=u22da9aa5-8de9-4d48-a126-55d633e1dfe&title=&width=983.3333333333334" alt="image.png"><br>技术栈对比：<br><img src="https://cdn.nlark.com/yuque/0/2022/webp/27782283/1659356045794-d1dbe0cc-60eb-42e0-a234-ecd90bb22fa9.webp#clientId=u3da4fb7e-948d-4&crop=0&crop=0&crop=1&crop=1&from=drop&id=u6683d7d0&margin=%5Bobject%20Object%5D&name=20210901090726.webp&originHeight=625&originWidth=1751&originalType=binary&ratio=1&rotation=0&showTitle=false&size=38392&status=done&style=none&taskId=uee8da5bb-3451-4f29-9b5f-2114500cddf&title=" alt="20210901090726.webp"></p><h1 id="二-服务注册与发现"><a href="#二-服务注册与发现" class="headerlink" title="二.服务注册与发现"></a>二.服务注册与发现</h1><h2 id="1-Eureka"><a href="#1-Eureka" class="headerlink" title="1.Eureka"></a>1.Eureka</h2><h3 id="什么是服务治理？"><a href="#什么是服务治理？" class="headerlink" title="什么是服务治理？"></a>什么是服务治理？</h3><pre><code>  Spring Cloud 封装了 Netflix 公司开发的 Eureka 模块来 **实现服务治理**  在传统的rpc远程调用框架中，**管理每个服务与服务之间依赖关系比较复杂**，管理比较复杂，所以需要使用服务治理，管理服务于服务之间依赖关系，可以实现服务调用、负载均衡、容错等，实现服务发现与注册。</code></pre><h3 id="什么是服务注册与发现？"><a href="#什么是服务注册与发现？" class="headerlink" title="什么是服务注册与发现？"></a>什么是服务注册与发现？</h3><p>Eureka采用了CS的设计架构，Eureka Server 作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使用 <strong>Eureka的客户端连接到 Eureka Server并维持心跳连接</strong>。这样系统的维护人员就可以<strong>通过 Eureka Server 来监控系统中各个微服务是否正常运行</strong>。<br>在服务注册与发现中，有一个注册中心。当服务器启动的时候，会把当前自己服务器的信息 比如 服务地址通讯地址等<strong>以别名方式注册到注册中心上</strong>。另一方（消费者|服务提供者），以<strong>该别名的方式去注册中心上获取到实际的服务通讯地址</strong>，然后再实现本地RPC调用RPC远程调用框架核心设计思想：在于注册中心，因为使用注册中心管理每个服务与服务之间的一个依赖关系(服务治理概念)。在任何rpc远程框架中，都会有一个注册中心(存放服务地址相关信息(接口地址))</p><p>说人话就是：假如你要添加一个美女的电话号码的步骤</p><ol><li>将美女的电话号码（服务地址通讯地址）放到通讯录（注册中心）里面，并且备注（别名）（服务注册）</li><li>要和美女聊天就直接在通讯录里面找美女的名字就完事了（调用服务直接找别名）（服务发现）</li><li>当美女某某电话号码更新的时候，需要通知到你，并修改通讯录服务中的号码。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/webp/27782283/1659357744210-01fd1918-b7cd-4174-bb10-d3fa3ea58aa7.webp#clientId=u3da4fb7e-948d-4&crop=0&crop=0&crop=1&crop=1&from=drop&id=u7d4da625&margin=%5Bobject%20Object%5D&name=20210901090919.webp&originHeight=838&originWidth=1454&originalType=binary&ratio=1&rotation=0&showTitle=false&size=43698&status=done&style=none&taskId=u7d5244bb-78f5-4a4d-bbf1-a80e1de144e&title=" alt="20210901090919.webp"></p><ul><li><p><strong>order-service 如何得知 user-service 实例地址？</strong></p><ul><li>user-service 服务实例启动后，将自己的信息注册到 eureka-server(Eureka服务端)，叫做<strong>服务注册</strong></li><li>eureka-server 保存服务名称到服务实例地址列表的映射关系</li><li>order-service 根据服务名称，拉取实例地址列表，这个叫<strong>服务发现或服务拉取</strong></li></ul></li><li><p><strong>order-service 如何从多个 user-service 实例中选择具体的实例？</strong></p><ul><li>order-service从实例列表中利用<strong>负载均衡算法</strong>选中一个实例地址，向该实例地址发起远程调用</li></ul></li><li><p><strong>order-service 如何得知某个 user-service 实例是否依然健康，是不是已经宕机？</strong></p><ul><li>user-service 会<strong>每隔一段时间(默认30秒)向 eureka-server 发起请求</strong>，报告自己状态，称为<strong>心跳</strong></li><li>当超过一定时间没有发送心跳时，eureka-server 会认为微服务实例故障，将该实例从服务列表中剔除</li><li>order-service 拉取服务时，就能将故障实例排除了</li></ul></li></ul><h3 id="代码实践"><a href="#代码实践" class="headerlink" title="代码实践"></a>代码实践</h3><h4 id="1-搭建注册中心"><a href="#1-搭建注册中心" class="headerlink" title="1.搭建注册中心"></a>1.搭建注册中心</h4><ol><li>改pom</li></ol><ul><li>引入 SpringCloud 为 eureka 提供的 starter 依赖，<strong>注意这里是用 server</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>写yml</li></ol><p>其中 <strong>default-zone</strong> 是因为前面配置类开启了注册中心所需要配置的 eureka 的地址信息，因为 eureka 本身也是一个微服务，这里也要将自己注册进来，当<strong>后面 eureka 集群时，这里就可以填写多个，使用 “,” 隔开</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">7001</span></span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: localhost #eureka服务端的实例名称</span><br><span class="line">  client:</span><br><span class="line">    #<span class="literal">false</span>表示不向注册中心注册自己。</span><br><span class="line">    register-with-eureka: <span class="literal">false</span></span><br><span class="line">    #<span class="literal">false</span>表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span><br><span class="line">    fetch-registry: <span class="literal">false</span></span><br><span class="line">    service-url:</span><br><span class="line">    #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址。</span><br><span class="line">      defaultZone: http:<span class="comment">//$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure><ol start="3"><li>主启动类</li></ol><ul><li>在主启动类上添加 <strong>@EnableEurekaServer</strong>注解，<strong>开启Eureka的注册中心功能</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaMain7001</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        SpringApplication.run(EurekaMain7001.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-服务注册"><a href="#2-服务注册" class="headerlink" title="2.服务注册"></a>2.服务注册</h4><ol><li>改pom</li></ol><ul><li>引入 SpringCloud 为 eureka 提供的 starter 依赖，<strong>注意这里是用client</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>写yml</li></ol><ul><li>在原配置的基础上添加以下配置<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    #表示是否将自己注册进EurekaServer默认为<span class="literal">true</span>。</span><br><span class="line">    register-with-eureka: <span class="literal">true</span></span><br><span class="line">    #是否从EurekaServer抓取已有的注册信息，默认为<span class="literal">true</span>。单节点无所谓，集群必须设置为<span class="literal">true</span>才能配合ribbon使用负载均衡</span><br><span class="line">    fetchRegistry: <span class="literal">true</span></span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:<span class="comment">//localhost:7001/eureka</span></span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>启动类</li></ol><ul><li>在主启动类上添加 **@EnableEurekaClient **注解<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentMain8001</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        SpringApplication.run(PaymentMain8001.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-服务拉取"><a href="#3-服务拉取" class="headerlink" title="3.服务拉取"></a>3.服务拉取</h4><p>pom、yml、启动类配置与服务注册一样<br>这里需要向spring容器中注入一个<strong>RestTemplate</strong>,这个 Bean 添加一个 <strong>@LoadBalanced <strong>注解，用于开启</strong>负载均衡，方便后续搭建集群使用。</strong></p><blockquote><p>RestTemplate:<br>spring框架提供的RestTemplate类可用于在应用中调用rest服务，它简化了与http服务的通信方式，统一了RESTful的标准，封装了http链接， 我们只需要传入url及返回值类型即可。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  public static final String PAYMENT_URL = &quot;http://localhost:8001&quot;;</span></span><br><span class="line">  <span class="comment">//这里用在注册中心注册的名字就可以找到对应的微服务</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PAYMENT_URL</span> <span class="operator">=</span> <span class="string">&quot;http://CLOUD-PAYMENT-SERVICE&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Resource</span> <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping(&quot;/consumer/payment/create&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title function_">create</span><span class="params">(Payment payment)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.postForObject(PAYMENT_URL + <span class="string">&quot;/payment/create&quot;</span>, payment, CommonResult.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping(&quot;/consumer/payment/get/&#123;id&#125;&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title function_">getPayment</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(PAYMENT_URL + <span class="string">&quot;/payment/get/&quot;</span> + id, CommonResult.class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Eureka集群搭建"><a href="#Eureka集群搭建" class="headerlink" title="Eureka集群搭建"></a>Eureka集群搭建</h3><ol><li><p>将eureka7001复制一份，成为7002，<strong>并且在配置文件中互相注册，搭建注册中心集群</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">7001</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: eureka7001.com #eureka服务端的实例名称</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: <span class="literal">false</span>     #<span class="literal">false</span>表示不向注册中心注册自己。</span><br><span class="line">    fetch-registry: <span class="literal">false</span>     #<span class="literal">false</span>表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:<span class="comment">//eureka7002.com:7002/eureka/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">7002</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: eureka7002.com #eureka服务端的实例名称</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: <span class="literal">false</span>     #<span class="literal">false</span>表示不向注册中心注册自己。</span><br><span class="line">    fetch-registry: <span class="literal">false</span>     #<span class="literal">false</span>表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:<span class="comment">//eureka7001.com:7001/eureka/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>将消费端和服务端都注册进两个注册中心中，<strong>并且参照8001写出一份8002，形成服务提供集群</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaultZone: http:<span class="comment">//eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka  # 集群版</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p></li></ol><p>发现调用服务是8001，8002交替出现，轮流被调用，可以说明<strong>RestTemplate</strong>默认的负载均衡策略为<strong>轮询</strong></p><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>对于注册进eureka里面的微服务，可以通过服务发现来获得该服务的信息<br><strong>@EnableDiscoveryClient</strong>  &#x2F;&#x2F;服务发现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span> <span class="comment">//服务发现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentMain8001</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        SpringApplication.run(PaymentMain8001.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Zookeeper-和-Consul"><a href="#2-Zookeeper-和-Consul" class="headerlink" title="2. Zookeeper 和 Consul"></a>2. Zookeeper 和 Consul</h2><p>相比Eureka，这两个注册中心只是引入了各自的依赖和配置文件，其余基本没变，这里当懒狗就不记了。</p><h2 id="3-CAP理论"><a href="#3-CAP理论" class="headerlink" title="3.CAP理论"></a>3.CAP理论</h2><p>CAP理论的核心是：<strong>一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，</strong><br><strong>最多只能同时较好的满足两个。</strong></p><ul><li>CP - 满足一致性，分区容忍必的系统，通常性能不是特别高。</li><li>AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。</li></ul><ol><li><strong>AP架构（Eureka）</strong></li></ol><p>当网络分区出现后，为了保证可用性，系统B可以返回旧值，保证系统的可用性。<br>结论：违背了一致性C的要求，只满足可用性和分区容错，即AP<br><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1659361878665-a1be68a8-b4a9-412c-bf4e-b7644c24ca3d.png#clientId=u3da4fb7e-948d-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=339&id=u06350283&margin=%5Bobject%20Object%5D&name=image.png&originHeight=509&originWidth=635&originalType=binary&ratio=1&rotation=0&showTitle=false&size=109020&status=done&style=none&taskId=u95ac2475-f7c8-4f6e-819e-306a00afb91&title=&width=423.3333333333333" alt="image.png"></p><ol start="2"><li><strong>CP架构(Zookeeper&#x2F;Consul)</strong></li></ol><p>当网络分区出现后，为了保证一致性，就必须拒接请求，否则无法保证一致性<br>结论：违背了可用性A的要求，只满足一致性和分区容错，即CP<br><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1659361925858-3e828485-7756-432a-bae3-4afc0142d021.png#clientId=u3da4fb7e-948d-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=337&id=u1f635627&margin=%5Bobject%20Object%5D&name=image.png&originHeight=505&originWidth=646&originalType=binary&ratio=1&rotation=0&showTitle=false&size=59219&status=done&style=none&taskId=ud535f60d-e88b-4dba-aeee-e4f643a0f45&title=&width=430.6666666666667" alt="image.png"></p><h1 id="三-服务调用"><a href="#三-服务调用" class="headerlink" title="三. 服务调用"></a>三. 服务调用</h1><h2 id="1-Ribbon负载均衡"><a href="#1-Ribbon负载均衡" class="headerlink" title="1.Ribbon负载均衡"></a>1.Ribbon负载均衡</h2><p><strong>Eureka依赖中自带了Ribbon的依赖</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1659362296133-94df3463-152b-451b-bf8a-d3b3f7d47c8b.png#clientId=u3da4fb7e-948d-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=294&id=u733b5360&margin=%5Bobject%20Object%5D&name=image.png&originHeight=441&originWidth=615&originalType=binary&ratio=1&rotation=0&showTitle=false&size=36548&status=done&style=none&taskId=uc0bcc59d-24d9-4373-b34c-09709541969&title=&width=410" alt="image.png"><br>前面RestTemplate的**@LoadBalanced<strong>的注解即赋予了其负载均衡功能，默认为</strong>轮询**。</p><h3 id="1-1-负载均衡策略"><a href="#1-1-负载均衡策略" class="headerlink" title="1.1 负载均衡策略"></a>1.1 负载均衡策略</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/webp/27782283/1659362532489-c55d48ca-c28b-4d57-99be-a8fa9858325e.webp#clientId=u3da4fb7e-948d-4&crop=0&crop=0&crop=1&crop=1&from=drop&id=uc17cd3d7&margin=%5Bobject%20Object%5D&name=20210901091811.webp&originHeight=512&originWidth=1386&originalType=binary&ratio=1&rotation=0&showTitle=false&size=25340&status=done&style=none&taskId=u40fbcf2c-9bf3-4402-a6aa-79b547d30ba&title=" alt="20210901091811.webp"></p><table><thead><tr><th><strong>内置负载均衡规则类</strong></th><th><strong>规则描述</strong></th></tr></thead><tbody><tr><td>RoundRobinRule</td><td>简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。</td></tr><tr><td>AvailabilityFilteringRule</td><td>对以下两种服务器进行忽略：（1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。 （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule 规则的客户端也会将其忽略。并发连接数的上限，可以由客户端设置。</td></tr><tr><td>WeightedResponseTimeRule</td><td>为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td></tr><tr><td><strong>ZoneAvoidanceRule</strong></td><td>以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。</td></tr><tr><td>BestAvailableRule</td><td>忽略那些短路的服务器，并选择并发数较低的服务器。</td></tr><tr><td>RandomRule</td><td>随机选择一个可用的服务器。</td></tr><tr><td>RetryRule</td><td>重试机制的选择逻辑</td></tr></tbody></table><h3 id="1-2-自定义策略"><a href="#1-2-自定义策略" class="headerlink" title="1.2 自定义策略"></a>1.2 自定义策略</h3><p>一般使用默认的负载均衡策略。<br>官方文档明确给出了警告：<br><strong>这个自定义配置类不能放在@ComponentScan所扫描的当前包下以及子包下，</strong><br>否则我们自定义的这个配置类就会被所有的Ribbon客户端所共享，达不到特殊化定制的目的了。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1659362841917-d4bd94a8-abe7-499e-9d3e-9702632739f9.png#clientId=u3da4fb7e-948d-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=243&id=u98f9d00b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=365&originWidth=340&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11523&status=done&style=none&taskId=u8cb85f44-83f8-4419-83f9-6e7d7190a44&title=&width=226.66666666666666" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySelfRule</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> IRule <span class="title function_">myRule</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();<span class="comment">//定义为随机</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="comment">//在启动该微服务的时候就能去加载我们的自定义Ribbon配置类，从而使配置生效，形如：</span></span><br><span class="line"><span class="meta">@RibbonClient(name = &quot;CLOUD-PAYMENT-SERVICE&quot;,configuration=MySelfRule.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderMain80</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        SpringApplication.run(OrderMain80.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-LB负载均衡-Load-Balance-是什么？"><a href="#1-3-LB负载均衡-Load-Balance-是什么？" class="headerlink" title="1.3 LB负载均衡(Load Balance)是什么？"></a>1.3 LB负载均衡(Load Balance)是什么？</h3><p>简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA（高可用）。<br>常见的负载均衡有软件Nginx，LVS，硬件 F5等。</p><h3 id="1-4-Ribbon本地负载均衡客户端-VS-Nginx服务端负载均衡区别"><a href="#1-4-Ribbon本地负载均衡客户端-VS-Nginx服务端负载均衡区别" class="headerlink" title="1.4 Ribbon本地负载均衡客户端 VS Nginx服务端负载均衡区别"></a>1.4 Ribbon本地负载均衡客户端 VS Nginx服务端负载均衡区别</h3><p> <strong>Nginx是服务器负载均衡</strong>，客户端所有请求都会交给nginx，然后由nginx实现转发请求。即负载均衡是由服务端实现的。<br>** Ribbon本地负载均衡**，在调用微服务接口时候，会在注册中心上获取注册信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用技术。</p><h2 id="2-OpenFeign服务接口调用"><a href="#2-OpenFeign服务接口调用" class="headerlink" title="2.OpenFeign服务接口调用"></a>2.OpenFeign服务接口调用</h2><p>使用OpenFeign代替RestTemplate来调用其他微服务的接口更加符合开发习惯（Controller调Service）</p><h3 id="2-1引入OpenFeign"><a href="#2-1引入OpenFeign" class="headerlink" title="2.1引入OpenFeign"></a>2.1引入OpenFeign</h3><ol><li><p>改pom</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--openfeign--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>yml不用改，启动类如下</p></li></ol><ul><li>使用**@EnableFeignClients**来开启<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderFeignMain80</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        SpringApplication.run(OrderFeignMain80.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>业务类</li></ol><ul><li>利用**@FeignClient**来使用，这样子调用这个方法就会去找对应服务的该方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;CLOUD-PAYMENT-SERVICE&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PaymentFeignService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/payment/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    CommonResult&lt;Payment&gt; <span class="title function_">getPaymentById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderFeignController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentFeignService paymentFeignService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/consumer/payment/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title function_">getPaymentById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> paymentFeignService.getPaymentById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1659363426591-c19403aa-07a3-468d-9066-1771fd23a4a8.png#clientId=u3da4fb7e-948d-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=413&id=u93a18685&margin=%5Bobject%20Object%5D&name=image.png&originHeight=619&originWidth=1366&originalType=binary&ratio=1&rotation=0&showTitle=false&size=136142&status=done&style=none&taskId=ub8970d38-4190-413a-a0ab-74e9a020052&title=&width=910.6666666666666" alt="image.png"></li></ul><h3 id="2-2-超时控制"><a href="#2-2-超时控制" class="headerlink" title="2.2 超时控制"></a>2.2 超时控制</h3><p>OpenFeign默认等待1秒钟，超过后报错，OpenFeign默认支持Ribbon<br>配置相关参数自定义超时时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#设置feign客户端超时时间(OpenFeign默认支持ribbon)</span><br><span class="line">ribbon:</span><br><span class="line">#指的是建立连接所用的时间，适用于网络状况正常的情况下,两端连接所用的时间</span><br><span class="line">  ReadTimeout: <span class="number">5000</span></span><br><span class="line">#指的是建立连接后从服务器读取到可用资源所用的时间</span><br><span class="line">  ConnectTimeout: <span class="number">5000</span></span><br></pre></td></tr></table></figure><h3 id="2-3-日志打印"><a href="#2-3-日志打印" class="headerlink" title="2.3 日志打印"></a>2.3 日志打印</h3><p>日志级别：</p><ul><li>NONE：默认的，不显示任何日志；</li><li>BASIC：仅记录请求方法、URL、响应状态码及执行时间；</li><li>HEADERS：除了 BASIC 中定义的信息之外，还有请求和响应的头信息；</li><li>FULL：除了 HEADERS 中定义的信息之外，还有请求和响应的正文及元数据。</li></ul><p>配置日志级别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignConfig</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Logger.Level <span class="title function_">feignLoggerLevel</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    # feign日志以什么级别监控哪个接口</span><br><span class="line">    com.atguigu.springcloud.service.PaymentFeignService: debug</span><br></pre></td></tr></table></figure><h1 id="四-服务降级"><a href="#四-服务降级" class="headerlink" title="四.服务降级"></a>四.服务降级</h1><h2 id="1-重要概念"><a href="#1-重要概念" class="headerlink" title="1.重要概念"></a>1.重要概念</h2><h3 id="1-1-服务降级"><a href="#1-1-服务降级" class="headerlink" title="1.1 服务降级"></a>1.1 服务降级</h3><p>当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。<br>我认为服务降级也是一种思想，能够保证在服务器压力剧增不能及时响应时，给予用户友好提示，以免带来不好的体验的思想。</p><h3 id="2-2-服务熔断"><a href="#2-2-服务熔断" class="headerlink" title="2.2 服务熔断"></a>2.2 服务熔断</h3><p>类比保险丝达到最大服务访问后，直接拒绝访问，拉闸限电，然后<strong>调用服务降级的方法</strong>并返回友好提示</p><h3 id="2-3-服务限流"><a href="#2-3-服务限流" class="headerlink" title="2.3 服务限流"></a>2.3 服务限流</h3><p>秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行</p><h1 id="五-服务网关"><a href="#五-服务网关" class="headerlink" title="五.服务网关"></a>五.服务网关</h1><h2 id="1-Gateway网关"><a href="#1-Gateway网关" class="headerlink" title="1. Gateway网关"></a>1. Gateway网关</h2><h3 id="1-1我们为什么选择gateway？"><a href="#1-1我们为什么选择gateway？" class="headerlink" title="1.1我们为什么选择gateway？"></a>1.1我们为什么选择gateway？</h3><h4 id="1-1-1-SpringCloud-Gateway特性"><a href="#1-1-1-SpringCloud-Gateway特性" class="headerlink" title="1.1.1 SpringCloud Gateway特性"></a>1.1.1 SpringCloud Gateway特性</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/webp/27782283/1659366136264-6ad7bdb8-ea7d-428f-a6eb-46982049b373.webp#clientId=u3da4fb7e-948d-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ud1c5fc87&margin=%5Bobject%20Object%5D&originHeight=441&originWidth=894&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u081bb2f6-e956-460c-a41a-a24b65a92e7&title="></p><h3 id="1-2-SpringCloud和Zuul的区别"><a href="#1-2-SpringCloud和Zuul的区别" class="headerlink" title="1.2  SpringCloud和Zuul的区别"></a>1.2  SpringCloud和Zuul的区别</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/webp/27782283/1659366136312-97d7b6ee-eeb8-4afe-8c98-40635504e759.webp#clientId=u3da4fb7e-948d-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u0a213558&margin=%5Bobject%20Object%5D&originHeight=428&originWidth=1114&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u264bfc31-85d3-4682-b05d-14277ebdbbe&title="><br><strong>Zuul 1.x 的模型</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/webp/27782283/1659366136629-7bed8742-7125-4a30-84fb-f5fb69a5baf1.webp#clientId=u3da4fb7e-948d-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uce2f8813&margin=%5Bobject%20Object%5D&originHeight=631&originWidth=1184&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uec938fc1-0662-4a18-908f-f4f8d879743&title="><br>** gateway模型**<br><img src="https://cdn.nlark.com/yuque/0/2022/webp/27782283/1659366136679-e51c6e34-3b12-46b1-a220-dbb9332a1118.webp#clientId=u3da4fb7e-948d-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u97a62aa4&margin=%5Bobject%20Object%5D&originHeight=252&originWidth=1105&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0ad78f49-2877-42a9-8230-a561f1ba4d1&title="></p><h3 id="1-3-Gateway的三大核心概念"><a href="#1-3-Gateway的三大核心概念" class="headerlink" title="1.3.Gateway的三大核心概念"></a>1.3.Gateway的三大核心概念</h3><ol><li><strong>Route路由</strong></li></ol><ul><li>路由是构建网关的基本模块，它由ID，目标URI，一些列的断言和过滤器组成，如果断言为true则匹配该路由。</li><li>路由转发：<ul><li>发送请求调用微服务时，负载均衡分派到微服务之前，会经过网关。</li><li>具体分派到哪个微服务，要符合网关的路由转发规则，才能转发到指定微服务</li></ul></li></ul><ol start="2"><li><strong>Predicate断言</strong></li></ol><ul><li>参考的是Java8的java.util.function.Predicate，开发人员可以匹配HTTP请求中的所有内容（例如请求头或请求参数），如果请求与断言相匹配则进行路由。</li></ul><ol start="3"><li>**Filter过滤 **</li></ol><ul><li>指的是Spring框架中GatewayFliter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改。     处理请求前和处理请求后都可能有Filter</li></ul><p>总体流程：</p><ol><li>客户端向 Spring Cloud Gateway 发出请求。然后在 Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到 Gateway Web Handler。</li><li>Handler 再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。</li><li>过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前（“pre”）或之后（“post”）执行业务逻辑。</li><li>Filter在“pre”类型的过滤器可以做参数校验、权限校验、流量监控、日志输出、协议转换等，在“post”类型的过滤器中可以做响应内容、响应头的修改，日志的输出，流量监控等有着非常重要的作用。</li></ol><p>核心逻辑：路由转发+执行过滤器链<br><img src="https://cdn.nlark.com/yuque/0/2022/webp/27782283/1659366136813-b0d158c4-2396-4814-92a2-451ad42a891b.webp#clientId=u3da4fb7e-948d-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u8e11a1cf&margin=%5Bobject%20Object%5D&originHeight=493&originWidth=560&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf453dbe6-5b03-414d-926c-68222b48356&title="></p><h3 id="1-4-Gateway的入门配置"><a href="#1-4-Gateway的入门配置" class="headerlink" title="1.4 Gateway的入门配置"></a>1.4 Gateway的入门配置</h3><ol><li><p>新建Module，后改pom</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;!--gateway--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--eureka-client--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--一般基础配置类--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></li><li><p>写yml</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">9527</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-gateway</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: cloud-gateway-service</span><br><span class="line">  client: #服务提供者provider注册进eureka服务列表内</span><br><span class="line">    service-url:</span><br><span class="line">      register-with-eureka: <span class="literal">true</span></span><br><span class="line">      fetch-registry: <span class="literal">true</span></span><br><span class="line">      defaultZone: http:<span class="comment">//eureka7001.com:7001/eureka</span></span><br></pre></td></tr></table></figure></li><li><p>主启动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GateWayMain9527</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        SpringApplication.run(GateWayMain9527.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="1-4-1-使用"><a href="#1-4-1-使用" class="headerlink" title="1.4.1 使用"></a>1.4.1 使用</h4><p>我们不想暴露8001端口，所以在8001上套一层9527</p><ol><li><p>在配置文件中增加网关配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">server:</span><br><span class="line">  port: 9527</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-gateway</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        - id: payment_routh #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span><br><span class="line">          uri: http://localhost:8001          #匹配后提供服务的路由地址</span><br><span class="line">          predicates:</span><br><span class="line">            - Path=/payment/get/**         # 断言，路径相匹配的进行路由</span><br><span class="line"></span><br><span class="line">        - id: payment_routh2 #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span><br><span class="line">          uri: http://localhost:8001          #匹配后提供服务的路由地址</span><br><span class="line">          predicates:</span><br><span class="line">            - Path=/payment/lb/**         # 断言，路径相匹配的进行路由</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: cloud-gateway-service</span><br><span class="line">  client: #服务提供者provider注册进eureka服务列表内</span><br><span class="line">    service-url:</span><br><span class="line">      register-with-eureka: true</span><br><span class="line">      fetch-registry: true</span><br><span class="line">      defaultZone: http://eureka7001.com:7001/eureka</span><br><span class="line"> </span><br></pre></td></tr></table></figure></li><li><p>在配置类中配置</p></li></ol><ul><li>这里演示的是转发到百度新闻<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GateWayConfig</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 配置了一个id为route-name的路由规则，</span></span><br><span class="line"><span class="comment">    * 当访问地址 http://localhost:9527/guonei时会自动转发到地址：http://news.baidu.com/guonei</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> builder</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RouteLocator <span class="title function_">customRouteLocator</span><span class="params">(RouteLocatorBuilder builder)</span></span><br><span class="line">    &#123;</span><br><span class="line">        RouteLocatorBuilder.<span class="type">Builder</span> <span class="variable">routes</span> <span class="operator">=</span> builder.routes();</span><br><span class="line">        </span><br><span class="line">        routes.route(<span class="string">&quot;path_route_atguigu&quot;</span>, r -&gt; r.path(<span class="string">&quot;/guonei&quot;</span>).uri(<span class="string">&quot;http://news.baidu.com/guonei&quot;</span>)).build();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> routes.build();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RouteLocator <span class="title function_">customRouteLocator2</span><span class="params">(RouteLocatorBuilder builder)</span></span><br><span class="line">    &#123;</span><br><span class="line">        RouteLocatorBuilder.<span class="type">Builder</span> <span class="variable">routes</span> <span class="operator">=</span> builder.routes();</span><br><span class="line">        routes.route(<span class="string">&quot;path_route_atguigu2&quot;</span>, r -&gt; r.path(<span class="string">&quot;/guoji&quot;</span>).uri(<span class="string">&quot;http://news.baidu.com/guoji&quot;</span>)).build();</span><br><span class="line">        <span class="keyword">return</span> routes.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-5-通过微服务名实现动态路由"><a href="#1-5-通过微服务名实现动态路由" class="headerlink" title="1.5 通过微服务名实现动态路由"></a>1.5 通过微服务名实现动态路由</h3><p>默认情况下Gateway会根据注册中心注册的服务列表，<strong>以注册中心上微服务名为路径创建动态路由进行转发，从而实现动态路由的功能</strong></p><ol><li>配置文件修改</li></ol><ul><li><strong>需要注意的是uri的协议为lb，表示启用Gateway的负载均衡功能。</strong></li><li><strong>lb:&#x2F;&#x2F;serviceName是spring cloud gateway在微服务中自动为我们创建的负载均衡uri</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9527</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-gateway</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      discovery:</span><br><span class="line">        locator:</span><br><span class="line">          enabled: true #开启从注册中心动态创建路由的功能，利用微服务名进行路由</span><br><span class="line">      routes:</span><br><span class="line">        - id: payment_routh #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span><br><span class="line">          # uri: http://localhost:8001          #匹配后提供服务的路由地址</span><br><span class="line">          uri: lb://cloud-payment-service #匹配后提供服务的路由地址</span><br><span class="line">          predicates:</span><br><span class="line">            - Path=/payment/get/**         # 断言，路径相匹配的进行路由</span><br><span class="line"></span><br><span class="line">        - id: payment_routh2 #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span><br><span class="line">          # uri: http://localhost:8001          #匹配后提供服务的路由地址</span><br><span class="line">          uri: lb://cloud-payment-service #匹配后提供服务的路由地址</span><br><span class="line">          predicates:</span><br><span class="line">            - Path=/payment/lb/**         # 断言，路径相匹配的进行路由</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: cloud-gateway-service</span><br><span class="line">  client: #服务提供者provider注册进eureka服务列表内</span><br><span class="line">    service-url:</span><br><span class="line">      register-with-eureka: true</span><br><span class="line">      fetch-registry: true</span><br><span class="line">      defaultZone: http://eureka7001.com:7001/eureka</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-6-Predicate的使用"><a href="#1-6-Predicate的使用" class="headerlink" title="1.6 Predicate的使用"></a>1.6 Predicate的使用</h3><p>Predicate就是为了实现一组匹配规则，让请求过来找到对应的Route进行处理。</p><h3 id="1-7-Filter的使用"><a href="#1-7-Filter的使用" class="headerlink" title="1.7 Filter的使用"></a>1.7 Filter的使用</h3><p>路由过滤器可用于修改进入的HTTP请求和返回的HTTP响应，路由过滤器只能指定路由进行使用。<br>Spring Cloud Gateway 内置了多种路由过滤器，他们都由GatewayFilter的工厂类来产生.</p><h1 id="Spring-Cloud-Alibaba"><a href="#Spring-Cloud-Alibaba" class="headerlink" title="Spring Cloud Alibaba"></a>Spring Cloud Alibaba</h1><p>官网：<a href="https://github.com/alibaba/spring-cloud-alibaba/blob/2.2.x/README-zh.md">https://github.com/alibaba/spring-cloud-alibaba/blob/2.2.x/README-zh.md</a><br><strong>主要功能：</strong></p><ul><li><strong>服务限流降级</strong>：默认支持 WebServlet、WebFlux、OpenFeign、RestTemplate、Spring Cloud Gateway、Zuul、Dubbo 和 RocketMQ 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。</li><li><strong>服务注册与发现</strong>：适配 Spring Cloud 服务注册与发现标准，默认集成了 Ribbon 的支持。</li><li><strong>分布式配置管理</strong>：支持分布式系统中的外部化配置，配置更改时自动刷新。</li><li><strong>消息驱动能力</strong>：基于 Spring Cloud Stream 为微服务应用构建消息驱动能力。</li><li><strong>分布式事务</strong>：使用 @GlobalTransactional 注解， 高效并且对业务零侵入地解决分布式事务问题。</li><li><strong>阿里云对象存储</strong>：阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据。</li><li><strong>分布式任务调度</strong>：提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有 Worker（schedulerx-client）上执行。</li><li><strong>阿里云短信服务</strong>：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。</li></ul><h1 id="一-Nacos服务注册和配置中心"><a href="#一-Nacos服务注册和配置中心" class="headerlink" title="一.Nacos服务注册和配置中心"></a>一.Nacos服务注册和配置中心</h1><h2 id="1-Nacos是什么？能干嘛？"><a href="#1-Nacos是什么？能干嘛？" class="headerlink" title="1.Nacos是什么？能干嘛？"></a>1.Nacos是什么？能干嘛？</h2><p>一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。<br><strong>Nacos就是注册中心 + 配置中心的组合，Nacos &#x3D; Eureka+Config +Bus</strong><br><strong>可以替代Eureka做服务注册中心，替代Config做服务配置中心。</strong></p><h2 id="2-各个服务中心比较"><a href="#2-各个服务中心比较" class="headerlink" title="2.各个服务中心比较"></a>2.各个服务中心比较</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1659407473530-023cbb43-80d7-46fd-9cae-ad0391326cd0.png#clientId=ube3dba84-68f1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=271&id=u4f28e3d9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=406&originWidth=828&originalType=binary&ratio=1&rotation=0&showTitle=false&size=266304&status=done&style=none&taskId=u1af32f52-b375-4e69-8796-5ce3f4ef500&title=&width=552" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1659407495528-a2fbc08e-cf4c-48e1-b9dc-d309b0cf19a5.png#clientId=ube3dba84-68f1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=285&id=u2ced0541&margin=%5Bobject%20Object%5D&name=image.png&originHeight=427&originWidth=829&originalType=binary&ratio=1&rotation=0&showTitle=false&size=383570&status=done&style=none&taskId=u6c8d46d0-0ac2-4105-b351-e5a58ca676c&title=&width=552.6666666666666" alt="image.png"><br><strong>Nacos提供AP和CP两个模式。</strong></p><h2 id="3-使用Nacos作为注册中心"><a href="#3-使用Nacos作为注册中心" class="headerlink" title="3.使用Nacos作为注册中心"></a>3.使用Nacos作为注册中心</h2><h3 id="3-1-安装Nacos"><a href="#3-1-安装Nacos" class="headerlink" title="3.1 安装Nacos"></a>3.1 安装Nacos</h3><ul><li>官网下载：<a href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a></li><li>解压压缩包，直接运行bin目录下的startup.cmd</li><li>访问<a href="http://localhost:8848/nacos">http://localhost:8848/nacos</a>，默认账号密码都是nacos</li><li>成功出现界面<img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1659407703172-2bb0b522-ebcc-4d66-b19e-a1aaf1bf5014.png#clientId=ube3dba84-68f1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=417&id=u11c0004a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=625&originWidth=1366&originalType=binary&ratio=1&rotation=0&showTitle=false&size=35506&status=done&style=none&taskId=ue13f9db3-fabb-4263-81c1-0542d55ff22&title=&width=910.6666666666666" alt="image.png"></li></ul><h3 id="3-2-注册服务"><a href="#3-2-注册服务" class="headerlink" title="3.2 注册服务"></a>3.2 注册服务</h3><ol><li><p>新建cloudalibaba-provider-payment9001，并修改pom</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.1</span><span class="number">.0</span>.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">    &lt;scope&gt;<span class="keyword">import</span>&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--SpringCloud ailibaba nacos --&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>写yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-payment-provider</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#配置Nacos地址</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure></li><li><p>主启动</p></li></ol><p>注意**@EnableDiscoveryClient**注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentMain9001</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            SpringApplication.run(PaymentMain9001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>业务类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/payment/nacos/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPayment</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;nacos registry, serverPort: &quot;</span>+ serverPort+<span class="string">&quot;\t id&quot;</span>+id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这时查看nacos控制台，发现已经注册进去了<br><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1659408095319-9360149c-5926-48e4-a3ad-39b6d4e08922.png#clientId=ube3dba84-68f1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=282&id=uf9e498f3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=423&originWidth=1358&originalType=binary&ratio=1&rotation=0&showTitle=false&size=34451&status=done&style=none&taskId=u8817a6a3-9e28-47ae-a779-62942347215&title=&width=905.3333333333334" alt="image.png"><br>参照9001，写出一个9002，方便演示负载均衡</li></ol><h3 id="3-3-服务拉取"><a href="#3-3-服务拉取" class="headerlink" title="3.3 服务拉取"></a>3.3 服务拉取</h3><ol><li><p>新建cloudalibaba-consumer-nacos-order83，修改pom</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--SpringCloud ailibaba nacos --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>写yml</p></li></ol><p>这里需要配置 <strong>消费者将要去访问的微服务名称</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">83</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-order-consumer</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#消费者将要去访问的微服务名称(注册成功进nacos的微服务提供者)</span></span><br><span class="line"><span class="attr">service-url:</span></span><br><span class="line">  <span class="attr">nacos-user-service:</span> <span class="string">http://nacos-payment-provider</span> </span><br><span class="line"> </span><br></pre></td></tr></table></figure><ol start="3"><li><p>主启动</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">@EnableDiscoveryClient</span></span><br><span class="line"><span class="string">@SpringBootApplication</span></span><br><span class="line"><span class="string">public</span> <span class="string">class</span> <span class="string">OrderNacosMain83</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">public</span> <span class="string">static</span> <span class="string">void</span> <span class="string">main(String</span>[] <span class="string">args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">SpringApplication.run(OrderNacosMain83.class</span>,<span class="string">args);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>业务类</p></li></ol><p>RestTemplate的注入和前面一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderNacosController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;service-url.nacos-user-service&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverURL;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/nacos/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(serverURL+<span class="string">&quot;/payment/nacos/&quot;</span>+id,String.class);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时访问 <a href="http://localhost:83/consumer/payment/nacos/13">http://localhost:83/consumer/payment/nacos/13</a> ，出现9001，9002交替出现，<strong>轮询负载均衡成功，因为Nacos集成了ribbon。</strong></p><h2 id="4-使用Nacos作为配置中心"><a href="#4-使用Nacos作为配置中心" class="headerlink" title="4.使用Nacos作为配置中心"></a>4.使用Nacos作为配置中心</h2><h3 id="4-1基础配置"><a href="#4-1基础配置" class="headerlink" title="4.1基础配置"></a>4.1基础配置</h3><ol><li><p>新建cloudalibaba-config-nacos-client3377，并修改pom</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--nacos-config--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>写yml</p></li></ol><p>这里需要写两个yml，Nacos同springcloud-config一样，在项目初始化时，要保证<strong>先从配置中心进行配置拉取</strong>，<br>拉取配置之后，才能保证项目的正常启动。<br><strong>springboot中配置文件的加载是存在优先级顺序的，bootstrap优先级高于application。</strong>因此在bootstrap里面写该服务特有的配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># nacos配置</span><br><span class="line">server:</span><br><span class="line">  port: <span class="number">3377</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: nacos-config-client</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:<span class="number">8848</span> #Nacos服务注册中心地址</span><br><span class="line">      config:</span><br><span class="line">        server-addr: localhost:<span class="number">8848</span> #Nacos作为配置中心地址</span><br><span class="line">        file-extension: yaml #指定yaml格式的配置</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># $&#123;spring.application.name&#125;-$&#123;spring.profile.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev # 表示开发环境</span><br></pre></td></tr></table></figure><ol start="3"><li><p>主启动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NacosConfigClientMain3377</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            SpringApplication.run(NacosConfigClientMain3377.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>业务类</p></li></ol><p>在控制器类加入**@RefreshScope**注解使当前类下的配置支持Nacos的动态刷新功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span> <span class="comment">//在控制器类加入@RefreshScope注解使当前类下的配置支持Nacos的动态刷新功能。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigClientController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config.info&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/config/info&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getConfigInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>在Nacos中添加配置信息</strong></li></ol><p>Nacos中的dataid的组成格式及与SpringBoot配置文件中的匹配规则：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1659408934075-4d9f666e-b070-4f6b-bbff-5c8977317c81.png#clientId=ube3dba84-68f1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=223&id=u1bdffec1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=334&originWidth=999&originalType=binary&ratio=1&rotation=0&showTitle=false&size=57234&status=done&style=none&taskId=uf850a919-659b-4ea2-9998-07bdb82d526&title=&width=666" alt="image.png"><br> 最后公式：${spring.application.name}-${spring.profiles.active}.${spring.cloud.nacos.config.file-extension}</p><p>Nacos界面：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1659409036316-84a91888-2206-4d09-9936-a6f8ce20dbc0.png#clientId=ube3dba84-68f1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=385&id=uf20ca736&margin=%5Bobject%20Object%5D&name=image.png&originHeight=577&originWidth=761&originalType=binary&ratio=1&rotation=0&showTitle=false&size=34654&status=done&style=none&taskId=u656921a5-be64-47cc-a138-05fc4271b54&title=&width=507.3333333333333" alt="image.png"><br>总结：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1659408995671-48fdfe7d-790d-4288-b1ad-81feb3e87067.png#clientId=ube3dba84-68f1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=255&id=uac6f984e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=382&originWidth=889&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32168&status=done&style=none&taskId=u2fe6f9b5-73ec-49ad-bb25-9525a3e1ed4&title=&width=592.6666666666666" alt="image.png"></p><h3 id="4-2-分类配置"><a href="#4-2-分类配置" class="headerlink" title="4.2 分类配置"></a>4.2 分类配置</h3><p><strong>为什么需要分类配置？</strong><br>为了解决以下问题<br>问题1：<br>实际开发中，通常一个系统会准备，dev开发环境，test测试环境，prod生产环境。<br><strong>如何保证指定环境启动时服务能正确读取到Nacos上相应环境的配置文件呢？</strong><br>问题2：<br>一个大型分布式微服务系统会有很多微服务子项目，每个微服务项目又都会有相应的开发环境、测试环境、预发环境、正式环境……<br><strong>那怎么对这些微服务配置进行管理呢？</strong></p><h4 id="4-2-1-命名空间、分组，DataId三者之间的关系"><a href="#4-2-1-命名空间、分组，DataId三者之间的关系" class="headerlink" title="4.2.1 命名空间、分组，DataId三者之间的关系"></a>4.2.1 命名空间、分组，DataId三者之间的关系</h4><p> <img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1659409314846-85df7526-b017-472e-9cc4-decbcf97f8c4.png#clientId=ube3dba84-68f1-4&crop=0&crop=0&crop=1&crop=1&from=drop&id=u812a5d71&margin=%5Bobject%20Object%5D&name=202105311539240.png&originHeight=602&originWidth=1005&originalType=binary&ratio=1&rotation=0&showTitle=false&size=25648&status=done&style=none&taskId=uf0788c97-44cc-4055-9418-86c1742d50f&title=" alt="202105311539240.png"></p><h4 id="4-2-2-使用"><a href="#4-2-2-使用" class="headerlink" title="4.2.2 使用"></a>4.2.2 使用</h4><p>修改yml，来匹配不同的配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Nacos注册配置，application.yml</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="comment">#active: test</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">    <span class="comment">#active: info</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nacos注册中心</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3377</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-order</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos服务注册中心地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos作为配置中心地址</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment">#这里我们获取的yaml格式的配置</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">5da1dccc-ee26-49e0-b8e5-7d9559b95ab0</span></span><br><span class="line">        <span class="comment">#group: DEV_GROUP</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">TEST_GROUP</span></span><br></pre></td></tr></table></figure><h2 id="5-Nacos集群和持久化"><a href="#5-Nacos集群和持久化" class="headerlink" title="5.Nacos集群和持久化"></a>5.Nacos集群和持久化</h2><p>架构说明：我们需要1个Nginx+3个Nacos+1个Mysql<img src="https://cdn.nlark.com/yuque/0/2022/webp/27782283/1659410144503-a17c0469-7a7c-4106-a505-b8b728990479.webp#clientId=ube3dba84-68f1-4&crop=0&crop=0&crop=1&crop=1&from=drop&id=uf3015a00&margin=%5Bobject%20Object%5D&name=202108182000220.webp&originHeight=702&originWidth=754&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14894&status=done&style=none&taskId=u53176fc1-ba45-4ca0-ad0d-a8a556037fa&title=" alt="202108182000220.webp"></p><h3 id="5-1-持久化说明"><a href="#5-1-持久化说明" class="headerlink" title="5.1 持久化说明"></a>5.1 持久化说明</h3><p>其实就是把Nacos的配置保存到mysql数据库中来实现持久化</p><ol><li>nacos-server-1.1.4\nacos\conf目录下找到sql脚本，并且在数据库中建库运行</li><li>nacos-server-1.1.4\nacos\conf目录下找到application.properties，并且修改，配置mysql数据库<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.datasource.platform</span>=<span class="string">mysql</span></span><br><span class="line"></span><br><span class="line"><span class="attr">db.num</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">db.url.0</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true</span></span><br><span class="line"><span class="attr">db.user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">db.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="5-2-集群搭建"><a href="#5-2-集群搭建" class="headerlink" title="5.2 集群搭建"></a>5.2 集群搭建</h3><p>参考：<a href="http://www.javaheidong.com/blog/article/471603/c04739243ce86a8d449c/">http://www.javaheidong.com/blog/article/471603/c04739243ce86a8d449c/</a><br><a href="https://blog.csdn.net/AyinMars/article/details/125805296">https://blog.csdn.net/AyinMars/article/details/125805296</a></p><h1 id="二-Sentinel实现熔断与限流"><a href="#二-Sentinel实现熔断与限流" class="headerlink" title="二.Sentinel实现熔断与限流"></a>二.Sentinel实现熔断与限流</h1><p>官网：<a href="https://sentinelguard.io/zh-cn/index.html">https://sentinelguard.io/zh-cn/index.html</a><br>Sentinel 具有以下特征</p><ul><li><strong>丰富的应用场景</strong>：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</li><li><strong>完备的实时监控</strong>：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</li><li><strong>广泛的开源生态</strong>：Sentinel 提供开箱即用的与其它开源框架&#x2F;库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。</li><li><strong>完善的</strong> <strong>SPI</strong> <strong>扩展点</strong>：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</li></ul><h2 id="1-安装Sentinel"><a href="#1-安装Sentinel" class="headerlink" title="1.安装Sentinel"></a>1.安装Sentinel</h2><ol><li>下载jar包：<a href="https://github.com/alibaba/Sentinel/releases">https://github.com/alibaba/Sentinel/releases</a></li><li>命令行运行jar包：java -jar sentinel-dashboard-1.7.2.jar （前提：java8环境，8080端口不被占用）</li><li>访问 <a href="http://localhost:8080/">http://localhost:8080</a> ，登录账号密码均为sentinel<img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1659422084455-df370307-67e9-472a-ab50-6e27cfb92821.png#clientId=ube3dba84-68f1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=129&id=ub0011ebb&margin=%5Bobject%20Object%5D&name=image.png&originHeight=193&originWidth=918&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18863&status=done&style=none&taskId=u8c5703fa-368d-4fe7-bb6a-bf30a1e77ad&title=&width=612" alt="image.png"></li></ol><h2 id="2-使用Sentinel"><a href="#2-使用Sentinel" class="headerlink" title="2.使用Sentinel"></a>2.使用Sentinel</h2><ol><li><p>建cloudalibaba-sentinel-service8401，修改pom</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringCloud ailibaba nacos --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--SpringCloud ailibaba sentinel-datasource-nacos 后续做持久化用到--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--SpringCloud ailibaba sentinel --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>写yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8401</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloudalibaba-sentinel-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment">#Nacos服务注册中心地址</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="comment">#配置Sentinel dashboard地址</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8080</span></span><br><span class="line">        <span class="comment">#默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8719</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>主启动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApp8401</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MainApp8401.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>业务类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlowLimitController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/testA&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testA</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;------testA&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/testB&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testB</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;------testB&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>准备就绪，开始使用</p><ol><li>启动Nacos，8848</li><li>启动微服务，8401</li><li>启动Sentinel，8080</li><li><strong>因为Sentinel为懒加载，因此刚启动时在控制台并不能看到效果</strong>，需要访问 <a href="http://localhost:8401/testA">http://localhost:8401/testA</a> 和<a href="http://localhost:8401/testB">http://localhost:8401/testB</a> 之后才能看到效果。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1659422593655-6a518b56-cfd2-41f9-8005-facacb19c1b4.png#clientId=ube3dba84-68f1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=359&id=u086a7569&margin=%5Bobject%20Object%5D&name=image.png&originHeight=538&originWidth=1328&originalType=binary&ratio=1&rotation=0&showTitle=false&size=60653&status=done&style=none&taskId=ue364f3a2-0351-418b-abdd-2c9dc0d77b0&title=&width=885.3333333333334" alt="image.png"></p><h2 id="3-流控规则"><a href="#3-流控规则" class="headerlink" title="3.流控规则"></a>3.流控规则</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1659423986534-fa632354-2842-4f7d-bc3f-721cf0b59f73.png#clientId=ube3dba84-68f1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=411&id=ucd9c3596&margin=%5Bobject%20Object%5D&name=image.png&originHeight=616&originWidth=1353&originalType=binary&ratio=1&rotation=0&showTitle=false&size=68382&status=done&style=none&taskId=u7e4818cb-e82b-497e-8f34-be10a760fdd&title=&width=902" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1659423988363-67200d43-2f6b-4f62-aecf-4c6b3acf7b15.png#clientId=ube3dba84-68f1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=349&id=u510f1cab&margin=%5Bobject%20Object%5D&name=image.png&originHeight=523&originWidth=876&originalType=binary&ratio=1&rotation=0&showTitle=false&size=72556&status=done&style=none&taskId=ufbb70daa-1167-4d14-a7ea-3ee0d5e419a&title=&width=584" alt="image.png"></p><h2 id="4-降级规则"><a href="#4-降级规则" class="headerlink" title="4.降级规则"></a>4.降级规则</h2><p>Sentinel 提供以下几种熔断策略：</p><ul><li><strong>慢调用比例 (SLOW_REQUEST_RATIO)：</strong>选择以慢调用比例作为阈值，需要设置允许的慢调用 RT（即最大的响应时间），请求的响应时间大于该值则统计为慢调用。<strong>当单位统计时长（statIntervalMs）内请求数目大于设置的最小请求数目，并且慢调用的比例大于阈值</strong>，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求响应时间小于设置的慢调用 RT 则结束熔断，若大于设置的慢调用 RT 则会再次被熔断。</li><li><strong>异常比例 (ERROR_RATIO)：当单位统计时长（statIntervalMs）内请求数目大于设置的最小请求数目，并且异常的比例大于阈值，</strong>则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。异常比率的阈值范围是 [0.0, 1.0]，代表 0% - 100%。</li><li><strong>异常数 (ERROR_COUNT)：当单位统计时长内的异常数目超过阈值之后会自动进行熔断。</strong>经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1659422882023-4ae9bfd9-dd25-4c79-9f98-61cb4d3289a7.png#clientId=ube3dba84-68f1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=193&id=ua35860b3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=290&originWidth=612&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16254&status=done&style=none&taskId=ub146f870-03cd-4b8d-b3c2-12ced590921&title=&width=408" alt="image.png"><br><strong>RT（平均响应时间，秒级）</strong></p><ul><li><strong>平均响应时间   超出阈值  且   在时间窗口内通过的请求&gt;&#x3D;5，两个条件同时满足后触发降级</strong></li><li>窗口期过后关闭断路器</li><li>RT最大4900（更大的需要通过-Dcsp.sentinel.statistic.max.rt&#x3D;XXXX才能生效）</li></ul><p><strong>异常比例（秒级）</strong></p><ul><li><strong>QPS &gt;&#x3D; 5 且异常比例（秒级统计）超过阈值时</strong>，触发降级；时间窗口结束后，关闭降级</li></ul><p><strong>异常数（分钟级）</strong></p><ul><li><strong>异常数（分钟统计）超过阈值时，触发降级</strong>；时间窗口结束后，关闭降级</li></ul><h2 id="5-热点Key限流"><a href="#5-热点Key限流" class="headerlink" title="5.热点Key限流"></a>5.热点Key限流</h2><p><strong>何为热点？</strong><br>热点即经常访问的数据，很多时候我们希望统计或者限制某个热点数据中访问频次最高的TopN数据，并对其访问进行限流或者其它操作<br>热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。<strong>热点参数限流可以看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效。</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1659423151318-69ab4164-73d1-4949-94f5-4f6246d361ab.png#clientId=ube3dba84-68f1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=322&id=ud5ce58e2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=483&originWidth=1022&originalType=binary&ratio=1&rotation=0&showTitle=false&size=49255&status=done&style=none&taskId=u89abafaf-9e02-4429-9732-cbe72404c37&title=&width=681.3333333333334" alt="image.png"></p><h3 id="5-1-关于降级方法"><a href="#5-1-关于降级方法" class="headerlink" title="5.1 关于降级方法"></a>5.1 关于降级方法</h3><p>系统默认的降级：Blocked by Sentinel (flow limiting)<br>**<br>利用**@SentinelResource **注解中的blockHandler属性指定兜底方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/testHotKey&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;testHotKey&quot;,blockHandler = &quot;dealHandler_testHotKey&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testHotKey</span><span class="params">(<span class="meta">@RequestParam(value = &quot;p1&quot;,required = false)</span> String p1, </span></span><br><span class="line"><span class="params">                         <span class="meta">@RequestParam(value = &quot;p2&quot;,required = false)</span> String p2)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;------testHotKey&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">dealHandler_testHotKey</span><span class="params">(String p1,String p2,BlockException exception)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;-----dealHandler_testHotKey&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-配置热点key"><a href="#5-2-配置热点key" class="headerlink" title="5.2 配置热点key"></a>5.2 配置热点key</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1659423554929-266d5c58-1ff8-4c29-8e6f-1515ed313cb4.png#clientId=ube3dba84-68f1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=202&id=u9c900dd9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=303&originWidth=1193&originalType=binary&ratio=1&rotation=0&showTitle=false&size=110089&status=done&style=none&taskId=ua19e92d0-ec30-4f2a-a87a-03399588489&title=&width=795.3333333333334" alt="image.png"><br><strong>限流模式只支持QPS模式，固定写死了。（这才叫热点）</strong><br>@SentinelResource 注解的方法参数索引，<strong>0代表第一个参数，1代表第二个参数，</strong>以此类推<br>单机阀值以及统计窗口时长表示在此窗口时间超过阀值就限流。<br>上面的抓图就是第一个参数有值的话，1秒的QPS为1，超过就限流，限流后调用dealHandler_testHotKey支持方法。<br>测试：当QPS超过1秒1次点击后马上被限流<br><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1659423627365-05f20dfa-b09b-4035-82cc-d437ec03b0b8.png#clientId=ube3dba84-68f1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=76&id=u0510e1a7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=114&originWidth=530&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15547&status=done&style=none&taskId=ue641b00e-3985-4af3-aed9-90f2980cce7&title=&width=353.3333333333333" alt="image.png"></p><h3 id="5-3-配置热点key的特例情况"><a href="#5-3-配置热点key的特例情况" class="headerlink" title="5.3 配置热点key的特例情况"></a>5.3 配置热点key的特例情况</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1659423720817-5ad7383e-19c2-43bf-a17b-708a2e2c4723.png#clientId=ube3dba84-68f1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=412&id=u6a667813&margin=%5Bobject%20Object%5D&name=image.png&originHeight=618&originWidth=665&originalType=binary&ratio=1&rotation=0&showTitle=false&size=33236&status=done&style=none&taskId=ub8045f2c-fc86-4f2d-9320-54119c7afe8&title=&width=443.3333333333333" alt="image.png"></p><h2 id="6-系统规则"><a href="#6-系统规则" class="headerlink" title="6.系统规则"></a>6.系统规则</h2><p>类似全局配置：总控的功能<br><img src="https://cdn.nlark.com/yuque/0/2022/webp/27782283/1659424355199-b1252468-a31a-43bd-8a65-20efb3eeca0b.webp#clientId=ube3dba84-68f1-4&crop=0&crop=0&crop=1&crop=1&from=drop&id=ua172cb9f&margin=%5Bobject%20Object%5D&name=1735851e5c89791c_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp&originHeight=359&originWidth=298&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7238&status=done&style=none&taskId=u2d6ed248-bcaf-4137-ab3b-f5938a58383&title=" alt="1735851e5c89791c_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><img src="https://cdn.nlark.com/yuque/0/2022/webp/27782283/1659424371310-280daf20-1f68-4b89-b050-6dbe017e505d.webp#clientId=ube3dba84-68f1-4&crop=0&crop=0&crop=1&crop=1&from=drop&id=u0b8b28e2&margin=%5Bobject%20Object%5D&name=173585a77d6f9865_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp&originHeight=276&originWidth=676&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6688&status=done&style=none&taskId=u2d910151-66fd-4163-98b1-7f2e410de47&title=" alt="173585a77d6f9865_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><img src="https://cdn.nlark.com/yuque/0/2022/webp/27782283/1659424365121-ba706c9c-f4fb-495f-a163-4dee786b8b7b.webp#clientId=ube3dba84-68f1-4&crop=0&crop=0&crop=1&crop=1&from=drop&id=ub843f6b0&margin=%5Bobject%20Object%5D&name=1735859fabf1cfc7_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp&originHeight=349&originWidth=906&originalType=binary&ratio=1&rotation=0&showTitle=false&size=41788&status=done&style=none&taskId=u0c8d3ffb-e792-4879-ae84-ee6b1246c09&title=" alt="1735859fabf1cfc7_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h2 id="7-SentinelResource"><a href="#7-SentinelResource" class="headerlink" title="7.@SentinelResource"></a>7.@SentinelResource</h2><h3 id="7-1-参数说明"><a href="#7-1-参数说明" class="headerlink" title="7.1 参数说明"></a>7.1 参数说明</h3><h4 id="value"><a href="#value" class="headerlink" title="value"></a>value</h4><p>资源名称，必需项，因为需要通过resource name找到对应的规则，这个是必须配置的。</p><h4 id="blockHandler"><a href="#blockHandler" class="headerlink" title="blockHandler"></a>blockHandler</h4><p>blockHandler 对应处理 BlockException 的函数名称，可选项，<strong>blockHandler管配置违规</strong><br>blockHandler 函数访问范围需要是 public，返回类型需要与原方法相匹配，参数类型需要和原方法相匹配并且最后加一个额外的参数，类型为 BlockException。</p><h4 id="blockHandlerClass"><a href="#blockHandlerClass" class="headerlink" title="blockHandlerClass"></a>blockHandlerClass</h4><p>blockHandler 函数默认需要和原方法在同一个类中，如果希望使用其他类的函数，则需要指定 blockHandlerClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。</p><h4 id="fallback"><a href="#fallback" class="headerlink" title="fallback"></a>fallback</h4><p>fallback 函数名称，可选项，<strong>用于在抛出异常的时候提供 fallback 处理逻辑</strong>。fallback 函数可以针对所有类型的异常（除了 exceptionsToIgnore 里面排除掉的异常类型）进行处理。</p><h4 id="fallbackClass"><a href="#fallbackClass" class="headerlink" title="fallbackClass"></a>fallbackClass</h4><p>fallbackClass的应用和blockHandlerClass类似，fallback 函数默认需要和原方法在同一个类中。<br>若希望使用其他类的函数，则可以指定 fallbackClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。</p><h3 id="7-2-按资源名称限流"><a href="#7-2-按资源名称限流" class="headerlink" title="7.2 按资源名称限流"></a>7.2 按资源名称限流</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1659424802833-5711ac04-f72f-454c-941b-9cc718e89bab.png#clientId=ube3dba84-68f1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=275&id=u129c4472&margin=%5Bobject%20Object%5D&name=image.png&originHeight=413&originWidth=1083&originalType=binary&ratio=1&rotation=0&showTitle=false&size=63136&status=done&style=none&taskId=u02a477fd-3669-4129-be28-ab0b4de83ac&title=&width=722" alt="image.png"></p><h3 id="7-3-按照Url地址限流"><a href="#7-3-按照Url地址限流" class="headerlink" title="7.3 按照Url地址限流"></a>7.3 按照Url地址限流</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1659424906258-03c9e0f3-2160-4cb0-ab08-c916de125ba1.png#clientId=ube3dba84-68f1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=414&id=u317bd970&margin=%5Bobject%20Object%5D&name=image.png&originHeight=621&originWidth=1212&originalType=binary&ratio=1&rotation=0&showTitle=false&size=50046&status=done&style=none&taskId=ua31d8dd1-6db6-451e-bbce-2b3683f7c9e&title=&width=808" alt="image.png"></p><h3 id="7-4-配置自定义降级方法"><a href="#7-4-配置自定义降级方法" class="headerlink" title="7.4 配置自定义降级方法"></a>7.4 配置自定义降级方法</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1659425003207-a1c7878f-2b01-4c6b-b141-4e5285752dee.png#clientId=ube3dba84-68f1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=353&id=u0d932f7d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=529&originWidth=1181&originalType=binary&ratio=1&rotation=0&showTitle=false&size=77102&status=done&style=none&taskId=ufb4ff6b4-4346-4921-b571-fb26d95a1e4&title=&width=787.3333333333334" alt="image.png"></p><h3 id="7-5-Sentinel-OpenFeign"><a href="#7-5-Sentinel-OpenFeign" class="headerlink" title="7.5 Sentinel+OpenFeign"></a>7.5 Sentinel+OpenFeign</h3><ol><li><p>pom</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringCloud openfeign --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 激活Sentinel对Feign的支持</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">sentinel:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span>  </span><br></pre></td></tr></table></figure></li><li><p>主启动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderNacosMain84</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(OrderNacosMain84.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>业务类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;nacos-payment-provider&quot;,fallback = PaymentFallbackService.class)</span><span class="comment">//调用中关闭9003服务提供者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PaymentService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/paymentSQL/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title function_">paymentSQL</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentFallbackService</span> <span class="keyword">implements</span> <span class="title class_">PaymentService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title function_">paymentSQL</span><span class="params">(Long id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>&lt;&gt;(<span class="number">444</span>,<span class="string">&quot;服务降级返回,没有该流水信息&quot;</span>,<span class="keyword">new</span> <span class="title class_">Payment</span>(id, <span class="string">&quot;errorSerial......&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="7-6-熔断框架对比"><a href="#7-6-熔断框架对比" class="headerlink" title="7.6 熔断框架对比"></a>7.6 熔断框架对比</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1659425718206-fec6d81a-3442-435c-a7c7-fe00bd170652.png#clientId=ube3dba84-68f1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=439&id=udb22a0c6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=658&originWidth=647&originalType=binary&ratio=1&rotation=0&showTitle=false&size=134275&status=done&style=none&taskId=u81eaf683-e765-4ce0-a72c-d282c5b2d1f&title=&width=431.3333333333333" alt="image.png"></p><h2 id="8-规则持久化"><a href="#8-规则持久化" class="headerlink" title="8.规则持久化"></a>8.规则持久化</h2><p>发现一旦重启微服务，sentinel的规则就会消失，没有持久化<br>解决方法：使用nacos来保存配置。</p><ol><li><p>修改8401pom</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringCloud alibaba sentinel-datasource-nacos：后续做持久化用到--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>改yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8401</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloudalibaba-sentinel-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment"># Nacos服务注册中心地址</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="comment"># 配置Sentinel dashboard地址</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8080</span></span><br><span class="line">        <span class="comment"># 默认8719端口，假如被占用会自动从8719开始一次+1扫描，直至找到被占用的端口。</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8719</span></span><br><span class="line">        </span><br><span class="line">      <span class="comment"># 添加Nacos数据源配置</span></span><br><span class="line">      <span class="attr">datasource:</span> </span><br><span class="line">        <span class="attr">ds1:</span> <span class="comment"># 数据源1</span></span><br><span class="line">          <span class="attr">nacos:</span></span><br><span class="line">            <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">            <span class="attr">dataId:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br><span class="line">            <span class="attr">groupId:</span> <span class="string">DEFAULT_GROUP</span></span><br><span class="line">            <span class="attr">data-type:</span> <span class="string">json</span></span><br><span class="line">            <span class="attr">rule-type:</span> <span class="string">flow</span> <span class="comment"># 流控规则</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">        </span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">sentinel:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 激活Sentinel对Feign的支持</span></span><br></pre></td></tr></table></figure></li><li><p>在nacos中新建配置</p></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1659426397413-c51571ba-14b0-40bb-98ef-72739722e89d.png#clientId=ube3dba84-68f1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=438&id=ue698c43c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=858&originWidth=1310&originalType=binary&ratio=1&rotation=0&showTitle=false&size=135645&status=done&style=none&taskId=u4ceb4560-56e5-4635-a195-9578d2f76d1&title=&width=669" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1659426309216-6fda9089-a928-4621-bcce-2c82c9432d20.png#clientId=ube3dba84-68f1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=235&id=ud04e4ba5&margin=%5Bobject%20Object%5D&name=image.png&originHeight=353&originWidth=1218&originalType=binary&ratio=1&rotation=0&showTitle=false&size=43614&status=done&style=none&taskId=u065e6775-9145-40f0-9794-0e0ef5d4815&title=&width=812" alt="image.png"></p><h1 id="三-Seata处理分布式事务"><a href="#三-Seata处理分布式事务" class="headerlink" title="三.Seata处理分布式事务"></a>三.Seata处理分布式事务</h1><p>Seata 是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。</p><h2 id="1-分布式事务"><a href="#1-分布式事务" class="headerlink" title="1.分布式事务"></a>1.分布式事务</h2><p><strong>分布式事务</strong>，就是指不是在单个服务或单个数据库架构下，产生的事务，例如</p><ul><li>跨数据源的分布式事务</li><li>跨服务的分布式事务</li><li>综合情况</li></ul><p>例如下单业务：<br><img src="https://cdn.nlark.com/yuque/0/2022/webp/27782283/1659426717206-61672052-0806-4f4b-945e-8393c994494a.webp#clientId=ube3dba84-68f1-4&crop=0&crop=0&crop=1&crop=1&from=drop&id=ubbf955e9&margin=%5Bobject%20Object%5D&name=202205231447738.webp&originHeight=468&originWidth=1217&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12138&status=done&style=none&taskId=ucc4a450a-837b-463b-9fc3-de4af6fbbcb&title=" alt="202205231447738.webp"><br>这时候就需要保证三个操作同时成功，也就是原子性，就需要用到分布式事务。</p><h2 id="2-Seata"><a href="#2-Seata" class="headerlink" title="2. Seata"></a>2. Seata</h2><p>官网：<a href="http://seata.io/zh-cn/">http://seata.io/zh-cn/</a></p><h3 id="2-1-分布式事务处理过程"><a href="#2-1-分布式事务处理过程" class="headerlink" title="2.1 分布式事务处理过程"></a>2.1 分布式事务处理过程</h3><p>一ID+三组件模型：（班级号，授课老师，班主任，学生）</p><ul><li><strong>Transaction ID XID：</strong>全局唯一的事务ID</li><li><strong>TC (Transaction Coordinator) - 事务协调者：</strong>维护全局和分支事务的状态，协调全局事务提交或回滚。</li><li><strong>TM (Transaction Manager) - 事务管理器：</strong>定义全局事务的范围、开始全局事务、提交或回滚全局事务。</li><li><strong>RM (Resource Manager) - 资源管理器：</strong>管理分支事务处理的资源，与 TC 交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li></ul><p>处理过程：</p><ol><li>TM 向 TC 申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的 XID；</li><li>XID 在微服务调用链路的上下文中传播；</li><li>RM 向 TC 注册分支事务，将其纳入 XID 对应全局事务的管辖；</li><li>TM 向 TC 发起针对 XID 的全局提交或回滚决议；</li><li>TC 调度 XID 下管辖的全部分支事务完成提交或回滚请求。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1659427152258-cb83755a-ef2a-4f9e-970a-c3505b1b3ce4.png#clientId=ube3dba84-68f1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=325&id=u5035ee8c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=487&originWidth=836&originalType=binary&ratio=1&rotation=0&showTitle=false&size=77501&status=done&style=none&taskId=u097b0da0-38df-4340-b732-b3cb1ee6d83&title=&width=557.3333333333334" alt="image.png"></p><h3 id="2-2-使用方法"><a href="#2-2-使用方法" class="headerlink" title="2.2 使用方法"></a>2.2 使用方法</h3><p>本地@Transactional<br><strong>全局@GlobalTransactional</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/27782283/1659427236330-eea62b29-af04-4f19-a9c3-91c8db9c2ae3.png#clientId=ube3dba84-68f1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=346&id=u900fb13f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=519&originWidth=809&originalType=binary&ratio=1&rotation=0&showTitle=false&size=87389&status=done&style=none&taskId=ua32209e2-28ad-4d98-a0fd-2ed67b05527&title=&width=539.3333333333334" alt="image.png"></p><h3 id="2-3-AT模式"><a href="#2-3-AT模式" class="headerlink" title="2.3 AT模式"></a>2.3 AT模式</h3><p>参考官网：<a href="http://seata.io/zh-cn/docs/overview/what-is-seata.html">http://seata.io/zh-cn/docs/overview/what-is-seata.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-内存及垃圾回收</title>
      <link href="/coderbin/ef33a712.html"/>
      <url>/coderbin/ef33a712.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h1><h2 id="类加载子系统一"><a href="#类加载子系统一" class="headerlink" title="类加载子系统一"></a>类加载子系统一</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699171422-27f069a7-962d-45ea-98c5-44bf524d1371.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u5a326163&margin=%5Bobject%20Object%5D&name=image.png&originHeight=579&originWidth=706&originalType=url&ratio=1&rotation=0&showTitle=false&size=161325&status=done&style=none&taskId=ub324f2a4-f9fe-428f-a987-f86af36f396&title=" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699171386-29e85e62-d7d9-4bf1-9714-2df26bec5cdc.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u4f09d4cd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=322&originWidth=856&originalType=url&ratio=1&rotation=0&showTitle=false&size=120382&status=done&style=none&taskId=u99b76d41-c99c-4f2c-99e7-6e91ba5d719&title=" alt="image.png"></p><h3 id="类加载子系统作用"><a href="#类加载子系统作用" class="headerlink" title="类加载子系统作用"></a>类加载子系统作用</h3><ol><li>负责从文件系统或者网络中加载Class文件，Class文件开头有特定标识（cafebabe）</li><li>Classloader只负责class文件的加载，至于是否可运行，则有执行引擎决定</li><li>加载的类信息存放于称为方法区的内存空间，除了类信息，方法区还会存放运行时常量池信息，还可能包括字符串字面量和数字常量。（常量池运行时加载到内存中，即运行时常量池）</li></ol><h3 id="类加载器ClassLoader的角色"><a href="#类加载器ClassLoader的角色" class="headerlink" title="类加载器ClassLoader的角色"></a>类加载器ClassLoader的角色</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699171350-4fd53ff9-f37b-42cc-899c-ef2257315573.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u937e1fd8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=607&originWidth=908&originalType=url&ratio=1&rotation=0&showTitle=false&size=56576&status=done&style=none&taskId=u59952d76-78a3-4bd6-9147-40b717103f9&title=" alt="image.png"></p><p>1.class file 存在与本地硬盘上。可以理解为设计师画在之上的模板，而最终这个模板在执行的时候是要加载到JVM当中来，根据这个文件实例化出n个一模一样的实例。</p><p>2.class file 加载带JVM中，被称为DNA元数据模块，放在方法区。</p><p>3.在 .class 文件 –&gt; JVM –&gt; 最终成为元数据模板，此过程就要一个运输工具（类装载器 Class Loader），扮演一个快递员的角色。</p><h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699189236-3f050a78-50fc-494d-8293-3e4c169c2a29.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u8f59760f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=239&originWidth=715&originalType=url&ratio=1&rotation=0&showTitle=false&size=185629&status=done&style=none&taskId=ue06f9f44-cd40-475f-9ab1-9f403b893ef&title=" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699189213-62e435db-9d7d-4f29-8d84-373274fd76eb.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uc746b309&margin=%5Bobject%20Object%5D&name=image.png&originHeight=437&originWidth=555&originalType=url&ratio=1&rotation=0&showTitle=false&size=66533&status=done&style=none&taskId=u97ec9e5e-9a9c-4365-a56b-62e9acb0e1a&title=" alt="image.png"></p><h4 id="一-加载"><a href="#一-加载" class="headerlink" title="一.加载"></a>一.加载</h4><ol><li>通过一个类的全限定名获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的**java.lang.Class **对象，作为方法区这个类的各种数据的访问入口。</li></ol><p>&#x2F;**<br>补充：加载  .Class 文件的方式<br>1.从本地系统中直接加载<br>2.通过网络获取，典型场景：Web Applet<br>3.从 zip 压缩包中读取，成为日后 jar、war 格式的基础<br>4.运行时计算生成，使用最多的是：动态代理技术<br>5.有其他文件生成，典型场景：JSP应用<br>6.从专有数据库中提取 .class 文件，比较少见<br>7.从加密文件中获取，典型的防 Class 文件被反编译的保护措施<br>**&#x2F;</p><h4 id="二-链接"><a href="#二-链接" class="headerlink" title="二.链接"></a>二.链接</h4><h5 id="1-验证-Verify"><a href="#1-验证-Verify" class="headerlink" title="1.验证(Verify)"></a>1.验证(Verify)</h5><p>（1）目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。<br>（2）主要包括四种验证：<br>文件格式验证：</p><p>A.CA FE BA BE</p><p>B.主次版本号</p><p>C.常量池的常量中是否有不被支持的常量类型。</p><p>D. 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</p><p>元数据验证：</p><p>A.对字节码描述的信息进行语义分析，保证描述符合Java规范</p><p>B.类是否有父类，除了Object之外，所有的类都应该有父类</p><p>C.类的父类是否继承了不允许被继承的类（被final修饰的类）</p><p>D.如果这个类不是抽象类，是否实现了其父类或接口中要求实现的所有方法。<br>E.类的字段，方法是否与父类的产生矛盾。例如方法参数都一样，返回值不同</p><p>字节码验证：</p><p>A.通过数据流分析和控制流分析，确定程序语义是合法的，符合逻辑的。</p><p>B.对类的方法体，进行校验分析，保证在运行时不会做出危害虚拟机的行为</p><p>C.保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，不会出现类似于在操作数栈放了一个int类型的数据，使用时却按照long类型加载到本地变量表中的情况。</p><p>D.保障任何跳转指令都不会跳转到方法体之外的字节码指令上。</p><p>符号引用验证：</p><p>A.通过字符串描述的全限定名是否能找到对应的类</p><p>B.符号引用中的类、字段、方法的可访问性是否可被当前类访问</p><h5 id="2-准备-Prepare"><a href="#2-准备-Prepare" class="headerlink" title="2.准备(Prepare)"></a>2.准备(Prepare)</h5><p>(1)为类变量分配内存并且设置该类变量的默认初始值，即零值。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699189180-b3142004-5374-4d05-acac-2ad00a66b532.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ueba01c74&margin=%5Bobject%20Object%5D&name=image.png&originHeight=242&originWidth=848&originalType=url&ratio=1&rotation=0&showTitle=false&size=30561&status=done&style=none&taskId=u985e86a9-d1da-4bc8-8dcf-3d838aeefc5&title=" alt="image.png"></p><p>(2)不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显示初始化</p><p>(3)不会为实例变量分配初始化，类变量会分配在方法区中，实例变量会随着对象一<br>起分配到Java堆中-</p><h5 id="3-解析-Resolve"><a href="#3-解析-Resolve" class="headerlink" title="3.解析(Resolve)"></a>3.解析(Resolve)</h5><p>(1)将常量池内的符号引用转换为直接引用的过程<br>(2)解析操作往往会伴随着JVM在执行完初始化之后再执行<br>(3)符号引用就是一组符号来描述所应用的目标，符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中<br>(4)直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。<br>(5)解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info</p><h4 id="三-初始化"><a href="#三-初始化" class="headerlink" title="三.初始化"></a>三.初始化</h4><p>1.初始化阶段就是执行类构造器方法 <clinit>() 的过程。<br>2.此方法不需定义，是javac编译器自动收集类中的所有变量的赋值动作和静态代码块中的语句合并而来<br>3.构造器方法中指令按语句再源文件中出现的顺序执行<br>4.   <clinit>()  不同于类的构造器。（关联：构造器是虚拟机视角下的 <init>() ）<br>5.若该类具有父类，JVM会保证子类的<clinit>() 执行前，父类的<clinit>() 已经执行完毕<br>6.虚拟机必须保证一个类的<clinit>() 方法在多线程下被同步加锁</p><h4 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h4><p>一.加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的。</p><p>二.解析阶段不一定，在某些情况下可以在初始化阶段之后再开始，为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）</p><p>三.Java虚拟机规范严格规定了，有且只有六种情况，必须立即对类进行初始化</p><p>1、遇到new,getstatic，putstatic或invokestatic这四条字节码指令时。<br>使用new关键字实例化对象<br>读取或设置一个类型的静态字段（final修饰已在编译期将结果放入常量池的静态字段除外）<br>调用一个类型的静态方法的时候</p><p>2、对类型进行反射调用，如果类型没有经过初始化，则需要触发初始化</p><p>3、初始化类的时候，发现父类没有初始化，则先触发父类初始化</p><p>4、虚拟机启动时，用户需要指定一个要执行的主类（包含main方法的那个类），虚拟机会初始化这个主类</p><p>5、只用JDK7中新加入的动态语言支持，如果一个java.lang.invoke.MethodHandler实例最后的解析结果为REF_getStatic,REF_putStatic,REF_invokeStatic，REF_newInvokeSpecial四种类型的方法句柄，并且这个方法对应的类没有进行初始化，则先触发其初始化</p><p>6、当一个接口中定了JDK8新加入的默认方法时，如果这个接口的实现类发生了初始化，要先将接口进行初始化</p><p>除了以上几种情况，其他使用类的方式被看做是对类的被动使用，都不会导致类的初始化</p><h2 id="类加载子系统二"><a href="#类加载子系统二" class="headerlink" title="类加载子系统二"></a>类加载子系统二</h2><h3 id="一-类加载器分类"><a href="#一-类加载器分类" class="headerlink" title="一.类加载器分类"></a>一.类加载器分类</h3><p>1.引导类加载器（使用C&#x2F;C++编写）<br>2.自定义加载器<br>概念：所有派生于抽象类ClassLoader 的类加载器都划分为自定义类加载器</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699344121-d6003fc0-16bc-4346-93fe-2caf51656e35.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uc079fe01&margin=%5Bobject%20Object%5D&name=image.png&originHeight=484&originWidth=891&originalType=url&ratio=1&rotation=0&showTitle=false&size=29468&status=done&style=none&taskId=u732afc2e-5157-4eaa-b2f2-123ddb6564e&title=" alt="image.png"></p><p>类：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699344365-1a4fb04f-ba96-4806-8cc4-d586e7a2d26c.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uf57680ff&margin=%5Bobject%20Object%5D&name=image.png&originHeight=588&originWidth=1150&originalType=url&ratio=1&rotation=0&showTitle=false&size=358457&status=done&style=none&taskId=u89ce48e8-1be4-41a9-84b6-aebc8ca446d&title=" alt="image.png"></p><h3 id="二-代码获取类加载器："><a href="#二-代码获取类加载器：" class="headerlink" title="二.代码获取类加载器："></a>二.代码获取类加载器：</h3><p>1.截图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699344450-d664b00d-2026-49ee-a4e9-3622335086ec.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u845ff23c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=547&originWidth=1136&originalType=url&ratio=1&rotation=0&showTitle=false&size=470164&status=done&style=none&taskId=u9724d770-5f5b-421c-be84-ab87334e2b8&title=" alt="image.png"></p><p>2.对于用户来说定义器来说，默认使用系统类加载器进行加载</p><p>3.JAVA的核心类库，使用引导类加载器进行加载</p><h3 id="三-启动类加载器（引导类加载器，Bootstrap-ClassLoader）："><a href="#三-启动类加载器（引导类加载器，Bootstrap-ClassLoader）：" class="headerlink" title="三.启动类加载器（引导类加载器，Bootstrap,ClassLoader）："></a>三.启动类加载器（引导类加载器，Bootstrap,ClassLoader）：</h3><ol><li>C&#x2F;C++语言实现，嵌套在JVM内部</li><li>用来加载JAVA的核心库（JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar 、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类。<ol><li>代码获取加载路径</li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699344193-7f79c54a-6ae8-41b5-b791-2fcdaebc9685.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u6fe22e4a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=122&originWidth=892&originalType=url&ratio=1&rotation=0&showTitle=false&size=112503&status=done&style=none&taskId=u1e570db6-a961-4d0c-a73c-c6d089ce806&title=" alt="image.png"></p><ol><li>并不继承自java.lang.ClassLoader ，没有父加载器。</li><li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li><li>出于安全考虑，Boostrap启动类加载器只加载包名为Java、javax、sun等开头的类。</li></ol><h3 id="四-扩展类加载器（java9-平台类加载器"><a href="#四-扩展类加载器（java9-平台类加载器" class="headerlink" title="四.扩展类加载器（java9:平台类加载器)"></a>四.扩展类加载器（java9:平台类加载器)</h3><ol><li>JAVA语言编写，由 sun.misc.Launcher$ExtClassLoader 实现。</li><li>派生于ClassLoader类</li><li>父类加载器为启动类加载器</li><li>从 java.ext.dirs 系统属性所指定的目录中加载类库，或从JDK的安装目录的jre&#x2F;lib&#x2F;est子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。<ol><li>代码</li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699344239-7139606f-07bc-45a9-9ea4-25714d9bdb2f.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=udf0d5e47&margin=%5Bobject%20Object%5D&name=image.png&originHeight=212&originWidth=769&originalType=url&ratio=1&rotation=0&showTitle=false&size=144592&status=done&style=none&taskId=u3c5849d6-364c-4f34-99f6-919c318fe98&title=" alt="image.png"></p><h3 id="五-应用程序类加载器（系统类加载器：AppClassLoader）"><a href="#五-应用程序类加载器（系统类加载器：AppClassLoader）" class="headerlink" title="五.应用程序类加载器（系统类加载器：AppClassLoader）"></a>五.应用程序类加载器（系统类加载器：AppClassLoader）</h3><ol><li>java语言编写，由sun.misc.Launcher$AppClassLoader实现</li><li>派生于ClassLoader 类</li><li>父类加载器为扩展类加载器</li><li>负责加载环境变量classpath或系统属性 java.class.path 指定路径下的类库</li><li>该类加载时程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li><li>通过ClassLoader#getSystemClassLoader（）方法可以获取到该类加载器</li></ol><h3 id="六-用户自定义类加载器"><a href="#六-用户自定义类加载器" class="headerlink" title="六.用户自定义类加载器"></a>六.用户自定义类加载器</h3><ol><li>为什么要用自定义类加载器<ol><li>隔离加载类<ol><li>例如使中间件的Jar包与应用程序Jar包不冲突</li></ol></li><li>修改类加载的方式<ol><li>启动类加载器必须使用，其他可以根据需要自定义加载</li></ol></li><li>扩展加载源</li><li>防止源码泄露<ol><li>对字节码进行加密，自定义类加载器实现解密</li></ol></li></ol></li><li>实现步骤<ol><li>继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器</li><li>1.2之前，继承并重写loadClass方法，1.2之后，建议把自定义的类加载逻辑写在findClass()方法中</li><li>如果没有太过复杂的需求，可以直接继承URLClassLoader类，可以避免自己编写findClass（）方法，及其获取字节码流的方式，使自定义类加载器编写更加简洁</li></ol></li></ol><h3 id="七-关于CLassLoader"><a href="#七-关于CLassLoader" class="headerlink" title="七.关于CLassLoader"></a>七.关于CLassLoader</h3><ol><li>是一个抽象类，除了启动类加载器，其他类加载器都继承自他</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699345083-a88f974d-56f6-431b-bc9c-5d78b0b930db.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u7f0ab734&margin=%5Bobject%20Object%5D&name=image.png&originHeight=314&originWidth=1078&originalType=url&ratio=1&rotation=0&showTitle=false&size=193738&status=done&style=none&taskId=u496eafa5-7ebd-494a-a3ff-68e40039aca&title=" alt="image.png"></p><h3 id="八-双亲委派机制"><a href="#八-双亲委派机制" class="headerlink" title="八.双亲委派机制"></a>八.双亲委派机制</h3><p>原理：Java虚拟机对Class文件采用的是按需加载，而且加载class文件时，Java虚拟机使用的是双亲委派模式，即把请求交由父类处理，它是异种任务委派模式。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699378231-698c9adf-f26b-427f-9fa3-990866dd0489.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uc3644a1b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=531&originWidth=656&originalType=url&ratio=1&rotation=0&showTitle=false&size=224838&status=done&style=none&taskId=ud433fd7c-1d4a-479c-ae9f-d67178fec22&title=" alt="image.png"></p><ol><li>如果一个类加载器收到了类加载请求，它并不会自己先去加载。而是把这个请求委托给父类的加载器去执行</li><li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将达到顶层的启动类加载器</li><li>如果父类的加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699378428-6a14a1de-b264-4129-873e-c72b864f45d1.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ufa80679b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=576&originWidth=811&originalType=url&ratio=1&rotation=0&showTitle=false&size=509119&status=done&style=none&taskId=u7e6ecec2-d67d-4937-96c0-665ab4e9c3c&title=" alt="image.png"></p><h4 id="一-双亲委派机制优势"><a href="#一-双亲委派机制优势" class="headerlink" title="一.双亲委派机制优势"></a>一.双亲委派机制优势</h4><ol><li>避免类的重复加载</li><li></li></ol><h3 id="九-沙箱安全机制"><a href="#九-沙箱安全机制" class="headerlink" title="九.沙箱安全机制"></a>九.沙箱安全机制</h3><ol><li>保证对Java核心源代码的保护</li></ol><p>&#x2F;**<br>补充：</p><ol><li>在JVM中表示两个class对象，是否为同一个类存在两个必要条件<ol><li>类的完整类名必须一致，包括包名</li><li>加载这个类的ClassLoader必须相同</li></ol></li><li>JVM必须知道一个类型是由启动类加载器加载的，还是由用户类加载器加载的。如果是用户类加载器加载的，JVM会将这个类加载器的一个引用作为类型信息的一部分，保存到方法区中。</li></ol><p>**&#x2F;</p><h1 id="运行时数据区概述"><a href="#运行时数据区概述" class="headerlink" title="运行时数据区概述"></a>运行时数据区概述</h1><h2 id="⭐程序寄存器（PC寄存器）"><a href="#⭐程序寄存器（PC寄存器）" class="headerlink" title="⭐程序寄存器（PC寄存器）"></a>⭐程序寄存器（PC寄存器）</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699544276-20b8db39-7140-4fb3-a6e0-34f7c8c2add4.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u7eeeeedc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=545&originWidth=1021&originalType=url&ratio=1&rotation=0&showTitle=false&size=200125&status=done&style=none&taskId=ua5a90dc1-5bf7-41c7-9a44-3932d39ee14&title=" alt="image.png"></p><ul><li>运行时数据区中唯一不会出现OOM（OOM:out of memory）的区域，没有垃圾回收(GC)</li><li>当前线程所执行的字节码的行号指示器<ul><li>为了线程切换后能恢复到正确的位置</li></ul></li><li>每个线程有一个独立的程序计数器，线程之间互不影响。</li><li>如果线程执行的Java方法，则计数器记录正在执行的虚拟机字节码的指令的地址</li><li>如果正在执行的本地方法，这个计数器值则应为空。（undefined）</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699544325-dc158f8f-b18f-484f-942e-d430c6919817.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua1d43bb4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=589&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&size=241131&status=done&style=none&taskId=u4c4f529d-c1df-4cf1-a878-15303488957&title=" alt="image.png"></p><h2 id="⭐虚拟机栈"><a href="#⭐虚拟机栈" class="headerlink" title="⭐虚拟机栈"></a>⭐虚拟机栈</h2><h3 id="一，内存中的栈和堆"><a href="#一，内存中的栈和堆" class="headerlink" title="一，内存中的栈和堆"></a>一，内存中的栈和堆</h3><ul><li>栈是运行时的单位，而堆是存储的单位，栈解决程序如何执行，如何处理数据。堆解决的是数据存储问题，即数据怎么放，放在哪里。</li><li><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699564568-37d9f6c1-1e47-41e4-9598-306f4e524cdb.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u75c54b67&margin=%5Bobject%20Object%5D&name=image.png&originHeight=360&originWidth=490&originalType=url&ratio=1&rotation=0&showTitle=false&size=55445&status=done&style=none&taskId=ua63a0512-3428-41b1-8481-33db12bdec7&title=" alt="image.png"></li></ul><h3 id="二，基本内容"><a href="#二，基本内容" class="headerlink" title="二，基本内容"></a>二，基本内容</h3><ul><li>Java虚拟机栈，早起也叫Java栈，每个线程创建时都会创建一个虚拟机栈，内部保存一个个栈帧，对应着一次次的Java方法调用<ul><li>线程私有的</li><li><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699564581-c0610d3f-d586-4044-aab2-6bf098a4e1e6.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u5ee2737e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=400&originWidth=642&originalType=url&ratio=1&rotation=0&showTitle=false&size=56011&status=done&style=none&taskId=uc68664bf-161e-4c65-8068-066e89c89e6&title=" alt="image.png"></li></ul></li><li>生命周期<ul><li>生命周期和线程的一致</li></ul></li><li>作用<ul><li>主管Java程序的运行，保存方法的局部变量（8种基本数据类型，对象的引用地址），部分结果，并参与方法的调用和返回。<ul><li>局部变量  vs  成员变量</li><li>基本数据类型   VS 引用类型变量（类，数组，接口）</li></ul></li></ul></li></ul><h3 id="三，优点"><a href="#三，优点" class="headerlink" title="三，优点"></a>三，优点</h3><ul><li>快速有效的存储方式，访问速度仅次于程序计数器</li><li>JVM直接对JAVA栈的操作只有两个<ul><li>每个方法执行，伴随着进栈（入栈，压栈）</li><li>执行结束的出栈</li></ul></li><li>栈不存在垃圾回收，但是存在OOM<ul><li>Java栈大小是动态或者固定不变的。如果是动态扩展，无法申请到足够内存OOM，如果是固定，线程请求的栈容量超过固定值，则StackOverflowError</li></ul></li><li>使用-Xss (记忆：站着做一个小手术，栈Xss)，设置线程的最大栈空间</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699564776-39fc4cb1-666a-40b4-a166-880e9c394508.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u90d2de3a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=561&originWidth=1274&originalType=url&ratio=1&rotation=0&showTitle=false&size=311025&status=done&style=none&taskId=u83e4b353-90dd-495c-a6e8-2fc8b764856&title=" alt="image.png"></p><h3 id="四，栈的存储单位"><a href="#四，栈的存储单位" class="headerlink" title="四，栈的存储单位"></a>四，栈的存储单位</h3><ul><li>每个线程都有自己的栈，栈中的数据以栈帧格式存储</li><li>线程上正在执行的每个方法都各自对应一个栈帧</li><li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各个数据信息</li><li>先进后出，后进先出</li><li>一条活动的线程中，一个时间点上，只会有一个活动的栈帧。只有当前正在执行的方法的栈顶栈帧是有效的，这个称为当前栈帧，对应方法是当前方法，对应类是当前类</li><li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作</li><li>如果方法中调用了其他方法，对应的新的栈帧会被创建出来，放在顶端，成为新的当前帧</li></ul><h3 id="五，栈运行原理"><a href="#五，栈运行原理" class="headerlink" title="五，栈运行原理"></a>五，栈运行原理</h3><ul><li>不同线程中包含的栈帧不允许存在相互引用。</li><li>当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为新的栈帧。</li><li>Java方法有两种返回方式<ul><li>一种是正常的函数返回，使用return指令</li><li>另外一种是抛出异常，不管哪种方式，都会导致栈帧被弹出</li></ul></li></ul><h3 id="六，栈帧的内部结构"><a href="#六，栈帧的内部结构" class="headerlink" title="六，栈帧的内部结构"></a>六，栈帧的内部结构</h3><ul><li><p><strong>每个栈帧中存储着：</strong></p><ul><li><strong>局部变量表（Local Variables）</strong></li><li><strong>操作数栈（operand Stack）(或表达式栈)</strong></li><li><strong>动态链接(Dynamic Linking)(或指向运行时常量池的方法引用)</strong></li><li><strong>方法返回地址（Return  Address）(或方法正常退出或者异常退出的定义)</strong></li><li><strong>一些附加信息</strong></li></ul></li><li><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699579695-1232cb55-000a-49b1-a12b-69d10981e476.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u292dbd06&margin=%5Bobject%20Object%5D&name=image.png&originHeight=363&originWidth=1030&originalType=url&ratio=1&rotation=0&showTitle=false&size=103478&status=done&style=none&taskId=u3744c93c-198a-4362-8396-fb7bb447972&title=" alt="image.png"></p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699579772-ddf5ad9e-baf9-4e0a-a8bd-5d4ae5deb81f.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ud5c91f53&margin=%5Bobject%20Object%5D&name=image.png&originHeight=634&originWidth=1131&originalType=url&ratio=1&rotation=0&showTitle=false&size=214087&status=done&style=none&taskId=u4daf5dc7-c544-47b5-88d0-c3638d36fa6&title=" alt="image.png"></p><h2 id="局部变量表（Local-variables）"><a href="#局部变量表（Local-variables）" class="headerlink" title="局部变量表（Local variables）"></a>局部变量表（Local variables）</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>局部变量表也被称为局部变量数组或本地变量表</p><ul><li>定义为一个数字数组，主要用于存储方法参数，定义在方法体内部的局部变量，数据类型包括各类基本数据类型，对象引用，以及return address类型</li><li>局部变量表建立在线程的栈上，是线程私有的，因此不存在数据安全问题</li><li>局部变量表容量大小是在编译期确定下来的</li><li>局部变量表存放编译期可知的各种基本数据类型（8种），引用类型（reference）,return address 类型</li><li>最基本的存储单元是slot（变量槽）<ul><li>32位占用一个slot，64位类型（long和double）占用两个slot</li></ul></li><li>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。</li><li>局部变量表中的变量只有在当前方法调用中有效，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。</li><li>方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁</li></ul><h3 id="关于Slot的理解"><a href="#关于Slot的理解" class="headerlink" title="关于Slot的理解"></a>关于Slot的理解</h3><ul><li><p>VM虚拟机会为局部变量表中的每个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</p></li><li><p>如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this，会存放在index为0的slot处，其余的参数表顺序继续排列</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699631312-edeab655-97ba-45d2-b79a-1e8294b04d2d.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u1f7aab09&margin=%5Bobject%20Object%5D&name=image.png&originHeight=482&originWidth=453&originalType=url&ratio=1&rotation=0&showTitle=false&size=68285&status=done&style=none&taskId=uc438e17a-f29d-41e9-aeb3-2663149746f&title=" alt="image.png"></p><p>this截图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699631460-7183af0a-0f0c-47cf-b2c4-02eba68d35e3.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u1b4dc68d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=493&originWidth=1429&originalType=url&ratio=1&rotation=0&showTitle=false&size=322071&status=done&style=none&taskId=u0907194c-83ff-4b61-a596-7466bf52b99&title=" alt="image.png"></p><ul><li>栈帧中的局部变量表中的槽位是可以重复的，如果一个局部变量过了其作用域，那么其作用域之后申明的新的局部变量就有可能会复用过期局部变量的槽位，从而达到节省资源的目的</li></ul><h2 id="操作数栈-Operand-Stack"><a href="#操作数栈-Operand-Stack" class="headerlink" title="操作数栈(Operand Stack)"></a>操作数栈(Operand Stack)</h2><h3 id="操作数栈（数组实现）："><a href="#操作数栈（数组实现）：" class="headerlink" title="操作数栈（数组实现）："></a>操作数栈（数组实现）：</h3><ul><li><p>在方法执行的过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈&#x2F;出栈</p><ul><li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈，使用它们后再将结果压入栈</li><li>比如：执行复制、交换、求和等操作</li></ul></li><li><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699685117-193b192e-d1ff-48ae-8b75-25b5d61b4677.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u88048f45&margin=%5Bobject%20Object%5D&name=image.png&originHeight=211&originWidth=643&originalType=url&ratio=1&rotation=0&showTitle=false&size=46452&status=done&style=none&taskId=u9556b129-d22f-4901-a1a7-3aa870b3554&title=" alt="image.png"></p></li><li><p>如果被调用方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新程序计数器中下一条需要执行的字节码指令</p></li><li><p>Java虚拟机的解释引擎是基于栈的执行引擎，其中栈就是操作数栈</p></li><li><p>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</p></li><li><p>当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的</p></li><li><p>每一个操作数栈会拥有一个明确的栈深度，用于存储数值，最大深度在编译期就定义好</p></li><li><p>栈中，32bit类型占用一个栈单位深度，64bit类型占用两个栈单位深度</p></li><li><p>操作数栈并非采用访问索引方式进行数据访问，而是只能通过标准的入栈、出栈操作完成一次数据访问</p></li></ul><h3 id="栈顶缓存技术："><a href="#栈顶缓存技术：" class="headerlink" title="栈顶缓存技术："></a>栈顶缓存技术：</h3><ul><li>由于操作数是存储在内存中，频繁的进行内存读写操作影响执行速度，将栈顶元素全部缓存到物理CPU的寄存器中，依此降低对内存的读写次数，提升执行引擎的执行效率</li></ul><h2 id="动态链接（或指向运行时常量池的方法引用）"><a href="#动态链接（或指向运行时常量池的方法引用）" class="headerlink" title="动态链接（或指向运行时常量池的方法引用）"></a>动态链接（或指向运行时常量池的方法引用）</h2><h3 id="指向运行时常量池的方法引用"><a href="#指向运行时常量池的方法引用" class="headerlink" title="指向运行时常量池的方法引用"></a>指向运行时常量池的方法引用</h3><ul><li>每一个栈帧内部都包含一个指向运行时常量池中，该帧所属方法的引用</li><li>目的是为了支持当前方法的代码能够实现动态链接，比如invokedynamic指令</li><li>在java源文件被编译成字节码文件中时，所有的变量、方法引用都作为符号引用，保存在class文件的常量池中。</li><li>描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的。</li><li>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</li><li><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699736179-dcc1544a-d902-4485-8f0f-8fdc87ea266a.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=udcdb452a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=554&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&size=177438&status=done&style=none&taskId=u037a2d80-078c-4480-9f04-34ef32b8d47&title=" alt="image.png"></li></ul><h3 id="常量池、运行时常量池"><a href="#常量池、运行时常量池" class="headerlink" title="常量池、运行时常量池"></a>常量池、运行时常量池</h3><ul><li>常量池在字节码文件中，运行时常量池，在运行时的方法区中</li></ul><h2 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h2><h3 id="一，链接与方法的绑定"><a href="#一，链接与方法的绑定" class="headerlink" title="一，链接与方法的绑定"></a>一，链接与方法的绑定</h3><ul><li>静态链接<ul><li>当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行时期间保持不变，这种情况下降调用方的符号引用转为直接引用的过程称为静态链接</li></ul></li><li>动态链接<ul><li>如果被调用的方法无法再编译期被确定下来，只能在运行期将调用的方法的符号引用转为直接引用，这种引用转换过程具备动态性，因此被称为动态链接</li></ul></li><li>方法的绑定<ul><li>绑定是一个字段、方法、或者类在符号引用被替换为直接引用的过程。仅仅发生一次。</li><li>早期绑定<ul><li>被调用的目标方法如果在编译期可知，且运行期保持不变</li></ul></li><li>晚期绑定<ul><li>被调用的方法在编译期无法被确定，只能够在程序运行期根据实际的类型绑定相关的方法。</li></ul></li></ul></li><li>Java中任何一个普通方法都具备虚函数的特征（运行期确认，具备晚期绑定的特点），C++中则使用关键字virtual来显式定义</li><li>如果在java程序中，不希望某个方法拥有虚函数的特征，则可以使用关键字final来标记这个方法</li></ul><h3 id="二，虚方法和非虚方法"><a href="#二，虚方法和非虚方法" class="headerlink" title="二，虚方法和非虚方法"></a>二，虚方法和非虚方法</h3><ul><li>非虚方法<ul><li>如果方法在编译期就确定了具体的调用版本，则这个版本在运行时是不可变的。这样的方法称为非虚方法，静态方法，私有方法，final方法，实例构造器，父类方法都是非虚方法</li></ul></li><li>其他方法称为虚方法</li></ul><h3 id="三，方法调用指令"><a href="#三，方法调用指令" class="headerlink" title="三，方法调用指令"></a>三，方法调用指令</h3><ul><li>普通调用指令<ul><li>invokestatic<ul><li>调用静态方法，解析阶段确定唯一方法版本</li></ul></li><li>invokespecial<ul><li>调用<init>方法，私有及父类方法，解析阶段确定唯一方法版本</li></ul></li><li>invokevirtual<ul><li>调用所有虚方法（除了final修饰的）</li></ul></li><li>invokeinterface<ul><li>调用接口方法</li></ul></li><li>其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法</li></ul></li><li>动态调用指令JDK1.7新增<ul><li>invokedynamic<ul><li>动态解析出需要调用的方法，然后执行</li></ul></li><li>直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式</li></ul></li><li>静态语言和动态语言<ul><li>区别在于对类型的检查是编译器还是运行期，满足编译期就是静态类型语言，反之就是动态类型语言。</li><li>Java是静态类型语言，动态调用指令增加了动态语言的特性</li></ul></li></ul><h3 id="四，方法重写的本质"><a href="#四，方法重写的本质" class="headerlink" title="四，方法重写的本质"></a>四，方法重写的本质</h3><ul><li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记做C</li><li>如果在类型C中找到与常量池中描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束，如果不通过，则返回java.lang.IllegalAccessError异常</li><li>否则，按照继承关系从下往上依次对C的各个父类进行上一步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常</li></ul><h3 id="五，虚方法表"><a href="#五，虚方法表" class="headerlink" title="五，虚方法表"></a>五，虚方法表</h3><ul><li>面向对象的编程中，会很频繁的使用动态分配，如果每次动态分配的过程都要重新在类的方法元数据中搜索合适的目标的话，就可能影响到执行效率，因此为了提高性能，JVM采用在类的方法区建立一个虚方法表，使用索引表来代替查找</li><li>每个类都有一个虚方法表，表中存放着各个方法的实际入口</li><li>虚方法表会在类加载的链接阶段被创建，并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法也初始化完毕</li><li><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699770979-268cf4d1-9763-4177-a066-f02bb4685d71.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u724d7bd0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=624&originWidth=992&originalType=url&ratio=1&rotation=0&showTitle=false&size=335789&status=done&style=none&taskId=u04a429d1-ef3c-4d67-b152-e691c688f8f&title=" alt="image.png"></li></ul><h2 id="方法返回地址及栈的面试题"><a href="#方法返回地址及栈的面试题" class="headerlink" title="方法返回地址及栈的面试题"></a>方法返回地址及栈的面试题</h2><h3 id="一，方法返回地址"><a href="#一，方法返回地址" class="headerlink" title="一，方法返回地址"></a>一，方法返回地址</h3><ul><li>存放调用该方法的pc寄存器的值</li><li>方法的结束<ul><li>正常执行完成</li><li>出现未处理异常，非正常退出</li></ul></li><li>无论哪种方式退出，方法退出后，都会返回该方法被调用的位置。方法正常退出时，调用者的PC计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。</li><li>异常退出的，返回地址是通过异常表来确定，栈帧中一般不会保存这部分信息</li><li>执行引擎遇到任意一个方法返回的字节码指令（return）,会有返回值传递给上层的方法调用者，简称正常完成出口<ul><li>返回指令包括<ul><li>ireturn返回值是boolean，byte，char，short，和int类型时使用</li><li>lreturn</li><li>dreturn</li><li>areturn<ul><li>引用类型</li></ul></li><li>还有一个return指供声明为 void的方法、实例初始化方法、类和接口的初始化方法使用</li></ul></li></ul></li><li>本质上，方法的退出就是当前栈帧出栈的过程。此时需要恢复上层方法的局部变量表，操作数栈，将返回值压入调用者栈帧的操作数栈，设置PC寄存器值等，让调用者方法继续执行下去。</li><li>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值</li></ul><h3 id="二，一些附加信息"><a href="#二，一些附加信息" class="headerlink" title="二，一些附加信息"></a>二，一些附加信息</h3><ul><li>允许携带与Java虚拟机实现相关的一些附加信息，例如对程序调试提供支持的信息。不确定有，可选情况</li></ul><h3 id="三，面试题"><a href="#三，面试题" class="headerlink" title="三，面试题"></a>三，面试题</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699816203-dfaa7c1f-4481-4c4f-9606-05a87c1e1cd2.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua916ea76&margin=%5Bobject%20Object%5D&name=image.png&originHeight=320&originWidth=787&originalType=url&ratio=1&rotation=0&showTitle=false&size=104013&status=done&style=none&taskId=udf9816f3-831c-45cb-b277-1cfd6fe5a11&title=" alt="image.png"></p><h2 id="⭐本地方法接口与本地方法栈"><a href="#⭐本地方法接口与本地方法栈" class="headerlink" title="⭐本地方法接口与本地方法栈"></a>⭐本地方法接口与本地方法栈</h2><h3 id="一，本地方法接口"><a href="#一，本地方法接口" class="headerlink" title="一，本地方法接口"></a>一，本地方法接口</h3><ul><li>什么是本地方法<ul><li>简单讲，就是一个Java调用非Java代码的接口</li></ul></li><li>为什么使用native method<ul><li>与Java环境外交互<ul><li>例如与操作系统底层或硬件交换信息时的情况</li><li>例如启动一个线程</li></ul></li></ul></li></ul><h3 id="二，本地方法栈"><a href="#二，本地方法栈" class="headerlink" title="二，本地方法栈"></a>二，本地方法栈</h3><ul><li>Java虚拟机栈管理Java方法的调用，而本地方法栈用于管理本地方法的调用</li><li>本地方法栈，也是线程私有的。</li><li>允许被实现成固定或者是可动态扩展的内存大小。<ul><li>内存溢出情况和Java虚拟机栈相同</li></ul></li><li>使用C语言实现</li><li>具体做法是Native Method Stack 中登记native方法，在Execution Engine执行时加载到本地方法库</li><li>当某个线程调用一个本地方法时，就会进入一个全新，不受虚拟机限制的世界，它和虚拟机拥有同样的权限。</li><li>并不是所有的JVM都支持本地方法，因为Java虚拟机规范并没有明确要求本地方法栈的使用语言，具体实现方式，数据结构等</li><li>Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一</li></ul><h2 id="⭐堆"><a href="#⭐堆" class="headerlink" title="⭐堆"></a>⭐堆</h2><h3 id="一，堆的核心概念"><a href="#一，堆的核心概念" class="headerlink" title="一，堆的核心概念"></a>一，堆的核心概念</h3><ul><li>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域</li><li>Java堆区在JVM启动的时候即被创建，其空间大小也就确认了。堆内存的大小是可调节的</li><li>Java虚拟机规范规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</li><li><strong>所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（TLAB）</strong></li><li>“几乎”所有的对象实例都在这里分配内存</li><li>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，引用指向对象或者数组在堆中的位置</li><li>方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</li><li>堆是GC执行垃圾回收的重点区域</li><li>堆空间细分为：<ul><li>Java7及之前<ul><li>内存逻辑上分为：<ul><li>新生区<ul><li>Eden区（伊甸园区）</li><li>Survivor区（幸存者区）<ul><li>from</li><li>to<ul><li>谁空谁是to</li></ul></li></ul></li></ul></li><li>养老区</li><li>永久区</li></ul></li></ul></li><li>Java8及之后<ul><li>内存逻辑上分为：<ul><li>新生区<ul><li>Eden区</li><li>Survivor区<ul><li>from</li><li>to<ul><li>谁空谁是to</li></ul></li></ul></li></ul></li><li>养老区</li><li>元空间</li></ul></li></ul></li><li>约定<ul><li>新生区&#x3D;&#x3D;新生代&#x3D;&#x3D;年轻代</li><li>养老区&#x3D;&#x3D;老年区&#x3D;&#x3D;老年代</li><li>永久区&#x3D;&#x3D;永久代</li></ul></li></ul></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699890317-38196b21-ac49-48e3-abcf-1a0a2052dae1.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uead3a694&margin=%5Bobject%20Object%5D&name=image.png&originHeight=529&originWidth=987&originalType=url&ratio=1&rotation=0&showTitle=false&size=137359&status=done&style=none&taskId=u0b48d8cf-0ef7-4382-938d-a888a294402&title=" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699890485-bf6d64fc-7567-44df-9a9a-1c72ebf643b0.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u0dcfe437&margin=%5Bobject%20Object%5D&name=image.png&originHeight=609&originWidth=1168&originalType=url&ratio=1&rotation=0&showTitle=false&size=404260&status=done&style=none&taskId=uf6e5294b-db7a-4ea4-9aaf-75cf031333f&title=" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699890279-fac113a1-41f1-43d3-a751-e370e5a83488.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=udb2113fc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=339&originWidth=596&originalType=url&ratio=1&rotation=0&showTitle=false&size=91261&status=done&style=none&taskId=ue7cee9cf-a8a9-4852-b92e-69d7fb956eb&title=" alt="image.png"></p><h3 id="二，设置堆内存大小与OOM"><a href="#二，设置堆内存大小与OOM" class="headerlink" title="二，设置堆内存大小与OOM"></a>二，设置堆内存大小与OOM</h3><ul><li>-Xms ：小秘书表示堆空间的起始内存。</li><li>-Xmx：小明星表示堆空间的最大内存<ul><li>超过最大内存将抛出OOM</li></ul></li><li><strong>通常将-Xms和-Xmx两个参数配置相同的值，其目的是为了能够在java垃圾会后清理完堆区后，不需要重新分隔计算堆区的大小，从而提高性能</strong></li><li><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699905303-c1cc8471-99c4-4196-aece-2b0af01803fa.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u37429759&margin=%5Bobject%20Object%5D&name=image.png&originHeight=108&originWidth=672&originalType=url&ratio=1&rotation=0&showTitle=false&size=46206&status=done&style=none&taskId=u9e967fc3-a17a-4b3b-a3b8-3ec861d80e8&title=" alt="image.png"></li><li></li><li><strong>代码：</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699905518-a79b2777-758e-4067-b0d9-b64c2c27c343.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u83353842&margin=%5Bobject%20Object%5D&name=image.png&originHeight=444&originWidth=1197&originalType=url&ratio=1&rotation=0&showTitle=false&size=390653&status=done&style=none&taskId=u3614caa3-0e2d-43fa-be27-c33f21f0839&title=" alt="image.png"></p><ul><li><p>jps命令</p><ul><li>查看当前程序运行的进程</li></ul></li><li><p>jstat</p><ul><li>查看JVM在gc时的统计信息<ul><li>jstat -gc 进程号</li></ul></li></ul></li><li><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699905311-f227ea29-13d3-4496-aae2-eb11bb0e3054.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u6a245d68&margin=%5Bobject%20Object%5D&name=image.png&originHeight=81&originWidth=600&originalType=url&ratio=1&rotation=0&showTitle=false&size=41272&status=done&style=none&taskId=ubd01b523-ed83-4105-8504-76f903e16ce&title=" alt="image.png"></p></li></ul><h3 id="三，年轻代与老年代"><a href="#三，年轻代与老年代" class="headerlink" title="三，年轻代与老年代"></a>三，年轻代与老年代</h3><ul><li>-XX:NewRatio&#x3D;2，表示新生代占1，老年代占2，新生代占整个堆的1&#x2F;3<ul><li>ratio：比率比例的意思</li></ul></li><li>jinfo -flag NewRatio 进程号，查看参数设定值</li><li>在HotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是：8:1:1<ul><li>-XX:SurvivorRatio调整这个空间比例<ul><li>Eden与Survivor区的比例</li></ul></li><li>实际是6:1:1，因为有自适应机制<ul><li>-XX:-UseAdaptiveSizePolicy：-表示关闭自适应，实际没有用。直接用Ratio分配即可</li></ul></li></ul></li><li>几乎所有的Java对象都是在Eden区被new出来的。<ul><li>Eden放不了的大对象，直接进入老年代了。</li></ul></li><li>IBM研究表明，新生代80%的对象都是朝生夕死</li><li>-Xmn：洗面奶，设置新生代最大内存大小，如果同时设置了新生代比例与此参数冲突，则以此参数为准。</li></ul><h3 id="四，图解对象分配一般过程"><a href="#四，图解对象分配一般过程" class="headerlink" title="四，图解对象分配一般过程"></a>四，图解对象分配一般过程</h3><ul><li>1、new的对象先放在Eden区，此区有大小限制</li><li>2、当创建新对象，<strong>Eden空间填满时，会触发Minor GC</strong>，将Eden不再被其他对象引用的对象进行销毁。再加载新的对象放到Eden区</li><li>3、将Eden中剩余的对象移到幸存者0区</li><li>4、再次触发垃圾回收，此时上次幸存者下来的，放在幸存者0区的，如果没有回收，就会放到幸存者1区</li><li>5、再次经历垃圾回收，又会将幸存者重新放回幸存者0区，依次类推</li><li>6、可以设置一个次数，默认是15次，超过15次，则会将幸存者区幸存下来的转去老年区<ul><li>-XX:MaxTenuringThreshold&#x3D;N进行设置</li></ul></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700009211-c51e14d4-f36f-406a-bb50-a920c8df2338.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ucb93d5db&margin=%5Bobject%20Object%5D&name=image.png&originHeight=761&originWidth=1001&originalType=url&ratio=1&rotation=0&showTitle=false&size=253292&status=done&style=none&taskId=ufd7f2dd9-4b02-4382-ac66-37b29c8c1a0&title=" alt="image.png"></p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul><li><strong>针对幸存者s0，s1区的总结：复制之后有交换，谁空谁是to</strong></li><li><strong>频繁在新生区收集，很少在养老区收集，几乎不在永久区&#x2F;元空间搜集</strong></li></ul><p>对象分配特殊过程：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700009211-bed9e395-7313-41a7-99b2-176559159f86.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u5d8ef843&margin=%5Bobject%20Object%5D&name=image.png&originHeight=649&originWidth=804&originalType=url&ratio=1&rotation=0&showTitle=false&size=259251&status=done&style=none&taskId=u00425c32-832d-4365-ae71-8b02f1fae83&title=" alt="image.png"></p><ul><li><strong>触发YGC，幸存者区就会进行回收，不会主动进行回收</strong></li><li><strong>超大对象eden放不下，就要看Old区大小是否可以放下</strong><ul><li><strong>old区也放不下，需要FullGC（MajorGC），这两GC概念还是有区别的。下面详解</strong></li></ul></li></ul><h2 id="MinorGC，MajorGC，FullGC"><a href="#MinorGC，MajorGC，FullGC" class="headerlink" title="MinorGC，MajorGC，FullGC"></a>MinorGC，MajorGC，FullGC</h2><h3 id="一，MinorGC，MajorGC，FullGC"><a href="#一，MinorGC，MajorGC，FullGC" class="headerlink" title="一，MinorGC，MajorGC，FullGC"></a>一，MinorGC，MajorGC，FullGC</h3><ul><li>针对HotSpotVM的实现<ul><li>GC按照内存回收区域分为<ul><li>部分收集<ul><li>新生代收集<ul><li>MinorGC （YoungGC）</li></ul></li><li>老年代收集<ul><li>MajorGC&#x2F;oldGC<ul><li>目前只有CMS GC会单独收集老年代的行为</li><li>很多时候MajorGC与FullGC混淆使用，具体分辨是老年代回收还是整堆回收</li></ul></li></ul></li><li>混合收集<ul><li>收集整个新生代以及部分老年代的垃圾收集<ul><li>目前只有G1 GC会有这种行为</li></ul></li></ul></li></ul></li><li>整堆收集<ul><li>收集整个Java堆和方法区的垃圾收集</li></ul></li></ul></li></ul></li></ul><h3 id="二，MinorGC的触发条件"><a href="#二，MinorGC的触发条件" class="headerlink" title="二，MinorGC的触发条件"></a>二，MinorGC的触发条件</h3><ul><li>当年轻代空间不足时，就会触发MinorGC，这里的年轻代指的是Eden代满，Survivor满不会触发GC。每次MinorGC会清理年轻代的内存</li><li>因为Java对象大多朝生夕灭，所以MinorGC非常频繁<ul><li>Minor翻译，较小的，未成年的</li></ul></li><li>MinorGC会引发STW</li></ul><h3 id="三，老年代GC（MajorGC-x2F-FullGC）触发条件"><a href="#三，老年代GC（MajorGC-x2F-FullGC）触发条件" class="headerlink" title="三，老年代GC（MajorGC&#x2F;FullGC）触发条件"></a>三，老年代GC（MajorGC&#x2F;FullGC）触发条件</h3><ul><li>指发生在老年代的GC，对象从老年代消失，我们说“MajorGC”“FullGC”发生了</li><li>出现了MajorGC，经常会伴随至少一次MinorGC<ul><li>非绝对，在Parallel Scavenge收集器的收集策略里就直接进行MajorGC的策略选择过程</li><li>也就是老年代空间不足，会先尝试触发MinorGC，如果之后空间还不足，则触发MajorGC</li></ul></li><li>MajorGC的速度比MinorGC慢10倍以上，STW的时间更长</li><li>如果MajorGC后，内存还不足，就报OOM了</li></ul><h3 id="四，FullGC的触发机制"><a href="#四，FullGC的触发机制" class="headerlink" title="四，FullGC的触发机制"></a>四，FullGC的触发机制</h3><ul><li>1、调用System.gc()时，系统建议执行FullGC，但是不必然执行</li><li>2、老年代空间不足</li><li>3、方法区空间不足</li><li>4、通过MinorGC后进入老年代的平均大小，大于老年代的可用内存</li><li>5、由Eden区，Survivor 0区向Survivor 1区复制时，对象的大小大于ToSpace可用内存，则把改对象转存到老年代，且老年代的可用内存小于该对象的大小</li><li>FullGC是开发或调优中尽量要避免的，这样暂停时间会短一些。</li></ul><h2 id="堆空间分代思想、内存分配策略"><a href="#堆空间分代思想、内存分配策略" class="headerlink" title="堆空间分代思想、内存分配策略"></a>堆空间分代思想、内存分配策略</h2><h3 id="一，堆空间分代思想"><a href="#一，堆空间分代思想" class="headerlink" title="一，堆空间分代思想"></a>一，堆空间分代思想</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700116760-2593405d-ee21-494a-9a58-7519d8d72e08.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uf8d7b78e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=534&originWidth=1143&originalType=url&ratio=1&rotation=0&showTitle=false&size=263007&status=done&style=none&taskId=u1cd52902-79d3-4443-bbdb-9c22dd1eb55&title=" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700116991-edb01ec4-3012-44f2-b774-d2fde449fce5.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u8f1bc4da&margin=%5Bobject%20Object%5D&name=image.png&originHeight=579&originWidth=1065&originalType=url&ratio=1&rotation=0&showTitle=false&size=343299&status=done&style=none&taskId=ua3ab0d47-3974-414c-8314-e30eda739c7&title=" alt="image.png"></p><h3 id="二，内存分配策略"><a href="#二，内存分配策略" class="headerlink" title="二，内存分配策略"></a>二，内存分配策略</h3><ul><li>如果对象再Eden出生并经过第一次MinorGC后仍然存活，并且能被Survivor区容纳，则被移动到Survivor空间中，并将对象年龄设置为1，对象再Survivor区每熬过一次MinorGC，年龄就+1，当年龄增加到一定程度（默认为15，不同Jvm，GC都所有不同）时，就会被晋升到老年代中<ul><li>-XX:MaxTenuringThreshold</li></ul></li><li>优先分配到Eden</li><li>大对象直接分配到老年代<ul><li>尽量避免程序中出现过多的大对象</li></ul></li><li>长期存活的对象分配到老年代</li><li>动态对象年龄分配<ul><li>如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄</li></ul></li></ul><h3 id="三，空间分配担保"><a href="#三，空间分配担保" class="headerlink" title="三，空间分配担保"></a>三，空间分配担保</h3><ul><li>-XX:HandlePromotionFailure</li><li>在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间，是否大于新生代所有对象的总空间<ul><li>如果大于，则此次MinorGC是安全的</li><li>如果小于，则查看-XX:HandlePromotionFailure设置是否允许担保失败<ul><li>true<ul><li>会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小</li><li>大于，则尝试进行一次MinorGC，但是这次MinorGC依然是有风险的</li><li>小于，则改为进行一次FullGC</li></ul></li><li>false<ul><li>则改为进行一次FullGC</li></ul></li></ul></li></ul></li><li>jdk6update24之后，这个参数不会再影响到虚拟机的空间分配担保策略。<ul><li>规则改为只要老年代的连续空间大于新生代对象总大小，或者历次晋升的平均大小，就会进行MinorGC</li><li>否则进行FullGC</li></ul></li></ul><h3 id="四，为对象分配内存：TLAB"><a href="#四，为对象分配内存：TLAB" class="headerlink" title="四，为对象分配内存：TLAB"></a>四，为对象分配内存：TLAB</h3><h4 id="为什么有TLAB（Thread-Local-Allocation-Buffer）？"><a href="#为什么有TLAB（Thread-Local-Allocation-Buffer）？" class="headerlink" title="为什么有TLAB（Thread Local Allocation Buffer）？"></a>为什么有TLAB（Thread Local Allocation Buffer）？</h4><ol><li>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据 </li><li>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的 </li><li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</li></ol><h4 id="什么是TLAB？"><a href="#什么是TLAB？" class="headerlink" title="什么是TLAB？"></a>什么是TLAB？</h4><ol><li>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。 </li><li>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。 </li><li>据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700144566-d6e48744-3803-4e09-8997-7f7f239736ae.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u3592e483&margin=%5Bobject%20Object%5D&name=image.png&originHeight=517&originWidth=903&originalType=url&ratio=1&rotation=0&showTitle=false&size=68242&status=done&style=none&taskId=u7ad1c4aa-8cd6-4c15-aaca-3ada7ffbde6&title=" alt="image.png"></p><h4 id="TLAB的再说明"><a href="#TLAB的再说明" class="headerlink" title="TLAB的再说明"></a>TLAB的再说明</h4><ol><li>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。 </li><li>在程序中，开发人员可以通过选项“-XX:UseTLAB”设置是否开启TLAB空间。 </li><li>默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项 “-XX:TLABWasteTargetPercent” 设置TLAB空间所占用Eden空间的百分比大小。 </li><li>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700144670-59dcfa44-dbd1-40cd-8368-2cf9b42fa0fe.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua6454fb5&margin=%5Bobject%20Object%5D&name=image.png&originHeight=487&originWidth=1048&originalType=url&ratio=1&rotation=0&showTitle=false&size=163864&status=done&style=none&taskId=u9fa9e5f2-2530-45b5-85bf-96748dc053b&title=" alt="image.png"></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>五，小结：堆空间的参数设置<br>官网地址：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html</a><br><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700180501-3c2a7bdf-4090-4cde-8a10-ba1f2e4b65c8.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u3d74fa17&margin=%5Bobject%20Object%5D&name=image.png&originHeight=436&originWidth=978&originalType=url&ratio=1&rotation=0&showTitle=false&size=118140&status=done&style=none&taskId=uee763d54-e553-467e-b06f-f13c5f98775&title=" alt="image.png"></p><ul><li><p>在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。</p></li><li><p>如果大于，则此次Minor GC是安全的</p></li><li><p>如果小于，则虚拟机会查看-XX:HandlePromotionFailure设置值是否允担保失败。 </p><ul><li>如果HandlePromotionFailure&#x3D;true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。 <ul><li>如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；</li><li>如果小于，则改为进行一次Full GC。</li></ul></li><li>如果HandlePromotionFailure&#x3D;false，则改为进行一次Full Gc。</li></ul></li><li><p>在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行FullGC。</p></li></ul><h2 id="堆补充"><a href="#堆补充" class="headerlink" title="堆补充"></a>堆补充</h2><p><strong>堆是分配对象的唯一选择么？</strong></p><ul><li>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</li><li>随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</li><li>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配.。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</li><li>此外，前面提到的基于OpenJDK深度定制的TaoBaoVM，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</li></ul><h3 id="一，逃逸分析概述"><a href="#一，逃逸分析概述" class="headerlink" title="一，逃逸分析概述"></a>一，逃逸分析概述</h3><ul><li><p>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</p></li><li><p>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</p></li><li><p>通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p></li><li><p>逃逸分析的基本行为就是分析对象动态作用域：</p></li><li><p>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</p></li><li><p>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700228524-69b4c439-98a9-460b-98ae-7cfed82d8951.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua1c3121b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1143&originWidth=1026&originalType=url&ratio=1&rotation=0&showTitle=false&size=95391&status=done&style=none&taskId=u3f235879-49e9-433b-8a64-c3fa28f1a31&title=" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700228531-a5cdc677-2e1a-4489-8a7f-f06896cf5455.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uf52d9bad&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1133&originWidth=1022&originalType=url&ratio=1&rotation=0&showTitle=false&size=95471&status=done&style=none&taskId=u0520db81-f79b-4575-b8e1-054858e4f34&title=" alt="image.png"></p><p>参数设置：</p><ul><li><p>在JDK 6u23 版本之后，HotSpot中默认就已经开启了逃逸分析</p></li><li><p>如果使用的是较早的版本，开发人员则可以通过：</p></li><li><p>选项“-XX:+DoEscapeAnalysis”显式开启逃逸分析</p></li><li><p>通过选项“-XX:+PrintEscapeAnalysis”查看逃逸分析的筛选结果</p></li><li><p><strong>结论：开发中能使用局部变量的，就不要使用在方法外定义。</strong></p></li></ul><h3 id="二，逃逸分析代码优化"><a href="#二，逃逸分析代码优化" class="headerlink" title="二，逃逸分析代码优化"></a>二，逃逸分析代码优化</h3><p>使用逃逸分析，编译器可以对代码做如下优化：</p><p>一、<strong>栈上分配</strong>：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</p><p>二、<strong>同步省略</strong>：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</p><p>三、<strong>分离对象或标量替换</strong>：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</p><h4 id="1-栈上分配"><a href="#1-栈上分配" class="headerlink" title="1.栈上分配"></a>1.栈上分配</h4><ul><li><p>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</p></li><li><p><strong>常见的栈上分配的场景：</strong></p><ul><li>在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传递。</li></ul></li></ul><h4 id="2-同步省略"><a href="#2-同步省略" class="headerlink" title="2.同步省略"></a>2.同步省略</h4><ul><li><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</p></li><li><p>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。</p></li><li><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700247509-773030b3-6b48-4879-b915-e5ba44858c0b.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uec37e248&margin=%5Bobject%20Object%5D&name=image.png&originHeight=738&originWidth=1033&originalType=url&ratio=1&rotation=0&showTitle=false&size=60525&status=done&style=none&taskId=u83ee98e5-ffbb-40ce-b461-4e9de022053&title=" alt="image.png"></p></li></ul><h4 id="3-标量替换"><a href="#3-标量替换" class="headerlink" title="3.标量替换"></a>3.标量替换</h4><ul><li><p><strong>标量（scalar）</strong>是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</p></li><li><p>相对的，那些还可以分解的数据叫做<strong>聚合量（Aggregate）</strong>，Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p></li><li><p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700247564-f9b162f3-1e14-4f19-9977-f0a342e2d8f9.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u653b9e42&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1003&originWidth=1042&originalType=url&ratio=1&rotation=0&showTitle=false&size=99794&status=done&style=none&taskId=uaebf011c-a7f7-485b-bed5-0a9f2615e76&title=" alt="image.png"></p><p>标量替换参数设置：</p><p>参数-XX:EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配到栈上。</p><p>上述代码在主函数中进行了1亿次alloc。调用进行对象创建，由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生GC。使用如下参数运行上述代码：<br>-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700247567-c48b0347-53f3-4f63-ab1c-91b696353fe4.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ub1e22248&margin=%5Bobject%20Object%5D&name=image.png&originHeight=377&originWidth=991&originalType=url&ratio=1&rotation=0&showTitle=false&size=83775&status=done&style=none&taskId=ubc526af2-244b-4133-82f7-48d1e5c76a0&title=" alt="image.png"></p><h3 id="三，逃逸分析小结：逃逸分析并不成熟"><a href="#三，逃逸分析小结：逃逸分析并不成熟" class="headerlink" title="三，逃逸分析小结：逃逸分析并不成熟"></a>三，逃逸分析小结：逃逸分析并不成熟</h3><ul><li>关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟。</li><li>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。 </li><li>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</li><li>虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。</li><li>注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，Oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。</li><li>目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。</li></ul><h2 id="⭐方法区"><a href="#⭐方法区" class="headerlink" title="⭐方法区"></a>⭐方法区</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700338333-b5e4f91e-7fd6-4be9-837a-d373e9cdefe8.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u1c58bbbd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=267&originWidth=963&originalType=url&ratio=1&rotation=0&showTitle=false&size=153776&status=done&style=none&taskId=u2b71e328-e6ae-4062-b9f2-d4098714b17&title=" alt="image.png"></p><h3 id="从线程共享与否的角度来看："><a href="#从线程共享与否的角度来看：" class="headerlink" title="从线程共享与否的角度来看："></a>从线程共享与否的角度来看：</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700338383-aec24b40-f04e-4a20-bfca-48d86e56e08d.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uf287de92&margin=%5Bobject%20Object%5D&name=image.png&originHeight=477&originWidth=972&originalType=url&ratio=1&rotation=0&showTitle=false&size=216667&status=done&style=none&taskId=u5147fca9-a6f2-4860-a664-c53c0ee2e4d&title=" alt="image.png"></p><h3 id="栈、堆、方法区的交互关系"><a href="#栈、堆、方法区的交互关系" class="headerlink" title="栈、堆、方法区的交互关系"></a>栈、堆、方法区的交互关系</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700338342-d43f300b-8738-4aac-a725-2f7313e47332.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u6678511d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=600&originWidth=1149&originalType=url&ratio=1&rotation=0&showTitle=false&size=180313&status=done&style=none&taskId=ua6ae8bce-9890-430c-a036-9b0d8618552&title=" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700366346-01164f3d-d87c-4b6f-b128-96d575c7e85f.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u1fb4e940&margin=%5Bobject%20Object%5D&name=image.png&originHeight=353&originWidth=1496&originalType=url&ratio=1&rotation=0&showTitle=false&size=45104&status=done&style=none&taskId=u2b637b31-09fe-4a76-8d4e-bed96955be9&title=" alt="image.png"></p><h2 id="方法区的理解"><a href="#方法区的理解" class="headerlink" title="方法区的理解"></a>方法区的理解</h2><h3 id="一，方法区在哪里？"><a href="#一，方法区在哪里？" class="headerlink" title="一，方法区在哪里？"></a>一，方法区在哪里？</h3><p>《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。</p><p>所以，方法区看作是一块独立于Java堆的内存空间。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700366404-6bdd380e-757f-40cd-bc7f-6c1fe2af155e.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u4bfe390d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=298&originWidth=805&originalType=url&ratio=1&rotation=0&showTitle=false&size=104775&status=done&style=none&taskId=u92b5807a-fde3-440d-ae97-fde32acd694&title=" alt="image.png"></p><h3 id="二，方法区的基本理解"><a href="#二，方法区的基本理解" class="headerlink" title="二，方法区的基本理解"></a>二，方法区的基本理解</h3><ul><li>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。</li><li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</li><li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li><li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：java.lang.OutOfMemoryError: PermGen space 或者java.lang.OutOfMemoryError: Metaspace <ul><li>加载大量的第三方的jar包；Tomcat部署的工程过多（30~50个）；大量动态的生成反射类</li></ul></li><li>关闭JVM就会释放这个区域的内存。</li></ul><h3 id="三，HotSpot中方法区的演进"><a href="#三，HotSpot中方法区的演进" class="headerlink" title="三，HotSpot中方法区的演进"></a>三，HotSpot中方法区的演进</h3><p>在jdk7及以前，习惯上把方法区，称为永久代。jdk8开始，使用元空间取代了永久代。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700366373-0dccdc62-e1b5-4990-9886-f1b68cd0e3f2.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ufdb71da8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=74&originWidth=751&originalType=url&ratio=1&rotation=0&showTitle=false&size=28581&status=done&style=none&taskId=ub81d1a1c-236b-4bff-9eef-cc6eba27fbb&title=" alt="image.png"></p><p>本质上，方法区和永久代并不等价。仅是对hotspot而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEA JRockit &#x2F; IBM J9 中不存在永久代的概念。</p><p>现在来看，当年使用永久代，不是好的idea。导致Java程序更容易OOM（超过-XX:MaxPermsize上限）</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700366472-92d8473f-5d9f-47e2-9513-db4f91b633cd.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ufe9613ab&margin=%5Bobject%20Object%5D&name=image.png&originHeight=617&originWidth=1188&originalType=url&ratio=1&rotation=0&showTitle=false&size=166902&status=done&style=none&taskId=u30e99f18-ebc8-4c7d-80cc-19aa12e6573&title=" alt="image.png"></p><p>而到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700366421-c7c92f21-cff9-4626-840d-0999ce91a50d.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ufbfccdd3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=273&originWidth=800&originalType=url&ratio=1&rotation=0&showTitle=false&size=86516&status=done&style=none&taskId=u33919bf4-9170-434d-b4b5-d5c0679ad33&title=" alt="image.png"></p><p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：<strong>元空间不在虚拟机设置的内存中，而是使用本地内存</strong></p><p>永久代、元空间二者并不只是名字变了，内部结构也调整了</p><p>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常</p><h2 id="设置方法区大小与OOM"><a href="#设置方法区大小与OOM" class="headerlink" title="设置方法区大小与OOM"></a>设置方法区大小与OOM</h2><p>方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。</p><h3 id="jdk7及以前"><a href="#jdk7及以前" class="headerlink" title="jdk7及以前"></a>jdk7及以前</h3><ul><li>通过来设置永久代初始分配空间。默认值是20.75M-XX:Permsize</li><li>通过来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M-XX:MaxPermsize</li><li>当JVM加载的类信息容量超过了这个值，会报异常OutOfMemoryError:PermGen space。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700440997-d3f3978e-cf7c-4216-8f22-cfb4c2c78676.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uc278d647&margin=%5Bobject%20Object%5D&name=image.png&originHeight=244&originWidth=651&originalType=url&ratio=1&rotation=0&showTitle=false&size=82156&status=done&style=none&taskId=u699bc77b-1d54-437c-aa00-645ebc6ae71&title=" alt="image.png"></p><h3 id="JDK8以后"><a href="#JDK8以后" class="headerlink" title="JDK8以后"></a>JDK8以后</h3><ul><li>元数据区大小可以使用参数 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize指定</li><li>默认值依赖于平台。windows下，-XX:MetaspaceSize&#x3D;21M -XX:MaxMetaspaceSize&#x3D;-1&#x2F;&#x2F;即没有限制。</li><li>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace</li><li>-XX:MetaspaceSize：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的-XX:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。</li><li>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值。</li></ul><p>举例1<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700441091-1d3b64bb-7aaf-4721-85a5-fd4a4f9ada55.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u944ac304&margin=%5Bobject%20Object%5D&name=image.png&originHeight=570&originWidth=1144&originalType=url&ratio=1&rotation=0&showTitle=false&size=245957&status=done&style=none&taskId=ubf5e2b60-75db-4182-96ec-46348bfeb1e&title=" alt="image.png"></p><p>举例2<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700441005-06849b1e-f1ea-459c-a0b4-a760b606e07c.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u1792e537&margin=%5Bobject%20Object%5D&name=image.png&originHeight=704&originWidth=932&originalType=url&ratio=1&rotation=0&showTitle=false&size=66479&status=done&style=none&taskId=uc1c9bd0c-5b7f-4f9f-b71e-80e38ec2ce3&title=" alt="image.png"></p><h3 id="如何解决这些OOM"><a href="#如何解决这些OOM" class="headerlink" title="如何解决这些OOM"></a>如何解决这些OOM</h3><ol><li>要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Eclipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow） </li><li>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GCRoots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GCRoots引用链的信息，就可以比较准确地定位出泄漏代码的位置。 </li><li>如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</li></ol><h2 id="方法区内部结构"><a href="#方法区内部结构" class="headerlink" title="方法区内部结构"></a>方法区内部结构</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700513450-2ae650d0-dfe2-4b08-8626-b2447e12c4a6.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uf476128c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=657&originWidth=1144&originalType=url&ratio=1&rotation=0&showTitle=false&size=306652&status=done&style=none&taskId=u7989ed2c-780a-46b9-801f-000d51447fc&title=" alt="image.png"></p><h3 id="一，方法区（Method-Area）存储什么？"><a href="#一，方法区（Method-Area）存储什么？" class="headerlink" title="一，方法区（Method Area）存储什么？"></a>一，方法区（Method Area）存储什么？</h3><p>《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：</p><p>“它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。”</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700513332-0b7a07fd-0e70-4c44-8ca0-85001d1cc729.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uc67e02b6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=191&originWidth=1058&originalType=url&ratio=1&rotation=0&showTitle=false&size=113172&status=done&style=none&taskId=u62ba79d6-bd68-4d33-aea6-8ad4a9b9f32&title=" alt="image.png"></p><h3 id="二，方法区的内部结构"><a href="#二，方法区的内部结构" class="headerlink" title="二，方法区的内部结构"></a>二，方法区的内部结构</h3><h4 id="类型信-息"><a href="#类型信-息" class="headerlink" title="类型信 息"></a>类型信 息</h4><ul><li>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：<ul><li>这个类型的完整有效名称（全名&#x3D;包名.类名）</li><li>这个类型直接父类的完整有效名（对于interface或是java.lang.object，都没有父类）</li><li>这个类型的修饰符（public，abstract，final的某个子集）</li><li>这个类型直接接口的一个有序列表</li></ul></li></ul><h4 id="域（Field）信息"><a href="#域（Field）信息" class="headerlink" title="域（Field）信息"></a>域（Field）信息</h4><ul><li><p>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</p></li><li><p>域的相关信息包括：域名称、域类型、域修饰符（public，private，protected，static，final，volatile，transient的某个子集）</p></li></ul><h4 id="方法（Method）信息"><a href="#方法（Method）信息" class="headerlink" title="方法（Method）信息"></a>方法（Method）信息</h4><ul><li>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：<ul><li>方法名称</li><li>方法的返回类型（或void）</li><li>方法参数的数量和类型（按顺序）</li><li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）</li><li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）</li><li>异常表（abstract和native方法除外） </li><li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li></ul></li></ul><h4 id="non-final的类变量"><a href="#non-final的类变量" class="headerlink" title="non-final的类变量"></a>non-final的类变量</h4><pre><code>  - 静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分  - 类变量被类的所有实例共享，即使没有类实例时，你也可以访问它</code></pre><h4 id="补充说明：全局常量（static-final）"><a href="#补充说明：全局常量（static-final）" class="headerlink" title="补充说明：全局常量（static final）"></a>补充说明：全局常量（static final）</h4><pre><code>  - 被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。</code></pre><h3 id="三，运行时常量池-VS-常量池"><a href="#三，运行时常量池-VS-常量池" class="headerlink" title="三，运行时常量池 VS 常量池"></a>三，运行时常量池 VS 常量池</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700513611-6873c89b-82b4-47dc-ab4d-62150b75eff4.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ubc6948d2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=597&originWidth=1115&originalType=url&ratio=1&rotation=0&showTitle=false&size=516639&status=done&style=none&taskId=ua5c9f60d-2174-4c8c-9b5e-676faac53ce&title=" alt="image.png"></p><ul><li>方法区，内部包含了运行时常量池</li><li>字节码文件，内部包含了常量池</li><li>要弄清楚方法区，需要理解清楚ClassFile，因为加载类的信息都在方法区。</li><li>要弄清楚方法区的运行时常量池，需要理解清楚ClassFile中的常量池。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700513443-55653793-360c-46a2-bfeb-0aee394bd430.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uf5c99de9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=480&originWidth=958&originalType=url&ratio=1&rotation=0&showTitle=false&size=238229&status=done&style=none&taskId=u5409aed6-8343-4821-8a5a-b9c60b45eca&title=" alt="image.png"></p><p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外，还包含一项信息就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用</p><h4 id="为什么需要常量池？"><a href="#为什么需要常量池？" class="headerlink" title="为什么需要常量池？"></a>为什么需要常量池？</h4><p>一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700513346-68f46486-b206-4654-bbcf-0081f8f85517.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ud871e406&margin=%5Bobject%20Object%5D&name=image.png&originHeight=439&originWidth=1006&originalType=url&ratio=1&rotation=0&showTitle=false&size=78218&status=done&style=none&taskId=uc1bdb545-579a-486e-820c-8fc98de1ad4&title=" alt="image.png"></p><h4 id="常量池中有什么"><a href="#常量池中有什么" class="headerlink" title="常量池中有什么?"></a>常量池中有什么?</h4><p>击中常量池内存储的数据类型包括：</p><ul><li>数量值</li><li>字符串值</li><li>类引用</li><li>字段引用</li><li>方法引用</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700514061-6a82d1da-a547-4533-8360-5d8eb80a4c64.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u1f44ba79&margin=%5Bobject%20Object%5D&name=image.png&originHeight=538&originWidth=1018&originalType=url&ratio=1&rotation=0&showTitle=false&size=31853&status=done&style=none&taskId=uc0468192-2440-4f29-8280-abeca6ac7b7&title=" alt="image.png"></p><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>● 运行时常量池（Runtime Constant Pool）是方法区的一部分。<br>● 常量池表（Constant Pool Table）是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。<br>● 运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。<br>● JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。<br>● 运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。<br>● 运行时常量池，相对于Class文件常量池的另一重要特征是：具备动态性。<br>● 运行时常量池类似于传统编程语言中的符号表（symboltable），但是它所包含的数据却比符号表要更加丰富一些。<br>●当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OutOfMemoryError异常。</p><h2 id="方法区使用举例"><a href="#方法区使用举例" class="headerlink" title="方法区使用举例"></a>方法区使用举例</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700755023-e4857fbb-16d1-476e-ab53-8169b01930c8.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u085fa899&margin=%5Bobject%20Object%5D&name=image.png&originHeight=255&originWidth=552&originalType=url&ratio=1&rotation=0&showTitle=false&size=11872&status=done&style=none&taskId=u67b5d20b-4eaf-4f41-b8c2-89f711d9296&title=" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700755146-a4b69713-39d0-4cff-99e9-7560c38a0b4e.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ub24e4119&margin=%5Bobject%20Object%5D&name=image.png&originHeight=632&originWidth=1193&originalType=url&ratio=1&rotation=0&showTitle=false&size=245338&status=done&style=none&taskId=uea0db5ab-1ab1-4690-9867-e05a0f998c1&title=" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700755252-102238ba-4fd2-41d0-9cb6-a7d351fd01d5.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u3547fce8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=615&originWidth=1156&originalType=url&ratio=1&rotation=0&showTitle=false&size=309786&status=done&style=none&taskId=u5e6808a2-6c4a-4374-80db-57b1c6816eb&title=" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700755212-ce8ab711-7bae-4af9-a413-0e713eb7fb74.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ud4f35ef8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=626&originWidth=1187&originalType=url&ratio=1&rotation=0&showTitle=false&size=271950&status=done&style=none&taskId=u8c5e3cfe-93ea-4056-8904-12bd8dc44c4&title=" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700755221-5d73807e-4c5f-4902-964e-69caefe656da.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u418fb7ff&margin=%5Bobject%20Object%5D&name=image.png&originHeight=633&originWidth=1190&originalType=url&ratio=1&rotation=0&showTitle=false&size=294900&status=done&style=none&taskId=u8de45fb1-a8a3-4338-865c-10ba57827da&title=" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700756015-d4136a4e-bcf0-4a72-8a88-dc07fee50687.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u8de9a465&margin=%5Bobject%20Object%5D&name=image.png&originHeight=629&originWidth=1185&originalType=url&ratio=1&rotation=0&showTitle=false&size=273163&status=done&style=none&taskId=ua0d47ae3-9093-4fe6-b78b-370584ab2d6&title=" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700756318-c41d070f-7418-416e-a340-95fc294e4970.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u5da94d1c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=639&originWidth=1197&originalType=url&ratio=1&rotation=0&showTitle=false&size=261378&status=done&style=none&taskId=u61dd10a0-a34b-4732-8f17-bd2b5ccf474&title=" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700756468-411f1b03-8d90-4208-b6f3-c608696fba0b.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9e779eda&margin=%5Bobject%20Object%5D&name=image.png&originHeight=636&originWidth=1196&originalType=url&ratio=1&rotation=0&showTitle=false&size=294241&status=done&style=none&taskId=ub5a29c6a-598c-422e-980c-8d88d545308&title=" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700756677-f49e3b97-97e7-470c-8209-4c90770b964f.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u1e6d833c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=628&originWidth=1192&originalType=url&ratio=1&rotation=0&showTitle=false&size=297390&status=done&style=none&taskId=u129ce437-0ce5-46a0-92d5-fa58a09f903&title=" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700756791-c268a45b-b36a-43c9-a47c-0a1a92337df0.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ub6d02765&margin=%5Bobject%20Object%5D&name=image.png&originHeight=615&originWidth=1162&originalType=url&ratio=1&rotation=0&showTitle=false&size=285499&status=done&style=none&taskId=uc4144ef3-675d-482e-b998-da886b24499&title=" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700757339-9171830b-016b-4fda-85b5-1cb2006ff7c6.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9f7193d3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=627&originWidth=1182&originalType=url&ratio=1&rotation=0&showTitle=false&size=267677&status=done&style=none&taskId=ua4263390-eb0e-47dd-bd74-4c626a27a03&title=" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700758071-292a43c9-6068-43c7-a9fa-b4bc3a0fe443.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ucd342475&margin=%5Bobject%20Object%5D&name=image.png&originHeight=613&originWidth=1158&originalType=url&ratio=1&rotation=0&showTitle=false&size=347513&status=done&style=none&taskId=u6f03b005-99f8-44f9-b2bb-0584ab7dc89&title=" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700758254-3262792a-e413-459f-a102-8f0af5d57bd5.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u5b8ec141&margin=%5Bobject%20Object%5D&name=image.png&originHeight=619&originWidth=1173&originalType=url&ratio=1&rotation=0&showTitle=false&size=265921&status=done&style=none&taskId=u67418e40-91fc-4e82-bf42-a99def2c84a&title=" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700758329-fe1ed8e2-6cce-4830-91b5-2f55ae2567a0.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ue8031870&margin=%5Bobject%20Object%5D&name=image.png&originHeight=623&originWidth=1184&originalType=url&ratio=1&rotation=0&showTitle=false&size=290143&status=done&style=none&taskId=ubef80249-80de-4045-8910-f065ee4e515&title=" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700758538-6aac9bca-4627-4a43-9b68-a91b9e768cda.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u8995a338&margin=%5Bobject%20Object%5D&name=image.png&originHeight=685&originWidth=1290&originalType=url&ratio=1&rotation=0&showTitle=false&size=344488&status=done&style=none&taskId=u248dd826-9d0e-4ee8-a0e7-6e608ce9fcf&title=" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700758853-90b998cb-a11e-433e-852c-e63d4a2a7eb0.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ubbf1cc9d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=690&originWidth=1310&originalType=url&ratio=1&rotation=0&showTitle=false&size=443139&status=done&style=none&taskId=u3cf83831-2142-4d30-9e40-d97e6a85177&title=" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700759641-28355c60-8d0a-4b0d-ae79-8d05df3ec8c5.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uacf598d2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=637&originWidth=1195&originalType=url&ratio=1&rotation=0&showTitle=false&size=297008&status=done&style=none&taskId=u6717e05e-8e1c-4b09-bd9d-370dd96989b&title=" alt="image.png"></p><h2 id="方法区的演进细节"><a href="#方法区的演进细节" class="headerlink" title="方法区的演进细节"></a>方法区的演进细节</h2><ol><li>首先明确：只有Hotspot才有永久代。BEA JRockit、IBMJ9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一</li><li>Hotspot中方法区的变化：</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700774517-b44d7653-694a-4338-851a-5356077c6df8.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uc91cade1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=255&originWidth=998&originalType=url&ratio=1&rotation=0&showTitle=false&size=43914&status=done&style=none&taskId=u95fd093b-74ed-493d-97c0-ef0e13c6f31&title=" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700774626-7b3387f4-5089-450d-b9f5-0a7c8ba60489.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ue5fc641e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=454&originWidth=925&originalType=url&ratio=1&rotation=0&showTitle=false&size=151148&status=done&style=none&taskId=ude7b5773-9d67-4f8a-934c-304acf74d90&title=" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700774637-5968efdc-b089-46d8-85b8-2127d941fd62.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u443f5190&margin=%5Bobject%20Object%5D&name=image.png&originHeight=452&originWidth=916&originalType=url&ratio=1&rotation=0&showTitle=false&size=161826&status=done&style=none&taskId=ufa27a426-457d-47d4-9d30-5323973e14b&title=" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700774692-d754fc0b-1f69-4cdf-86ca-45e4591bff0d.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uacdb79ad&margin=%5Bobject%20Object%5D&name=image.png&originHeight=438&originWidth=1114&originalType=url&ratio=1&rotation=0&showTitle=false&size=244724&status=done&style=none&taskId=u3d36a394-8926-4a84-9dae-115ba3c69a3&title=" alt="image.png"></p><h3 id="一，为什么永久代要被元空间替代？"><a href="#一，为什么永久代要被元空间替代？" class="headerlink" title="一，为什么永久代要被元空间替代？"></a>一，为什么永久代要被元空间替代？</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700774968-ea365f26-60ac-4155-bdbc-01b2a06e0da5.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u1e733a28&margin=%5Bobject%20Object%5D&name=image.png&originHeight=844&originWidth=1272&originalType=url&ratio=1&rotation=0&showTitle=false&size=661460&status=done&style=none&taskId=u277f05ff-0170-4809-a95a-7e5a582c061&title=" alt="image.png"></p><ul><li><p>JRockit是和HotSpot融合后的结果，因为JRockit没有永久代，所以他们不需要配置永久代</p></li><li><p>随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。</p></li><li><p>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。</p></li><li><p>这项改动是很有必要的，原因有：</p></li><li><p>为永久代设置空间大小是很难确定的。在某些场景下，如果动态加载类过多，容易产生Perm区的oom。比如某个实际Web工 程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。 </p></li><li><p>而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，元空间的大小仅受本地内存限制。 </p></li><li><p>对永久代进行调优是很困难的。</p></li></ul><p>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK 11时期的ZGC收集器就不支持类卸载）。 一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏</p><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型</p><h3 id="二，StringTable为什么要调整位置？"><a href="#二，StringTable为什么要调整位置？" class="headerlink" title="二，StringTable为什么要调整位置？"></a>二，StringTable为什么要调整位置？</h3><p>jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才会触发。而full gc是老年代的空间不足、永久代不足时才会触发。</p><p>这就导致StringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p><h3 id="三，静态变量存放在那里？"><a href="#三，静态变量存放在那里？" class="headerlink" title="三，静态变量存放在那里？"></a>三，静态变量存放在那里？</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700775495-109bf95c-2a8e-48ad-87d9-7cbcdc90d378.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uaeabafdf&margin=%5Bobject%20Object%5D&name=image.png&originHeight=2225&originWidth=1051&originalType=url&ratio=1&rotation=0&showTitle=false&size=490242&status=done&style=none&taskId=u8dda91f3-26f9-4b38-9d61-3579d8c7b45&title=" alt="image.png"></p><h2 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h2><ul><li><p>有些人认为方法区（如Hotspot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的zGC收集器就不支持类卸载）。</p></li><li><p>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p></li><li><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</p></li><li><p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p></li><li><p>类和接口的全限定名</p></li><li><p>字段的名称和描述符</p></li><li><p>方法的名称和描述符</p></li><li><p>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p></li><li><p>回收废弃常量与回收Java堆中的对象非常类似。</p></li><li><p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p></li><li><p>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。 </p></li><li><p>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。 </p></li><li><p>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 </p></li><li><p>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class 以及 -XX:+TraceClassLoading、-XX:+TraceClassUnLoading查看类加载和卸载信息</p></li><li><p>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</p></li></ul><h2 id="方法区总结及面试题"><a href="#方法区总结及面试题" class="headerlink" title="方法区总结及面试题"></a>方法区总结及面试题</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700862287-fe4b7315-03ee-42a8-a296-5b6a30a970e6.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ud3b4ebbb&margin=%5Bobject%20Object%5D&name=image.png&originHeight=475&originWidth=1102&originalType=url&ratio=1&rotation=0&showTitle=false&size=236187&status=done&style=none&taskId=u649952ea-fdfe-4ace-8e8d-3b8b625ab09&title=" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700862289-06bcae20-49c6-4b7b-ba48-ac5bef57613f.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u6a45b9be&margin=%5Bobject%20Object%5D&name=image.png&originHeight=534&originWidth=1094&originalType=url&ratio=1&rotation=0&showTitle=false&size=231766&status=done&style=none&taskId=ua631daba-3346-46d5-8d07-d139325dc90&title=" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700862285-6f01df5f-1874-4969-8bcc-004a3cbe2218.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u8acbea39&margin=%5Bobject%20Object%5D&name=image.png&originHeight=523&originWidth=1104&originalType=url&ratio=1&rotation=0&showTitle=false&size=240117&status=done&style=none&taskId=ud18eac66-cde3-4f8c-9c66-f986c484a9f&title=" alt="image.png"></p><h2 id="⭐对象实例化及直接内存"><a href="#⭐对象实例化及直接内存" class="headerlink" title="⭐对象实例化及直接内存"></a>⭐对象实例化及直接内存</h2><h2 id="对象实例化"><a href="#对象实例化" class="headerlink" title="对象实例化"></a>对象实例化</h2><p>面试题：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700895296-b556b290-2f95-4565-8925-dcee2899cd55.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua1f0ffef&margin=%5Bobject%20Object%5D&name=image.png&originHeight=363&originWidth=922&originalType=url&ratio=1&rotation=0&showTitle=false&size=102673&status=done&style=none&taskId=ub705596d-9c33-4abf-83f5-180b502851f&title=" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700895478-c2e564f0-9a6b-47e7-bd4b-19a65bc25482.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u3716cede&margin=%5Bobject%20Object%5D&name=image.png&originHeight=591&originWidth=1110&originalType=url&ratio=1&rotation=0&showTitle=false&size=283595&status=done&style=none&taskId=u0a3af62d-d1ea-4457-9640-4737be048b4&title=" alt="image.png"></p><h3 id="一，创建对象的方式"><a href="#一，创建对象的方式" class="headerlink" title="一，创建对象的方式"></a>一，创建对象的方式</h3><ul><li><p><strong>new：</strong>最常见的方式、Xxx的静态方法，XxxBuilder&#x2F;XxxFactory的静态方法</p></li><li><p><strong>Class的newInstance方法：</strong>反射的方式，只能调用空参的构造器，权限必须是public</p></li><li><p><strong>Constructor的newInstance(XXX)：</strong>反射的方式，可以调用空参、带参的构造器，权限没有要求</p></li><li><p><strong>使用clone()：</strong>不调用任何的构造器，要求当前的类需要实现Cloneable接口，实现clone()</p></li><li><p><strong>使用序列化：</strong>从文件中、从网络中获取一个对象的二进制流</p></li><li><p><strong>第三方库 Objenesis</strong></p></li></ul><h3 id="二，创建对象的步骤"><a href="#二，创建对象的步骤" class="headerlink" title="二，创建对象的步骤"></a>二，创建对象的步骤</h3><p>从执行步骤角度分析：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700895483-ab3a4752-078b-45e4-9562-37416eeeaa07.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ufcb5c68a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=378&originWidth=885&originalType=url&ratio=1&rotation=0&showTitle=false&size=197824&status=done&style=none&taskId=u5e9393b0-94a5-4efd-b7a0-814828ff88f&title=" alt="image.png"></p><h4 id="1-判断对象对应的类是否加载、链接、初始化"><a href="#1-判断对象对应的类是否加载、链接、初始化" class="headerlink" title="1.判断对象对应的类是否加载、链接、初始化"></a>1.判断对象对应的类是否加载、链接、初始化</h4><ul><li><p>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化（即判断类元信息是否存在）。</p></li><li><p>如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的 .class文件；</p></li><li><p>如果没有找到文件，则抛出ClassNotFoundException异常</p></li><li><p>如果找到，则进行类加载，并生成对应的Class对象</p></li></ul><h4 id="2-为对象分配内存"><a href="#2-为对象分配内存" class="headerlink" title="2.为对象分配内存"></a>2.为对象分配内存</h4><ul><li><p>首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小</p></li><li><p><strong>如果内存规整</strong>：虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。</p></li><li><p>意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。</p></li><li><p><strong>如果内存不规整</strong>：虚拟机需要维护一个空闲列表（Free List）来为对象分配内存。</p></li><li><p>已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。意思是虚拟机维护了一个列表，记录上那些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。</p></li><li><p>选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p></li></ul><h4 id="3-处理并发问题"><a href="#3-处理并发问题" class="headerlink" title="3.处理并发问题"></a>3.处理并发问题</h4><ul><li>采用CAS失败重试、区域加锁保证更新的原子性</li><li>每个线程预先分配一块TLAB：通过设置 -XX:+UseTLAB参数来设定</li></ul><h4 id="4-初始化分配到的内存"><a href="#4-初始化分配到的内存" class="headerlink" title="4.初始化分配到的内存"></a>4.初始化分配到的内存</h4><ul><li>所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用</li></ul><h4 id="5-设置对象的对象头"><a href="#5-设置对象的对象头" class="headerlink" title="5.设置对象的对象头"></a>5.设置对象的对象头</h4><ul><li>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</li></ul><h4 id="6-执行init方法进行初始化"><a href="#6-执行init方法进行初始化" class="headerlink" title="6.执行init方法进行初始化"></a>6.执行init方法进行初始化</h4><ul><li><p>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。</p></li><li><p>因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。</p></li></ul><h3 id="给对象属性赋值的操作"><a href="#给对象属性赋值的操作" class="headerlink" title="给对象属性赋值的操作"></a>给对象属性赋值的操作</h3><ul><li>属性的默认初始化</li><li>显式初始化</li><li>代码块中初始化</li><li>构造器中初始化</li></ul><h3 id="对象实例化的过程"><a href="#对象实例化的过程" class="headerlink" title="对象实例化的过程"></a>对象实例化的过程</h3><ul><li>加载类元信息</li><li>为对象分配内存</li><li>处理并发问题</li><li>属性的默认初始化（零值初始化）</li><li>设置对象头信息</li><li>属性的显示初始化、代码块中初始化、构造器中初始化</li></ul><h2 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h2><h3 id="一，对象头（Header）"><a href="#一，对象头（Header）" class="headerlink" title="一，对象头（Header）"></a>一，对象头（Header）</h3><p><strong>对象头包含了两部分，分别是运行时元数据（Mark Word）和类型指针。如果是数组，还需要记录数组的长度</strong></p><ul><li><p>运行时元数据</p></li><li><p>哈希值（HashCode）</p></li><li><p>GC分代年龄</p></li><li><p>锁状态标志</p></li><li><p>线程持有的锁</p></li><li><p>偏向线程ID</p></li><li><p>偏向时间戳</p></li><li><p>类型指针</p></li><li><p>指向类元数据InstanceClass，确定该对象所属的类型。</p></li></ul><h3 id="二，实例数据（Instance-Data）"><a href="#二，实例数据（Instance-Data）" class="headerlink" title="二，实例数据（Instance Data）"></a>二，实例数据（Instance Data）</h3><ul><li><p>它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承下来的和本身拥有的字段）</p></li><li><p>相同宽度的字段总是被分配在一起</p></li><li><p>父类中定义的变量会出现在子类之前</p></li><li><p>如果CompactFields参数为true（默认为true）：子类的窄变量可能插入到父类变量的空隙</p></li></ul><h3 id="三，对齐填充（Padding）"><a href="#三，对齐填充（Padding）" class="headerlink" title="三，对齐填充（Padding）"></a>三，对齐填充（Padding）</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701000227-7d0079c0-1d11-49fb-8c34-9151f7c28700.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u98fee42f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=516&originWidth=954&originalType=url&ratio=1&rotation=0&showTitle=false&size=21394&status=done&style=none&taskId=u439545e5-b231-46c1-8d88-c425785942c&title=" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701000568-bf547880-14c2-48fe-9655-9596f3c2c242.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ubf5e7d5f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=621&originWidth=1188&originalType=url&ratio=1&rotation=0&showTitle=false&size=519643&status=done&style=none&taskId=ue11e42ca-4ca4-471f-af06-b89b299de26&title=" alt="image.png"></p><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701000374-48001c10-c36d-4e0d-9b12-05386d921530.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u4a3ee008&margin=%5Bobject%20Object%5D&name=image.png&originHeight=373&originWidth=1005&originalType=url&ratio=1&rotation=0&showTitle=false&size=224810&status=done&style=none&taskId=u2bf4f85d-09ed-4998-b889-e10f79ab27d&title=" alt="image.png"></p><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701037558-54b61ac4-7493-4c4e-b259-62c3021f6e48.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u86ae31d0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=362&originWidth=1271&originalType=url&ratio=1&rotation=0&showTitle=false&size=190428&status=done&style=none&taskId=ue470a89d-5c85-4ec6-890e-805fe72fe21&title=" alt="image.png"></p><p>JVM是如何通过栈帧中的对象引用访问到其内部的对象实例呢？</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701037529-9b83875d-f338-431e-9d16-23d42fa47bf3.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ud575dfd4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=346&originWidth=631&originalType=url&ratio=1&rotation=0&showTitle=false&size=113186&status=done&style=none&taskId=u2a9916a1-467a-440a-9181-1d08d0c36ba&title=" alt="image.png"></p><h3 id="一，句柄访问"><a href="#一，句柄访问" class="headerlink" title="一，句柄访问"></a>一，句柄访问</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701037660-014072cc-9d9b-4dd3-9c4b-6d55448feeca.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u4e071b06&margin=%5Bobject%20Object%5D&name=image.png&originHeight=661&originWidth=1157&originalType=url&ratio=1&rotation=0&showTitle=false&size=308430&status=done&style=none&taskId=u70f5f218-b31e-4b41-a3d3-672b22f7196&title=" alt="image.png"></p><p>reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改</p><h3 id="二，直接指针（HotSpot采用）"><a href="#二，直接指针（HotSpot采用）" class="headerlink" title="二，直接指针（HotSpot采用）"></a>二，直接指针（HotSpot采用）</h3><p>直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据</p><h2 id="直接内存（Direct-Memory）"><a href="#直接内存（Direct-Memory）" class="headerlink" title="直接内存（Direct Memory）"></a>直接内存（Direct Memory）</h2><h3 id="一，直接内存概述"><a href="#一，直接内存概述" class="headerlink" title="一，直接内存概述"></a>一，直接内存概述</h3><ul><li><p>不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。直接内存是在Java堆外的、直接向系统申请的内存区间。来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存。通常，访问直接内存的速度会优于Java堆，即读写性能高。</p></li><li><p>因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。</p></li><li><p>Java的NIO库允许Java程序使用直接内存，用于数据缓冲区</p></li></ul><h3 id="二，非直接缓存区"><a href="#二，非直接缓存区" class="headerlink" title="二，非直接缓存区"></a>二，非直接缓存区</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701066605-d206e461-d9f7-4f74-8a13-b719776e3ce2.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u6631a346&margin=%5Bobject%20Object%5D&name=image.png&originHeight=547&originWidth=849&originalType=url&ratio=1&rotation=0&showTitle=false&size=131481&status=done&style=none&taskId=ubcc54dcf-4ff1-40c5-a9f1-600f425d33d&title=" alt="image.png"></p><h3 id="三，直接缓存区"><a href="#三，直接缓存区" class="headerlink" title="三，直接缓存区"></a>三，直接缓存区</h3><p>使用NIO时，操作系统划出的直接缓存区可以被java代码直接访问，只有一份。NIO适合对大文件的读写操作。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701066635-4244d859-890f-4f9c-83ea-22d1230f1151.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u1b4bed5d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=584&originWidth=900&originalType=url&ratio=1&rotation=0&showTitle=false&size=172431&status=done&style=none&taskId=u260c4734-bd11-4830-b2c7-98aad0e919d&title=" alt="image.png"></p><p>也可能导致OutOfMemoryError异常<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701066535-3706eaed-decd-4acc-9019-81044c7c0e37.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u8383a6ad&margin=%5Bobject%20Object%5D&name=image.png&originHeight=207&originWidth=1005&originalType=url&ratio=1&rotation=0&showTitle=false&size=20469&status=done&style=none&taskId=u593b81da-c5ff-40cc-b1ea-b45fefec409&title=" alt="image.png"></p><ul><li><p>由于直接内存在Java堆外，因此它的大小不会直接受限于-Xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。</p></li><li><p>分配回收成本较高</p></li><li><p>不受JVM内存回收管理</p></li><li><p>直接内存大小可以通过MaxDirectMemorySize设置。如果不指定，默认与堆的最大值-Xmx参数值一致</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701066715-00e94c2e-bc5d-441d-a8fc-af98a566b7b1.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua35d6aac&margin=%5Bobject%20Object%5D&name=image.png&originHeight=598&originWidth=1082&originalType=url&ratio=1&rotation=0&showTitle=false&size=319601&status=done&style=none&taskId=u7fb172bb-6d20-4ab9-8c4a-b656ce3c784&title=" alt="image.png"></p><h2 id="⭐执行引擎"><a href="#⭐执行引擎" class="headerlink" title="⭐执行引擎"></a>⭐执行引擎</h2><h3 id="一，执行引擎概述"><a href="#一，执行引擎概述" class="headerlink" title="一，执行引擎概述"></a>一，执行引擎概述</h3><p>执行引擎属于JVM的下层，里面包括解释器、及时编译器、垃圾回收器</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701100187-cf4a4554-85dc-42d2-84f7-6c89a0265c32.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ue46a5495&margin=%5Bobject%20Object%5D&name=image.png&originHeight=530&originWidth=857&originalType=url&ratio=1&rotation=0&showTitle=false&size=246665&status=done&style=none&taskId=u6bb0da9a-ed10-46ae-8feb-39d2bd95f59&title=" alt="image.png"></p><p>执行引擎是Java虚拟机核心的组成部分之一。</p><p>“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。</p><p>JVM的主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701100215-a8c05d81-116a-4fe3-932e-2156b2ce0b61.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u94eb4285&margin=%5Bobject%20Object%5D&name=image.png&originHeight=495&originWidth=1038&originalType=url&ratio=1&rotation=0&showTitle=false&size=303866&status=done&style=none&taskId=u2cd7c9ca-3580-4167-900c-3b8302497d6&title=" alt="image.png"></p><p>那么，如果想要让一个Java程序运行起来，执行引擎（Execution Engine）的任务就是将字节码指令解释&#x2F;编译为对应平台上的本地机器指令.才可以。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。</p><h3 id="二，执行引擎的工作流程"><a href="#二，执行引擎的工作流程" class="headerlink" title="二，执行引擎的工作流程"></a>二，执行引擎的工作流程</h3><ol><li>执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器。</li><li>每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。</li><li>当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701100133-69eef82e-6af6-4c6f-8853-e29274eb1a2f.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u26478910&margin=%5Bobject%20Object%5D&name=image.png&originHeight=525&originWidth=612&originalType=url&ratio=1&rotation=0&showTitle=false&size=164335&status=done&style=none&taskId=u52702469-ea12-4ec2-96e9-5abddd379e8&title=" alt="image.png"></p><h2 id="Java代码编译和执行过程"><a href="#Java代码编译和执行过程" class="headerlink" title="Java代码编译和执行过程"></a>Java代码编译和执行过程</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701136666-6a93624c-58fb-430e-b82b-6f9c8db6acd9.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ucfff5d77&margin=%5Bobject%20Object%5D&name=image.png&originHeight=406&originWidth=898&originalType=url&ratio=1&rotation=0&showTitle=false&size=153855&status=done&style=none&taskId=ua8647958-7b18-467f-a1ff-e068ee63dc8&title=" alt="image.png"></p><p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图中的各个步骤</p><p>Java代码编译是由Java源码编译器（前端编译器）来完成，流程图如下所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701136742-653ba9e8-1733-4b5f-8976-4e8084c43f9a.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u5419cb69&margin=%5Bobject%20Object%5D&name=image.png&originHeight=234&originWidth=778&originalType=url&ratio=1&rotation=0&showTitle=false&size=265130&status=done&style=none&taskId=uc5047aee-97e2-4b13-b805-71997d8e861&title=" alt="image.png"></p><p>Java字节码的执行是由JVM执行引擎（后端编译器）来完成，流程图 如下所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701136762-aaa09067-89bd-4417-a63b-08712169e570.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uf14f6ff8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=364&originWidth=840&originalType=url&ratio=1&rotation=0&showTitle=false&size=279649&status=done&style=none&taskId=u66e1f9e6-9e8a-49f6-bdeb-11344024d6b&title=" alt="image.png"></p><h3 id="一，什么是解释器（Interpreter）？什么是JIT编译器？"><a href="#一，什么是解释器（Interpreter）？什么是JIT编译器？" class="headerlink" title="一，什么是解释器（Interpreter）？什么是JIT编译器？"></a>一，什么是解释器（Interpreter）？什么是JIT编译器？</h3><p>解释器：当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p><p>JIT（Just In Time Compiler）编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。</p><h3 id="二，为什么Java是半编译半解释型语言？"><a href="#二，为什么Java是半编译半解释型语言？" class="headerlink" title="二，为什么Java是半编译半解释型语言？"></a>二，为什么Java是半编译半解释型语言？</h3><p>JDK1.0时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701136905-0f8bf0df-209b-4284-b11b-3e71b08e97ff.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u378ee1b3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=607&originWidth=1218&originalType=url&ratio=1&rotation=0&showTitle=false&size=506823&status=done&style=none&taskId=u5c34fac1-ef42-4126-a419-e71f99d185f&title=" alt="image.png"></p><h2 id="机器码、指令、汇编语言"><a href="#机器码、指令、汇编语言" class="headerlink" title="机器码、指令、汇编语言"></a>机器码、指令、汇编语言</h2><h3 id="一，机器码"><a href="#一，机器码" class="headerlink" title="一，机器码"></a>一，机器码</h3><p>各种用二进制编码方式表示的指令，叫做机器指令码。开始，人们就用它采编写程序，这就是机器语言。</p><p>机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。</p><p>用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，执行速度最快。</p><p>机器指令与CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同。</p><h3 id="二，指令"><a href="#二，指令" class="headerlink" title="二，指令"></a>二，指令</h3><p>由于机器码是有0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。</p><p>指令就是把机器码中特定的0和1序列，简化成对应的指令（一般为英文简写，如mov，inc等），可读性稍好</p><p>由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov），对应的机器码也可能不同。</p><h3 id="三，指令集"><a href="#三，指令集" class="headerlink" title="三，指令集"></a>三，指令集</h3><ul><li><p>不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。 如常见的</p></li><li><p>x86指令集，对应的是x86架构的平台</p></li><li><p>ARM指令集，对应的是ARM架构的平台</p></li></ul><h3 id="四，汇编语言"><a href="#四，汇编语言" class="headerlink" title="四，汇编语言"></a>四，汇编语言</h3><p>由于指令的可读性还是太差，于是人们又发明了汇编语言。</p><p>在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用&lt;mark地址符号（Symbol）或标号（Label）代替指令或操作数的地址。在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。</p><p>由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译成机器指令码，计算机才能识别和执行。</p><h3 id="五，高级语言"><a href="#五，高级语言" class="headerlink" title="五，高级语言"></a>五，高级语言</h3><p>为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。高级语言比机器语言、汇编语言更接近人的语言</p><p>当计算机执行高级语言编写的程序时，仍然需要把程序解释和编译成机器的指令码。完成这个过程的程序就叫做解释程序或编译程序。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701175966-e1f41c91-ed5e-4513-9794-98fdd038431d.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u0b53a86b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=476&originWidth=802&originalType=url&ratio=1&rotation=0&showTitle=false&size=80134&status=done&style=none&taskId=u95b76c93-fd1f-43e6-a60f-0fe4f831e64&title=" alt="image.png"></p><p>高级语言也不是直接翻译成机器指令，而是翻译成汇编语言码，如下面说的C和C++</p><h4 id="C、C-源程序执行过程"><a href="#C、C-源程序执行过程" class="headerlink" title="C、C++源程序执行过程"></a>C、C++源程序执行过程</h4><p>编译过程又可以分成两个阶段：编译和汇编。</p><p>编译过程：是读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码</p><p>汇编过程：实际上指把汇编语言代码翻译成目标机器指令的过程。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701174819-c75299ba-7853-4e07-adfd-09a1b746d4f5.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ub2f02240&margin=%5Bobject%20Object%5D&name=image.png&originHeight=492&originWidth=488&originalType=url&ratio=1&rotation=0&showTitle=false&size=295465&status=done&style=none&taskId=u82927b4e-b8ff-48c8-90a9-54ed4b74e1a&title=" alt="image.png"></p><h3 id="六，字节码"><a href="#六，字节码" class="headerlink" title="六，字节码"></a>六，字节码</h3><p>字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码</p><p>字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。</p><p>字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。字节码典型的应用为：Java bytecode</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701174697-1b471cc5-68ec-4f7b-8f18-a775bdfd3048.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u0fcdde28&margin=%5Bobject%20Object%5D&name=image.png&originHeight=322&originWidth=752&originalType=url&ratio=1&rotation=0&showTitle=false&size=81146&status=done&style=none&taskId=u6e61718e-abe8-49e3-b605-c612833a99f&title=" alt="image.png"></p><h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><p>JVM设计者们的初衷仅仅只是单纯地为了满足Java程序实现跨平台特性，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701225296-a8b1f899-0567-4b4e-893b-5c55fcf49aba.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9f690e7b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=352&originWidth=935&originalType=url&ratio=1&rotation=0&showTitle=false&size=127727&status=done&style=none&taskId=ucd02339b-2e90-42ec-8cf3-24c2105211c&title=" alt="image.png"></p><p>为什么Java源文件不直接翻译成JVM，而是翻译成字节码文件？可能是因为直接翻译的代价是比较大的</p><h3 id="一，解释器工作机制"><a href="#一，解释器工作机制" class="headerlink" title="一，解释器工作机制"></a>一，解释器工作机制</h3><p>解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p><p>当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</p><h3 id="二，解释器分类"><a href="#二，解释器分类" class="headerlink" title="二，解释器分类"></a>二，解释器分类</h3><ul><li><p>在Java的发展历史里，一共有两套解释执行器，即古老的字节码解释器、现在普遍使用的模板解释器。</p></li><li><p>字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。</p></li><li><p>而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。</p></li><li><p>在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。</p></li><li><p>Interpreter模块：实现了解释器的核心功能</p></li><li><p>Code模块：用于管理HotSpot VM在运行时生成的本地机器指令</p></li></ul><h3 id="三，现状"><a href="#三，现状" class="headerlink" title="三，现状"></a>三，现状</h3><p>由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Perl、Ruby等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些C&#x2F;C++程序员所调侃。</p><p>为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。</p><p>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</p><h2 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h2><h3 id="一，Java代码的执行分类"><a href="#一，Java代码的执行分类" class="headerlink" title="一，Java代码的执行分类"></a>一，Java代码的执行分类</h3><pre><code>• 第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行 • 第二种是编译执行（直接编译成机器码，但是要知道不同机器上编译的机器码是不一样，而字节码是可以跨平台的）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT，Just In Time）将方法编译成机器码后再执行 </code></pre><p>HotSpot VM是目前市面上高性能虚拟机的代表作之一。它采用解释器与即时编译器并存的架构。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。</p><p>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C&#x2F;C++ 程序一较高下的地步。</p><p>问题来了</p><p>有些开发人员会感觉到诧异，既然HotSpot VM中已经内置JIT编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？比如JRockit VM内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。</p><p>首先明确： 当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。 编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。</p><p>所以： 尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。在此模式下，当Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</p><p>同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”。</p><h3 id="二，HotSpot-JVM执行方式"><a href="#二，HotSpot-JVM执行方式" class="headerlink" title="二，HotSpot JVM执行方式"></a>二，HotSpot JVM执行方式</h3><p>当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。</p><h3 id="三，概念解释"><a href="#三，概念解释" class="headerlink" title="三，概念解释"></a>三，概念解释</h3><p>Java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器（其实叫“编译器的前端”更准确一些）把.java文件转变成.class文件的过程；</p><p>也可能是指虚拟机的后端运行期编译器（JIT编译器，Just In Time Compiler）把字节码转变成机器码的过程。</p><p>还可能是指使用静态提前编译器（AOT编译器，Ahead of Time Compiler）直接把.java文件编译成本地机器代码的过程。</p><pre><code>• 前端编译器：Sun的Javac、Eclipse JDT中的增量式编译器（ECJ）。 • JIT编译器：HotSpot VM的C1、C2编译器。 • AOT 编译器：GNU Compiler for the Java（GCJ）、Excelsior JET。 </code></pre><h3 id="四，热点代码及探测技术"><a href="#四，热点代码及探测技术" class="headerlink" title="四，热点代码及探测技术"></a>四，热点代码及探测技术</h3><p>当然是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被调用执行的频率而定。关于那些需要被编译为本地代码的字节码，也被称之为“热点代码”，JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出深度优化，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能。</p><p>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此被称之为栈上替换，或简称为OSR（On Stack Replacement）编译。</p><p>一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能。</p><p>目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测。</p><p>采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。</p><pre><code>• 方法调用计数器用于统计方法的调用次数• 回边计数器则用于统计循环体执行的循环次数</code></pre><h4 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a>方法调用计数器</h4><p>这个计数器就用于统计方法被调用的次数，它的默认阀值在Client模式下是1500次，在Server模式下是10000次。超过这个阈值，就会触发JIT编译。</p><p>这个阀值可以通过虚拟机参数 -XX:CompileThreshold来人为设定。</p><p>当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阀值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</p><h4 id="热点衰减"><a href="#热点衰减" class="headerlink" title="热点衰减"></a>热点衰减</h4><p>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期（Counter Half Life Time）</p><p>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 -XX:-UseCounterDecay 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</p><p>另外，可以使用-XX:CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。</p><h4 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h4><p>它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发OSR编译。</p><h3 id="五，HotSpotVM-可以设置程序执行方法"><a href="#五，HotSpotVM-可以设置程序执行方法" class="headerlink" title="五，HotSpotVM 可以设置程序执行方法"></a>五，HotSpotVM 可以设置程序执行方法</h3><p>缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：</p><pre><code>• -Xint：完全采用解释器模式执行程序；• -Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行• -Xmixed：采用解释器+即时编译器的混合模式共同执行程序。</code></pre><h3 id="六，HotSpotVM中-JIT-分类"><a href="#六，HotSpotVM中-JIT-分类" class="headerlink" title="六，HotSpotVM中 JIT 分类"></a>六，HotSpotVM中 JIT 分类</h3><p>JIT的编译器还分为了两种，分别是C1和C2，在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server Compiler，但大多数情况下我们简称为C1编译器 和 C2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：</p><pre><code>• -client：指定Java虚拟机运行在Client模式下，并使用C1编译器；C1编译器会对字节码进行简单和可靠的优化，耗时短，以达到更快的编译速度。• -server：指定Java虚拟机运行在server模式下，并使用C2编译器。C2进行耗时较长的优化，以及激进优化，但优化的代码执行效率更高。</code></pre><p>分层编译（Tiered Compilation）策略：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。</p><p>不过在Java7版本之后，一旦开发人员在程序中显式指定命令“-server”时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务。</p><p>C1 和 C2编译器不同的优化策略</p><p>在不同的编译器上有不同的优化策略，C1编译器上主要有方法内联、去虚拟化、冗余消除。</p><pre><code>• 方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程• 去虚拟化：对唯一的实现类进行内联• 冗余消除：在运行期间把一些不会执行的代码折叠掉</code></pre><p>C2的优化主要是在全局层面，逃逸分析（前面讲过，并不成熟）是优化的基础。基于逃逸分析在C2上有如下几种优化：</p><pre><code>• 标量替换：用标量值代替聚合对象的属性值• 栈上分配：对于未逃逸的对象分配对象在栈而不是堆• 同步消除：清除同步操作，通常指synchronized</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一般来讲，JIT编译出来的机器码性能比解释器高。C2编译器启动时长比C1慢，系统稳定执行以后，C2编译器执行速度远快于C1编译器</p><h3 id="写到最后1"><a href="#写到最后1" class="headerlink" title="写到最后1"></a>写到最后1</h3><ul><li>自JDK10起，HotSpot又加入了一个全新的及时编译器：Graal编译器</li><li>编译效果短短几年时间就追评了C2编译器，未来可期</li><li>目前，带着实验状态标签，需要使用开关参数-XX:+UnlockExperimentalvMOptions -XX:+UseJVMCICompiler去激活才能使用</li></ul><h3 id="写到最后2：AOT编译器"><a href="#写到最后2：AOT编译器" class="headerlink" title="写到最后2：AOT编译器"></a>写到最后2：AOT编译器</h3><p>jdk9引入了AOT编译器（静态提前编译器，Ahead of Time Compiler）</p><p>Java 9引入了实验性AOT编译工具jaotc。它借助了Graal编译器，将所输入的Java类文件转换为机器码，并存放至生成的动态共享库之中。</p><p>所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。</p><p>最大的好处：Java虚拟机加载已经预编译成二进制库，可以直接执行。不必等待及时编译器的预热，减少Java应用给人带来“第一次运行慢” 的不良体验</p><p>缺点：</p><ul><li>破坏了 java “ 一次编译，到处运行”的理念，必须为每个不同的硬件，OS编译对应的发行包</li><li>降低了Java链接过程的动态性，加载的代码在编译器就必须全部已知。</li><li>还需要继续优化中，最初只支持Linux X64 java base</li></ul><h1 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h1><p><strong>一， String的基本特性</strong></p><ul><li>String：字符串，使用一对””引起来表示</li><li>String声明为final的，不可被继承</li><li>String实现了Serializable接口：表示字符串是支持序列化的。</li><li>String实现了Comparable接口：表示string可以比较大小</li><li>String在jdk8及以前内部定义了final char[] value用于存储字符串数据。JDK9时改为byte[]</li></ul><p><strong>二，String在jdk9中存储结构变更</strong></p><p>官网地址：JEP 254: Compact Strings (java.net)</p><ul><li><p><strong>动机</strong></p></li><li><p>目前String类的实现将字符存储在一个char数组中，每个字符使用两个字节（16位）。从许多不同的应用中收集到的数据表明，字符串是堆使用的主要组成部分，此外，大多数字符串对象只包含Latin-1字符。这些字符只需要一个字节的存储空间，因此这些字符串对象的内部字符数组中有一半的空间没有被使用。</p></li><li><p><strong>说明</strong></p></li><li><p>我们建议将String类的内部表示方法从UTF-16字符数组改为字节数组加编码标志域。新的String类将根据字符串的内容，以ISO-8859-1&#x2F;Latin-1（每个字符一个字节）或UTF-16（每个字符两个字节）的方式存储字符编码。编码标志将表明使用的是哪种编码。</p></li><li><p>与字符串相关的类，如AbstractStringBuilder、StringBuilder和StringBuffer将被更新以使用相同的表示方法，HotSpot VM的内在字符串操作也是如此。</p></li><li><p>这纯粹是一个实现上的变化，对现有的公共接口没有变化。目前没有计划增加任何新的公共API或其他接口。</p></li><li><p>迄今为止所做的原型设计工作证实了内存占用的预期减少，GC活动的大幅减少，以及在某些角落情况下的轻微性能倒退。</p></li><li><p>结论：String再也不用char[] 来存储了，改成了byte [] 加上编码标记，节约了一些空间</p></li></ul><p><strong>三，String的基本特性</strong></p><ul><li><p>String：代表不可变的字符序列。简称：不可变性。</p></li><li><p>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</p></li><li><p>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</p></li><li><p>当调用string的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</p></li><li><p>通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</p></li><li><p>字符串常量池是不会存储相同内容的字符串的</p></li><li><p>String的String Pool是一个固定大小的Hashtable，默认值大小长度是1009。如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern时性能会大幅下降。</p></li><li><p>使用-XX:StringTablesize可设置StringTable的长度</p><ul><li>在jdk6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。StringTablesize设置没有要求 </li><li>在jdk7中，StringTable的长度默认值是60013，StringTablesize设置没有要求 </li><li>在JDK8中，设置StringTable长度的话，1009是可以设置的最小值</li></ul></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701368685-63012c27-1b8c-46f1-be13-6e14f764223e.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u6854193f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=604&originWidth=759&originalType=url&ratio=1&rotation=0&showTitle=false&size=247316&status=done&style=none&taskId=u7d079eea-8294-4cb0-be41-b98167780f5&title=" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701368613-99c8ff09-733b-4291-97a9-20a880a8e1f5.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u221a9300&margin=%5Bobject%20Object%5D&name=image.png&originHeight=781&originWidth=1435&originalType=url&ratio=1&rotation=0&showTitle=false&size=109326&status=done&style=none&taskId=u16d7f0ae-f458-4ff0-a39b-552b31cdf7e&title=" alt="image.png"></p><h2 id="String的内存分配"><a href="#String的内存分配" class="headerlink" title="String的内存分配"></a>String的内存分配</h2><ul><li><p>在Java语言中有8种基本数据类型和一种比较特殊的类型String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。</p></li><li><p>常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，String类型的常量池比较特殊。它的主要使用方法有两种。</p></li><li><p>直接使用双引号声明出来的String对象会直接存储在常量池中。 </p></li><li><p>如果不是用双引号声明的String对象，可以使用String提供的intern()方法。这个后面重点谈 </p></li><li><p>Java 6及以前，字符串常量池存放在永久代</p></li><li><p>Java 7中 Oracle的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到Java堆内</p></li><li><p>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。 </p></li><li><p>字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java 7中使用String.intern()。 </p></li><li><p>Java8元空间，字符串常量在堆</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701413407-a8010168-8212-4cd7-8e13-d5c9f242bbe7.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u3b092e8e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=432&originWidth=891&originalType=url&ratio=1&rotation=0&showTitle=false&size=96538&status=done&style=none&taskId=u1579ad67-ae74-4957-9488-6114be1b783&title=" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701413420-70e523b2-6712-44d1-ab44-9079193e2698.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u4b720dc8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=425&originWidth=864&originalType=url&ratio=1&rotation=0&showTitle=false&size=83929&status=done&style=none&taskId=u4f98d0b6-bc72-4da5-91b7-90b102b1e86&title=" alt="image.png"></p><h3 id="StringTable为什么要调整？"><a href="#StringTable为什么要调整？" class="headerlink" title="StringTable为什么要调整？"></a>StringTable为什么要调整？</h3><p>官网地址：<a href="https://www.oracle.com/java/technologies/javase/jdk7-relnotes.html#jdk7changes">Java SE 7 Features and Enhancements (oracle.com)</a></p><p>简介：在JDK 7中，内部字符串不再分配在Java堆的永久代中，而是分配在Java堆的主要部分（称为年轻代和老年代），与应用程序创建的其他对象一起。这种变化将导致更多的数据驻留在主Java堆中，而更少的数据在永久代中，因此可能需要调整堆的大小。大多数应用程序将看到由于这一变化而导致的堆使用的相对较小的差异，但加载许多类或大量使用String.intern()方法的大型应用程序将看到更明显的差异。</p><h2 id="String的基本操作"><a href="#String的基本操作" class="headerlink" title="String的基本操作"></a>String的基本操作</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701444022-df3e1534-711b-48a3-b02a-9632f64c7536.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u2ac1ccf3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=718&originWidth=491&originalType=url&ratio=1&rotation=0&showTitle=false&size=67826&status=done&style=none&taskId=u0f79bf1b-3c9d-4fb0-b904-bad04b9b709&title=" alt="image.png"></p><p>Java语言规范里要求完全相同的字符串字面量，应该包含同样的Unicode字符序列（包含同一份码点序列的常量），并且必须是指向同一个String类实例。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701443999-a4cbf460-2083-4c7a-91bf-e8708c76bb73.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u7dcbdd34&margin=%5Bobject%20Object%5D&name=image.png&originHeight=383&originWidth=1004&originalType=url&ratio=1&rotation=0&showTitle=false&size=27857&status=done&style=none&taskId=udd93a7e1-d982-4dbb-a6b7-49046c21f22&title=" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701444081-03bd9ff8-c586-470a-a163-0b0d3fd605ea.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u4ec3f506&margin=%5Bobject%20Object%5D&name=image.png&originHeight=492&originWidth=1134&originalType=url&ratio=1&rotation=0&showTitle=false&size=160657&status=done&style=none&taskId=uebbbb82b-3ad2-492e-b5a9-34bc9f0ef3c&title=" alt="image.png"></p><h2 id="字符串拼接操作"><a href="#字符串拼接操作" class="headerlink" title="字符串拼接操作"></a>字符串拼接操作</h2><ul><li>常量与常量的拼接结果在常量池，原理是编译期优化</li><li>常量池中不会存在相同内容的变量</li><li>只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder</li><li>如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址</li></ul><p>例子1：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701471308-a0bec55d-bcf0-49f7-9924-dabe3ae14ff2.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u388e145c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=311&originWidth=998&originalType=url&ratio=1&rotation=0&showTitle=false&size=40026&status=done&style=none&taskId=u39b28164-22d2-4e53-9f75-fc19b2af925&title=" alt="image.png"></p><p>例子2：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701471366-8b407a39-72c1-47cb-9b42-8726665e1dcb.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u3bcee9de&margin=%5Bobject%20Object%5D&name=image.png&originHeight=621&originWidth=1002&originalType=url&ratio=1&rotation=0&showTitle=false&size=86841&status=done&style=none&taskId=u67291a28-d43c-445d-9b31-6218c710dd5&title=" alt="image.png"></p><p>例子3：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701471317-20920841-ee98-4d96-9a5f-5b7f9342cd8d.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=udb2e56cc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=395&originWidth=997&originalType=url&ratio=1&rotation=0&showTitle=false&size=40575&status=done&style=none&taskId=u96b9bb16-6618-4aef-a00f-d961b5815f9&title=" alt="image.png"></p><ul><li>不使用final修饰，即为变量。如s3行的s1和s2，会通过new StringBuilder进行拼接</li><li>使用final修饰，即为常量。会在编译器进行代码优化。在实际开发中，能够使用final的，尽量使用</li></ul><p>例子4：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701471438-98907e47-3493-48e1-8d20-e5ea120a1b99.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u815e3d43&margin=%5Bobject%20Object%5D&name=image.png&originHeight=259&originWidth=997&originalType=url&ratio=1&rotation=0&showTitle=false&size=13185&status=done&style=none&taskId=u42bc880e-bea0-481d-887d-3f81e4bf5c4&title=" alt="image.png"></p><h3 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h3><p>我们拿例4的字节码进行查看，可以发现s1 + s2实际上是new了一个StringBuilder对象，并使用了append方法将s1和s2添加进来，最后调用了toString方法赋给s4</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701471359-82cd63c3-c9d6-4023-9a34-c01623354d10.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ub2380c98&margin=%5Bobject%20Object%5D&name=image.png&originHeight=703&originWidth=996&originalType=url&ratio=1&rotation=0&showTitle=false&size=50915&status=done&style=none&taskId=u93214db8-a4c0-466c-a029-8a271f890bf&title=" alt="image.png"></p><h3 id="字符串拼接操作性能对比"><a href="#字符串拼接操作性能对比" class="headerlink" title="字符串拼接操作性能对比"></a>字符串拼接操作性能对比</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701472316-7718b7d2-1116-49d0-bcf3-6f350671079a.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u6d690c18&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1382&originWidth=999&originalType=url&ratio=1&rotation=0&showTitle=false&size=80897&status=done&style=none&taskId=u563f4977-7833-4497-bdae-df3d88ede34&title=" alt="image.png"></p><ul><li><p>本实验进行5万次循环，String拼接方式的时间是StringBuilder.append方式的约8000倍，StringBuffer.append()方式的时间是StringBuilder.append()方式的约4倍</p></li><li><p>可以看到，通过StringBuilder的append方式的速度，要比直接对String使用“+”拼接的方式快的不是一点半点</p></li><li><p>那么，在实际开发中，对于需要多次或大量拼接的操作，在不考虑线程安全问题时，我们就应该尽可能使用StringBuilder进行append操作</p></li><li><p>除此之外，还有那些操作能够帮助我们提高字符串方面的运行效率呢？</p></li><li><p>StringBuilder空参构造器的初始化大小为16。那么，如果提前知道需要拼接String的个数，就应该直接使用带参构造器指定capacity，以减少扩容的次数（扩容的逻辑可以自行查看源代码）</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701472366-fb839f20-8ebc-4354-9802-6565627891c5.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uca17c5e4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=572&originWidth=997&originalType=url&ratio=1&rotation=0&showTitle=false&size=37865&status=done&style=none&taskId=uc30c04c7-e698-4a12-bc8c-294bb8c18bf&title=" alt="image.png"></p><h3 id="intern-的使用"><a href="#intern-的使用" class="headerlink" title="intern()的使用"></a>intern()的使用</h3><p>当调用intern方法时，如果池子里已经包含了一个与这个String对象相等的字符串，正如equals(Object)方法所确定的，那么池子里的字符串会被返回。否则，这个String对象被添加到池中，并返回这个String对象的引用。</p><p>由此可见，对于任何两个字符串s和t，当且仅当s.equals(t)为真时，s.intern() &#x3D;&#x3D; t.intern()为真。</p><p>所有字面字符串和以字符串为值的常量表达式都是interned。</p><p>返回一个与此字符串内容相同的字符串，但保证是来自一个唯一的字符串池。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701549929-3447e97a-de0d-47bc-91a4-eb29dec725da.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u5b6e8295&margin=%5Bobject%20Object%5D&name=image.png&originHeight=441&originWidth=1065&originalType=url&ratio=1&rotation=0&showTitle=false&size=372365&status=done&style=none&taskId=uff4de93e-1c51-445e-a351-0f5f8556efa&title=" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701549753-2c07e298-bc11-48e3-87df-f686dff7e5b7.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u56fa143b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=336&originWidth=1063&originalType=url&ratio=1&rotation=0&showTitle=false&size=78953&status=done&style=none&taskId=uc251ea97-e3b7-4d33-9a87-2ca0303d46e&title=" alt="image.png"></p><h3 id="一，intern的使用：JDK6-vs-JDK7-x2F-8"><a href="#一，intern的使用：JDK6-vs-JDK7-x2F-8" class="headerlink" title="一，intern的使用：JDK6 vs JDK7&#x2F;8"></a>一，intern的使用：JDK6 vs JDK7&#x2F;8</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701549774-4872e035-76e0-4083-aaec-da6aab057ad7.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u1a322953&margin=%5Bobject%20Object%5D&name=image.png&originHeight=809&originWidth=1022&originalType=url&ratio=1&rotation=0&showTitle=false&size=86389&status=done&style=none&taskId=ue82e57e8-33ba-4bc2-bf74-d676f702923&title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701549828-29681724-87eb-416d-ad16-c75d4b2d800d.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u6c4fe5e6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=610&originWidth=1026&originalType=url&ratio=1&rotation=0&showTitle=false&size=191915&status=done&style=none&taskId=uaca7f057-2113-4c08-8e21-4d3803574fa&title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701549839-469e302c-e693-4e02-a39e-e0df4a733a2b.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u3c94d63b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=469&originWidth=1097&originalType=url&ratio=1&rotation=0&showTitle=false&size=205898&status=done&style=none&taskId=u4e48b0da-3106-4a15-998d-b95fe0d3d94&title=" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701550646-d6283d7d-21c4-4091-b91f-ebcb8ae833ba.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ue0431826&margin=%5Bobject%20Object%5D&name=image.png&originHeight=395&originWidth=822&originalType=url&ratio=1&rotation=0&showTitle=false&size=40861&status=done&style=none&taskId=u79350454-1da4-4f6a-9af7-e22263fd036&title=" alt="image.png"></p><p><strong>练习1：</strong></p><p>JDK6：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701550860-764166fa-57e6-453e-bfe8-9763eaa1eae8.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u035d81b7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=576&originWidth=1105&originalType=url&ratio=1&rotation=0&showTitle=false&size=215543&status=done&style=none&taskId=uc54f47c4-82a6-4c87-b837-df5b879e1c6&title=" alt="image.png"></p><p>JDK7：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701550928-17ee4db2-31c0-4b49-817e-dc4aa1ec14df.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u808d7d21&margin=%5Bobject%20Object%5D&name=image.png&originHeight=562&originWidth=1074&originalType=url&ratio=1&rotation=0&showTitle=false&size=212133&status=done&style=none&taskId=u9a792c26-e5b5-4d1b-a5c8-07768e48753&title=" alt="image.png"></p><p><strong>练习2：</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701551179-b3a1f0ec-4124-4517-9715-ff083ec05747.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ud2573815&margin=%5Bobject%20Object%5D&name=image.png&originHeight=592&originWidth=1122&originalType=url&ratio=1&rotation=0&showTitle=false&size=240101&status=done&style=none&taskId=u352a1542-fc94-46ad-bfe4-b7b067a040c&title=" alt="image.png"></p><h3 id="二，intern的效率测试：空间角度"><a href="#二，intern的效率测试：空间角度" class="headerlink" title="二，intern的效率测试：空间角度"></a>二，intern的效率测试：空间角度</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701551279-6587d8b9-bead-4292-bdaf-d61104b703ad.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u957530c3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1000&originWidth=1050&originalType=url&ratio=1&rotation=0&showTitle=false&size=77653&status=done&style=none&taskId=uf3d5b6a5-93ee-46e5-8816-2cd27b22d5c&title=" alt="image.png"></p><h3 id="三，StringTable的垃圾回收"><a href="#三，StringTable的垃圾回收" class="headerlink" title="三，StringTable的垃圾回收"></a>三，StringTable的垃圾回收</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701551764-e6e102c4-5d5a-4d30-9e47-57f799327eca.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u7ec679fa&margin=%5Bobject%20Object%5D&name=image.png&originHeight=884&originWidth=1049&originalType=url&ratio=1&rotation=0&showTitle=false&size=73566&status=done&style=none&taskId=u87b07ceb-c93b-4e40-a1ce-5ff686c8f80&title=" alt="image.png"></p><h3 id="四：G1中的String去重操作"><a href="#四：G1中的String去重操作" class="headerlink" title="四：G1中的String去重操作"></a>四：G1中的String去重操作</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701552694-1ec23dc3-0abe-4bae-8d5f-e4c0100c5038.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uff4b7329&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1877&originWidth=1051&originalType=url&ratio=1&rotation=0&showTitle=false&size=249019&status=done&style=none&taskId=ub0956120-3379-4062-8cca-7685c493d17&title=" alt="image.png"></p><h1 id="垃圾回收概述及算法"><a href="#垃圾回收概述及算法" class="headerlink" title="垃圾回收概述及算法"></a>垃圾回收概述及算法</h1><h2 id="垃圾回收概述"><a href="#垃圾回收概述" class="headerlink" title="垃圾回收概述"></a>垃圾回收概述</h2><h3 id="一，垃圾回收概述"><a href="#一，垃圾回收概述" class="headerlink" title="一，垃圾回收概述"></a>一，垃圾回收概述</h3><h4 id="1，什么是垃圾？"><a href="#1，什么是垃圾？" class="headerlink" title="1，什么是垃圾？"></a>1，什么是垃圾？</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701641712-936948e5-4424-4777-88c1-ae89272bca1a.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u848a5cb0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=450&originWidth=478&originalType=url&ratio=1&rotation=0&showTitle=false&size=35433&status=done&style=none&taskId=u538b96c3-22fe-4023-8b9d-1d9875ad440&title=" alt="image.png"></p><ul><li><p>垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。</p></li><li><p>关于垃圾收集有三个经典问题：</p></li><li><p>哪些内存需要回收？</p></li><li><p>什么时候回收？</p></li><li><p>如何回收？</p></li><li><p>垃圾收集机制是Java的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。</p></li></ul><h4 id="2，大厂面试题"><a href="#2，大厂面试题" class="headerlink" title="2，大厂面试题"></a>2，大厂面试题</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701641756-910ee23d-3d9d-4154-a35d-4fb4fb5c744c.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uee540be5&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1472&originWidth=1010&originalType=url&ratio=1&rotation=0&showTitle=false&size=90313&status=done&style=none&taskId=uf4b4fbbc-64f3-4407-a0c1-6ceccfc3258&title=" alt="image.png"></p><h4 id="3，什么是垃圾？"><a href="#3，什么是垃圾？" class="headerlink" title="3，什么是垃圾？"></a>3，什么是垃圾？</h4><p>An object is considered garbage when it can no longer be reached from any pointer in the running program</p><p>垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。</p><p>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序的结束，被保留的空间无法被其它对象使用，甚至可能导致内存溢出。</p><h4 id="4，为什么需要GC"><a href="#4，为什么需要GC" class="headerlink" title="4，为什么需要GC"></a>4，为什么需要GC</h4><p><strong>想要学习GC，首先需要理解为什么需要GC？</strong></p><p>对于高级语言来说，一个基本认知是如果不进行垃圾回收，内存迟早都会被消耗完，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。</p><p>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便JVM将整理出的内存分配给新的对象。</p><p>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序的正常进行。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</p><h4 id="5，早期垃圾回收"><a href="#5，早期垃圾回收" class="headerlink" title="5，早期垃圾回收"></a>5，早期垃圾回收</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701641751-40b0d952-e2d0-435c-991a-dbf27068fade.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u776cf894&margin=%5Bobject%20Object%5D&name=image.png&originHeight=823&originWidth=1079&originalType=url&ratio=1&rotation=0&showTitle=false&size=82748&status=done&style=none&taskId=u6622ea75-be12-44f5-be1e-5c23748f635&title=" alt="image.png"></p><h4 id="6，Java垃圾回收机制"><a href="#6，Java垃圾回收机制" class="headerlink" title="6，Java垃圾回收机制"></a>6，Java垃圾回收机制</h4><ul><li><p>自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险</p><ul><li>没有垃圾回收器，java也会和cpp一样，各种悬垂指针，野指针，泄露问题让你头疼不已。</li></ul></li><li><p>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发</p></li><li><p>oracle官网关于垃圾回收的介绍 <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html</a></p></li><li><p><strong>担忧</strong></p></li><li><p>对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力。</p></li><li><p>此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见outofMemoryError时，快速地根据错误异常日志定位问题和解决问题。</p></li><li><p>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节。</p></li></ul><h5 id="GC主要关注的区域"><a href="#GC主要关注的区域" class="headerlink" title="GC主要关注的区域"></a>GC主要关注的区域</h5><ul><li>GC主要关注于 方法区 和堆中的垃圾收集</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701641810-e52760fa-96b7-4201-8162-f7508fc84991.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u32928307&margin=%5Bobject%20Object%5D&name=image.png&originHeight=476&originWidth=681&originalType=url&ratio=1&rotation=0&showTitle=false&size=159753&status=done&style=none&taskId=u31c92e36-f289-4dcd-9462-ded8bf73212&title=" alt="image.png"></p><ul><li><p>垃圾收集器可以对年轻代回收，也可以对老年代回收，甚至是全栈和方法区的回收。其中，Java堆是垃圾收集器的工作重点</p></li><li><p>从次数上讲：</p></li><li><p>频繁收集Young区</p></li><li><p>较少收集Old区</p></li><li><p>基本不收集Perm区（元空间）</p></li></ul><h2 id="垃圾回收相关算法——标记阶段"><a href="#垃圾回收相关算法——标记阶段" class="headerlink" title="垃圾回收相关算法——标记阶段"></a>垃圾回收相关算法——标记阶段</h2><h3 id="对象存活判断"><a href="#对象存活判断" class="headerlink" title="对象存活判断"></a>对象存活判断</h3><p>在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为垃圾标记阶段。</p><p>那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</p><p>判断对象存活一般有两种方式：引用计数算法和可达性分析算法。</p><h3 id="一，-标记阶段"><a href="#一，-标记阶段" class="headerlink" title="一， 标记阶段"></a>一， 标记阶段</h3><h4 id="方式一：引用计数算法"><a href="#方式一：引用计数算法" class="headerlink" title="方式一：引用计数算法"></a>方式一：引用计数算法</h4><p>引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。</p><p>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</p><p>优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</p><p>缺点：</p><ul><li>它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。</li><li>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。</li><li>引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。</li></ul><h5 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h5><p>当p的指针断开的时候，内部的引用形成一个循环，这就是循环引用</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701787244-19d75e80-d026-40fe-a9c4-c5a13fa46057.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9d743124&margin=%5Bobject%20Object%5D&name=image.png&originHeight=516&originWidth=942&originalType=url&ratio=1&rotation=0&showTitle=false&size=107150&status=done&style=none&taskId=u69cd7a85-b23f-4c17-9059-b34fb7aaa2e&title=" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701787371-706bf3b1-88aa-4fe6-84fa-7c399f277dd5.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u2c2fd1ba&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1432&originWidth=1071&originalType=url&ratio=1&rotation=0&showTitle=false&size=268782&status=done&style=none&taskId=u9335147d-6dd1-453d-a2a8-74e7e986b9a&title=" alt="image.png"></p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制。</p><p>具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。</p><p>Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。</p><p>Python如何解决循环引用？</p><ul><li>手动解除：很好理解，就是在合适的时机，解除引用关系。 使用弱引用weakref，weakref是Python提供的标准库，旨在解决循环引用。</li></ul><h4 id="方式二：可达性分析算法"><a href="#方式二：可达性分析算法" class="headerlink" title="方式二：可达性分析算法"></a>方式二：可达性分析算法</h4><h5 id="可达性分析算法（根搜索算法、追踪性垃圾收集）"><a href="#可达性分析算法（根搜索算法、追踪性垃圾收集）" class="headerlink" title="可达性分析算法（根搜索算法、追踪性垃圾收集）"></a>可达性分析算法（根搜索算法、追踪性垃圾收集）</h5><p>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。</p><p>相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫作追踪性垃圾收集（Tracing Garbage Collection）</p><p>所谓”GCRoots”根集合就是一组必须活跃的引用。</p><h5 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h5><ul><li>可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。</li><li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链（Reference Chain）</li><li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。</li><li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701909773-afa1935b-85a2-4c65-a758-f6a4beb8cabd.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u8e8d4155&margin=%5Bobject%20Object%5D&name=image.png&originHeight=524&originWidth=779&originalType=url&ratio=1&rotation=0&showTitle=false&size=112517&status=done&style=none&taskId=u49e66fdb-e50f-4a56-8832-daccb318e64&title=" alt="image.png"></p><p>在Java语言中，GC Roots包括以下几类元素：</p><ul><li>虚拟机栈中引用的对象 <ul><li>比如：各个线程被调用的方法中使用到的参数、局部变量等。</li></ul></li><li>本地方法栈内JNI（通常说的本地方法）引用的对象</li><li>方法区中类静态属性引用的对象 <ul><li>比如：Java类的引用类型静态变量</li></ul></li><li>方法区中常量引用的对象 <ul><li>比如：字符串常量池（String Table）里的引用</li></ul></li><li>所有被同步锁synchronized持有的对象</li><li>Java虚拟机内部的引用。 <ul><li>基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError），系统类加载器。</li><li>反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li></ul></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701909915-69eef607-a77f-4495-9303-a5291d0ccfda.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u89806c15&margin=%5Bobject%20Object%5D&name=image.png&originHeight=539&originWidth=756&originalType=url&ratio=1&rotation=0&showTitle=false&size=279253&status=done&style=none&taskId=ua010a551-a565-4a50-9f00-d41f9f0fe7e&title=" alt="image.png"></p><p>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：分代收集和局部回收（PartialGC）。</p><p>如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GCRoots集合中去考虑，才能保证可达性分析的准确性。</p><p>小技巧：由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root。</p><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。</p><p>这点也是导致GC进行时必须“stop The World”的一个重要原因。</p><ul><li>即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。</li></ul><h2 id="对象的finalization机制"><a href="#对象的finalization机制" class="headerlink" title="对象的finalization机制"></a>对象的finalization机制</h2><ul><li><p>Java语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。</p></li><li><p>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法。</p></li><li><p>finalize() 方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</p></li><li><p>永远不要主动调用某个对象的finalize()方法I应该交给垃圾回收机制调用。理由包括下面三点：</p></li><li><p>在finalize()时可能会导致对象复活。</p></li><li><p>finalize()方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize()方法将没有执行机会。</p></li><li><p>一个糟糕的finalize()会严重影响Gc的性能。</p></li><li><p>从功能上来说，finalize()方法与C中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize()方法在本质上不同于C中的析构函数。</p></li><li><p>由于finalize()方法的存在，虚拟机中的对象一般处于三种可能的状态。</p></li></ul><h3 id="一，生存还是死亡？"><a href="#一，生存还是死亡？" class="headerlink" title="一，生存还是死亡？"></a>一，生存还是死亡？</h3><ul><li><p>如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。一个无法触及的对象有可能在某一个条件下“复活”自己，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：</p></li><li><p>可触及的：从根节点开始，可以到达这个对象。</p></li><li><p>可复活的：对象的所有引用都被释放，但是对象有可能在finalize()中复活。</p></li><li><p>不可触及的：对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，<strong>因为finalize()只会被调用一次</strong>。</p></li><li><p>以上3种状态中，是由于inalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</p></li></ul><h3 id="二，具体过程"><a href="#二，具体过程" class="headerlink" title="二，具体过程"></a>二，具体过程</h3><p>判定一个对象objA是否可回收，至少要经历两次标记过程：</p><ol><li>如果对象objA到GC Roots没有引用链，则进行第一次标记。</li><li>进行筛选，判断此对象是否有必要执行finalize()方法</li><li>如果对象objA没有重写finalize()方法，或者finalize()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。</li><li>如果对象objA重写了finalize()方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize()方法执行。</li><li><strong>finalize()方法是对象逃脱死亡的最后机会</strong>，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701947314-90f1a887-2459-482f-8203-e53ac39f2727.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u23617756&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1516&originWidth=1089&originalType=url&ratio=1&rotation=0&showTitle=false&size=116251&status=done&style=none&taskId=u2f7567f5-91ef-4adb-a79e-feb8128df06&title=" alt="image.png"></p><h2 id="MAT与JProfiler的GC-Roots溯源"><a href="#MAT与JProfiler的GC-Roots溯源" class="headerlink" title="MAT与JProfiler的GC Roots溯源"></a>MAT与JProfiler的GC Roots溯源</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701983768-a742b535-4090-49a9-b7d4-090dbb958ab0.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u0e0f2708&margin=%5Bobject%20Object%5D&name=image.png&originHeight=2686&originWidth=1098&originalType=url&ratio=1&rotation=0&showTitle=false&size=855105&status=done&style=none&taskId=u6721337f-73b7-4fdd-91d9-c02ce1a378d&title=" alt="image.png"></p><h2 id="垃圾回收相关算法——清除阶段"><a href="#垃圾回收相关算法——清除阶段" class="headerlink" title="垃圾回收相关算法——清除阶段"></a>垃圾回收相关算法——清除阶段</h2><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。</p><p>目前在JVM中比较常见的三种垃圾收集算法是标记一清除算法（Mark-Sweep）、复制算法（copying）、标记-压缩算法（Mark-Compact）</p><h4 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h4><p>标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并并应用于Lisp语言。</p><h5 id="一，执行过程"><a href="#一，执行过程" class="headerlink" title="一，执行过程"></a>一，执行过程</h5><ul><li><p>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除</p></li><li><p>标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。 </p></li><li><p>清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650702090561-3ff0ad48-89e1-4181-9b85-7968e6568a74.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u40171925&margin=%5Bobject%20Object%5D&name=image.png&originHeight=652&originWidth=832&originalType=url&ratio=1&rotation=0&showTitle=false&size=128374&status=done&style=none&taskId=u3821320d-ac2b-4f29-b74b-789c8a4085d&title=" alt="image.png"></p><h5 id="二，缺点"><a href="#二，缺点" class="headerlink" title="二，缺点"></a>二，缺点</h5><ul><li>标记清除算法的效率不算高</li><li>在进行GC的时候，需要停止整个应用程序，用户体验较差</li><li>这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个空闲列表</li></ul><h5 id="三，何为清除"><a href="#三，何为清除" class="headerlink" title="三，何为清除"></a>三，何为清除</h5><p>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放覆盖原有的地址。</p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><h4 id="复制（Copying）算法"><a href="#复制（Copying）算法" class="headerlink" title="复制（Copying）算法"></a>复制（Copying）算法</h4><p>为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky于1963年发表了著名的论文，“使用双存储区的Lisp语言垃圾收集器CA LISP Garbage Collector Algorithm Using Serial Secondary Storage）”。M.L.Minsky在该论文中描述的算法被人们称为复制（Copying）算法，它也被M.L.Minsky本人成功地引入到了Lisp语言的一个实现版本中。</p><h4 id="一，核心思想"><a href="#一，核心思想" class="headerlink" title="一，核心思想"></a>一，核心思想</h4><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650702156239-6fa40c4d-df56-476c-9616-d46a4a5840bc.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u67639ff7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=539&originWidth=1040&originalType=url&ratio=1&rotation=0&showTitle=false&size=113511&status=done&style=none&taskId=u964cacc8-b137-44d7-9ab1-b5c9f74b2c2&title=" alt="image.png"></p><h4 id="二，优点"><a href="#二，优点" class="headerlink" title="二，优点"></a>二，优点</h4><ul><li>没有标记和清除过程，实现简单，运行高效</li><li>复制过去以后保证空间的连续性，不会出现“碎片”问题。</li></ul><h4 id="三，缺点"><a href="#三，缺点" class="headerlink" title="三，缺点"></a>三，缺点</h4><ul><li>此算法的缺点也是很明显的，就是需要两倍的内存空间。</li><li>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小</li></ul><h4 id="四，特别的"><a href="#四，特别的" class="headerlink" title="四，特别的"></a>四，特别的</h4><p>如果系统中的垃圾对象很多，复制算法不会很理想，因为复制算法需要复制的存活对象数量并不会太大，或者说非常低才行</p><h4 id="五，应用场景"><a href="#五，应用场景" class="headerlink" title="五，应用场景"></a>五，应用场景</h4><p>在新生代，对常规应用的垃圾回收，一次通常可以回收70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650702156251-2c7eec83-41fa-4db9-b025-b6c0f4844e4d.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ub6e3073f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=415&originWidth=799&originalType=url&ratio=1&rotation=0&showTitle=false&size=83983&status=done&style=none&taskId=u59492047-1855-4e03-b7e4-e2fbe6be770&title=" alt="image.png"></p><h3 id="标记-压缩（整理）算法"><a href="#标记-压缩（整理）算法" class="headerlink" title="标记-压缩（整理）算法"></a>标记-压缩（整理）算法</h3><h4 id="标记-压缩（或标记-整理、Mark-Compact）算法"><a href="#标记-压缩（或标记-整理、Mark-Compact）算法" class="headerlink" title="标记-压缩（或标记-整理、Mark-Compact）算法"></a>标记-压缩（或标记-整理、Mark-Compact）算法</h4><p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。</p><p>标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JVM的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact）算法由此诞生。</p><p>1970年前后，G.L.Steele、C.J.Chene和D.s.Wise等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。</p><h4 id="一，执行过程-1"><a href="#一，执行过程-1" class="headerlink" title="一，执行过程"></a>一，执行过程</h4><ol><li>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象 </li><li>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。 </li><li>之后，清理边界外所有的空间。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650702224736-ae1e3cc6-c6ab-40ee-beba-9a5a8a48c397.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u8b7b8be6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=538&originWidth=667&originalType=url&ratio=1&rotation=0&showTitle=false&size=113741&status=done&style=none&taskId=uca262698-4ee9-495d-8ab3-78fcb11dc90&title=" alt="image.png"></p><p>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（Mark-Sweep-Compact）算法。</p><p>二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</p><h4 id="二，指针碰撞（Bump-the-Pointer）"><a href="#二，指针碰撞（Bump-the-Pointer）" class="headerlink" title="二，指针碰撞（Bump the Pointer）"></a>二，指针碰撞（Bump the Pointer）</h4><p>如果内存空间以规整和有序的方式分布，即已用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做<strong>指针碰撞（Bump tHe Pointer）</strong>。</p><h4 id="三，优点-1"><a href="#三，优点-1" class="headerlink" title="三，优点"></a>三，优点</h4><ul><li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</li><li>消除了复制算法当中，内存减半的高额代价。</li></ul><h4 id="四，缺点"><a href="#四，缺点" class="headerlink" title="四，缺点"></a>四，缺点</h4><ul><li>从效率上来说，标记-整理算法要低于复制算法。</li><li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址</li><li>移动过程中，需要全程暂停用户应用程序。即：STW</li></ul><h4 id="小结：-1"><a href="#小结：-1" class="headerlink" title="小结："></a>小结：</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650702224698-ebf88486-9940-49fc-b97b-3b6f631733c2.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u91d2661d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=599&originWidth=1047&originalType=url&ratio=1&rotation=0&showTitle=false&size=54779&status=done&style=none&taskId=u46a9f6ac-3570-4578-a5a6-1e296e2277d&title=" alt="image.png"></p><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。</p><p>分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p><p>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p><p><strong>目前几乎所有的GC都采用分代手机算法执行垃圾回收的。</strong></p><p>在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p><h3 id="一，年轻代（Young-Gen）"><a href="#一，年轻代（Young-Gen）" class="headerlink" title="一，年轻代（Young Gen）"></a>一，年轻代（Young Gen）</h3><p>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</p><p>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</p><h3 id="二，老年代（Tenured-Gen）"><a href="#二，老年代（Tenured-Gen）" class="headerlink" title="二，老年代（Tenured Gen）"></a>二，老年代（Tenured Gen）</h3><p>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</p><p>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。</p><ul><li>Mark阶段的开销与存活对象的数量成正比。</li><li>Sweep阶段的开销与所管理区域的大小成正相关。</li><li>Compact阶段的开销与存活对象的数据成正比。</li></ul><p>以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理。</p><p>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代</p><h2 id="增量收集算法、分区算法"><a href="#增量收集算法、分区算法" class="headerlink" title="增量收集算法、分区算法"></a>增量收集算法、分区算法</h2><h4 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h4><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种Stop the World的状态。在Stop the World状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。</p><h5 id="一，基本思想"><a href="#一，基本思想" class="headerlink" title="一，基本思想"></a>一，基本思想</h5><p>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</p><p>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</p><h5 id="二，缺点-1"><a href="#二，缺点-1" class="headerlink" title="二，缺点"></a>二，缺点</h5><p>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</p><h4 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h4><p>一般来说，在相同条件下，堆空间越大，一次Gc时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</p><p>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。</p><p>每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650702306182-7ba9374d-de46-43f3-9b7f-364fd954bee6.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u5acb9dc2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=517&originWidth=781&originalType=url&ratio=1&rotation=0&showTitle=false&size=302996&status=done&style=none&taskId=u0ddc8ffd-7179-4599-9992-763d355bfed&title=" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650702305999-d5ca46f5-021c-4c14-b139-e6ad2abbebdc.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=udddc3495&margin=%5Bobject%20Object%5D&name=image.png&originHeight=155&originWidth=1041&originalType=url&ratio=1&rotation=0&showTitle=false&size=14627&status=done&style=none&taskId=u5bf8fdec-7aa4-41bd-a7f8-3b2a01fc433&title=" alt="image.png"></p><h1 id="垃圾回收相关概念"><a href="#垃圾回收相关概念" class="headerlink" title="垃圾回收相关概念"></a>垃圾回收相关概念</h1><h2 id="一，System-gc-的理解"><a href="#一，System-gc-的理解" class="headerlink" title="一，System.gc()的理解"></a>一，System.gc()的理解</h2><p>在默认情况下，通过system.gc()或者Runtime.getRuntime().gc() 的调用，会显式触发Full GC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</p><p>然而System.gc() 调用附带一个免责声明，无法保证对垃圾收集器的调用。(<strong>不能确保立即生效</strong>)</p><p>JVM实现者可以通过System.gc() 调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650702370112-0f7efa93-5f7b-414e-b597-02da1ac18f3c.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u8fd13a56&margin=%5Bobject%20Object%5D&name=image.png&originHeight=471&originWidth=999&originalType=url&ratio=1&rotation=0&showTitle=false&size=53045&status=done&style=none&taskId=ua31c3f5e-6cb1-4495-a5e0-67dc578069e&title=" alt="image.png"></p><h2 id="内存溢出与内存泄露与STW"><a href="#内存溢出与内存泄露与STW" class="headerlink" title="内存溢出与内存泄露与STW"></a>内存溢出与内存泄露与STW</h2><h3 id="一，内存溢出（OOM）"><a href="#一，内存溢出（OOM）" class="headerlink" title="一，内存溢出（OOM）"></a>一，内存溢出（OOM）</h3><p>内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。</p><p>由于GC一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现ooM的情况。</p><p>大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的Full GC操作，这时候会回收大量的内存，供应用程序继续使用。</p><p>javadoc中对OutOfMemoryError的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。</p><p>首先说没有空闲内存的情况：说明Java虚拟机的堆内存不够。原因有二：</p><ol><li><strong>Java虚拟机的堆内存设置不够。</strong><br>比如：可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小。我们可以通过参数-Xms 、-Xmx来调整。 </li><li><strong>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）</strong><br>对于老版本的Oracle JDK，因为永久代的大小是有限的，并且JVM对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现OutOfMemoryError也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似intern字符串缓存占用太多空间，也会导致OOM问题。对应的异常信息，会标记出来和永久代相关：“java.lang.OutOfMemoryError: PermGen space”。<br>随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的ooM有所改观，出现OOM，异常信息则变成了：“java.lang.OutofMemoryError:Metaspace”。直接内存不足，也会导致OOM。</li></ol><p>这里面隐含着一层意思是，在抛出OutOfMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间。</p><ul><li><p>例如：在引用机制分析中，涉及到JVM会去尝试回收软引用指向的对象等。</p></li><li><p>在java.nio.BIts.reserveMemory()方法中，我们能清楚的看到，System.gc()会被调用，以清理空间。</p></li><li><p>当然，也不是在任何情况下垃圾收集器都会被触发的</p><ul><li>比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出OutOfMemoryError。</li></ul></li></ul><h3 id="二，内存泄漏（Memory-Leak）"><a href="#二，内存泄漏（Memory-Leak）" class="headerlink" title="二，内存泄漏（Memory Leak）"></a>二，内存泄漏（Memory Leak）</h3><p>也称作“存储渗漏”。严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。</p><p>但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致00M，也可以叫做宽泛意义上的“内存泄漏”。</p><p>尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现OutOfMemory异常，导致程序崩溃。</p><p>注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650702401304-bb089921-301b-490b-a81e-725fa00588ed.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u97c791a2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=511&originWidth=1079&originalType=url&ratio=1&rotation=0&showTitle=false&size=254148&status=done&style=none&taskId=u99878d4a-401f-430d-ab2a-02a4cb48b26&title=" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650702401185-4a3dcaa4-b64f-4003-8a35-f173f22ede23.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u2b7d2e7f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=296&originWidth=1054&originalType=url&ratio=1&rotation=0&showTitle=false&size=35430&status=done&style=none&taskId=ufb097c65-90a0-453f-899f-af4910297e0&title=" alt="image.png"></p><h3 id="三，Stop-The-World"><a href="#三，Stop-The-World" class="headerlink" title="三，Stop The World"></a>三，Stop The World</h3><p>Stop-the-World，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。</p><p>可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿。</p><ul><li>分析工作必须在一个能确保一致性的快照中进行</li><li>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</li><li>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</li></ul><p>被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少STW的发生。</p><p>STW事件和采用哪款GC无关，所有的GC都有这个事件。</p><p>哪怕是G1也不能完全避免Stop-the-World情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。</p><p>STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉。</p><p><strong>开发中不要用System.gc() 会导致Stop-the-World的发生</strong>。</p><h2 id="垃圾回收的并行与并发"><a href="#垃圾回收的并行与并发" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h2><h4 id="并发（Concurrent）"><a href="#并发（Concurrent）" class="headerlink" title="并发（Concurrent）"></a>并发（Concurrent）</h4><p>在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行。</p><p>并发不是真正意义上的“同时进行”，只是CPU把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换，由于CPU处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650702434204-bf383107-d1aa-4a98-a92f-98c54ca2e2f1.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u5a5c318d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=307&originWidth=502&originalType=url&ratio=1&rotation=0&showTitle=false&size=74988&status=done&style=none&taskId=ub12a5816-7a43-4ee9-a7e0-9944af99e02&title=" alt="image.png"></p><h4 id="并行（Parallel）"><a href="#并行（Parallel）" class="headerlink" title="并行（Parallel）"></a>并行（Parallel）</h4><p>当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，我们称之为并行（Parallel）。</p><p>其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行。</p><p>适合科学计算，后台处理等弱交互场景</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650702434177-57d2314a-3109-4554-a062-e4db224468b9.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u8dd20a64&margin=%5Bobject%20Object%5D&name=image.png&originHeight=285&originWidth=490&originalType=url&ratio=1&rotation=0&showTitle=false&size=54227&status=done&style=none&taskId=ufdd50b45-75d8-4641-9314-3d228f36270&title=" alt="image.png"></p><h4 id="并发-vs-并行"><a href="#并发-vs-并行" class="headerlink" title="并发 vs 并行"></a>并发 vs 并行</h4><ul><li>并发，指的是多个事情，在同一时间段内同时发生了。 </li><li>并行，指的是多个事情，在同一时间点上同时发生了。 </li><li>并发的多个任务之间是互相抢占资源的。 </li><li>并行的多个任务之间是不互相抢占资源的。 </li><li>只有在多CPU或者一个CPU多核的情况中，才会发生并行。 </li><li>否则，看似同时发生的事情，其实都是并发执行的。</li></ul><h4 id="垃圾回收的并发与并行"><a href="#垃圾回收的并发与并行" class="headerlink" title="垃圾回收的并发与并行"></a>垃圾回收的并发与并行</h4><h5 id="一，并行（Parallel）"><a href="#一，并行（Parallel）" class="headerlink" title="一，并行（Parallel）"></a>一，并行（Parallel）</h5><p>指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。如ParNew、Parallel Scavenge、Parallel Old；</p><h5 id="二，串行（Serial）"><a href="#二，串行（Serial）" class="headerlink" title="二，串行（Serial）"></a>二，串行（Serial）</h5><p>相较于并行的概念，单线程执行。如果内存不够，则程序暂停，启动JM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650702434249-5d368e8c-4534-4c53-860d-840c38374a38.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u7be9d313&margin=%5Bobject%20Object%5D&name=image.png&originHeight=323&originWidth=1143&originalType=url&ratio=1&rotation=0&showTitle=false&size=104439&status=done&style=none&taskId=u028b9a31-ef15-4241-b9b5-c3942bf3d35&title=" alt="image.png"></p><h5 id="三，并发（Concurrent）"><a href="#三，并发（Concurrent）" class="headerlink" title="三，并发（Concurrent）"></a>三，并发（Concurrent）</h5><p>指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上；如：CMS、G1</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650702434252-50d3d1ae-6a83-43a2-b715-48b272c8cb9c.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u3ac9062b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=306&originWidth=649&originalType=url&ratio=1&rotation=0&showTitle=false&size=77551&status=done&style=none&taskId=u3d6f03f4-b64b-4900-bc7f-6211ed08836&title=" alt="image.png"></p><h2 id="安全点与安全区域"><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h2><h3 id="一，安全点"><a href="#一，安全点" class="headerlink" title="一，安全点"></a>一，安全点</h3><p>程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点（Safepoint）”。</p><p>Safe Point的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。比如：选择一些执行时间较长的指令作为Safe Point，如方法调用、循环跳转和异常跳转等。</p><p>如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？</p><ul><li><p>抢先式中断：（目前没有虚拟机采用了）</p><ul><li>首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</li></ul></li><li><p>主动式中断</p><ul><li>设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。（有轮询的机制）</li></ul></li></ul><h3 id="二，安全区域（Safe-Resion）"><a href="#二，安全区域（Safe-Resion）" class="headerlink" title="二，安全区域（Safe Resion）"></a>二，安全区域（Safe Resion）</h3><p>Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？例如线程处于Sleep 状态或Blocked 状态，这时候线程无法响应JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。</p><p>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始Gc都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650702499644-5865ef5e-0c59-46e9-ba65-92f57ea9ba51.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u40a9afee&margin=%5Bobject%20Object%5D&name=image.png&originHeight=246&originWidth=1051&originalType=url&ratio=1&rotation=0&showTitle=false&size=37361&status=done&style=none&taskId=uc5824753-4347-4e4f-a8ee-85f0edc3000&title=" alt="image.png"></p><h2 id="强软弱虚引用"><a href="#强软弱虚引用" class="headerlink" title="强软弱虚引用"></a>强软弱虚引用</h2><p>我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。</p><p><strong>【既偏门又非常高频的面试题】强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？</strong></p><p>在JDK1.2版之后，Java对引用的概念进行了扩充，将引用分为：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）这4种引用强度依次逐渐减弱。</p><p>除强引用外，其他3种引用均可以在java.lang.ref包中找到它们的身影。如下图，显示了这3种引用类型对应的类，开发人员可以在应用程序中直接使用它们。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650702557892-16ebcfb4-a9c4-4012-bac3-cf57d503a4b5.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua2092e8b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=150&originWidth=442&originalType=url&ratio=1&rotation=0&showTitle=false&size=81572&status=done&style=none&taskId=u6e4c413f-a04d-49ac-ae2a-791ca329708&title=" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650702557894-f0fc4f8b-1c77-4f43-a574-364d21881883.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ud3eb5c4d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=430&originWidth=1050&originalType=url&ratio=1&rotation=0&showTitle=false&size=88492&status=done&style=none&taskId=u99fddc0d-4b17-4730-ba0e-89894f7f650&title=" alt="image.png"></p><h3 id="一，强引用（Strong-Reference）——不回收"><a href="#一，强引用（Strong-Reference）——不回收" class="headerlink" title="一，强引用（Strong Reference）——不回收"></a>一，强引用（Strong Reference）——不回收</h3><p>在Java程序中，最常见的引用类型是强引用（普通系统99%以上都是强引用），也就是我们最常见的普通对象引用，也是默认的引用类型。</p><p>当在Java语言中使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</p><p>强引用的对象是<strong>可触及的</strong>，垃圾收集器就永远不会回收掉被引用的对象。</p><p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为nu11，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</p><p>相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，<strong>强引用是造成Java内存泄漏的主要原因之一</strong>。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650702558047-475a6734-a01b-456c-8659-6d7d64d99b53.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u5cd487c1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1382&originWidth=1078&originalType=url&ratio=1&rotation=0&showTitle=false&size=302465&status=done&style=none&taskId=ufc612a6d-e708-4ee9-a596-ef5fced1a72&title=" alt="image.png"></p><h3 id="二，软引用（Soft-Reference）——内存不足即回收"><a href="#二，软引用（Soft-Reference）——内存不足即回收" class="headerlink" title="二，软引用（Soft Reference）——内存不足即回收"></a>二，软引用（Soft Reference）——内存不足即回收</h3><ul><li>软引用是用来描述一些还有用，但非必需的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</li><li>软引用通常用来实现内存敏感的缓存。比如：高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</li><li>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue）。</li><li>类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</li><li>在JDK1.2版之后提供了java.lang.ref.SoftReference类来实现软引用</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650702557879-c81cc41d-5cb4-4987-8eb6-6c45ec223104.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u33ac8371&margin=%5Bobject%20Object%5D&name=image.png&originHeight=164&originWidth=1002&originalType=url&ratio=1&rotation=0&showTitle=false&size=16058&status=done&style=none&taskId=u5a71615d-4e86-4856-836b-73741cff7f8&title=" alt="image.png"></p><h3 id="三，弱引用（Weak-Reference）——发现即回收"><a href="#三，弱引用（Weak-Reference）——发现即回收" class="headerlink" title="三，弱引用（Weak Reference）——发现即回收"></a>三，弱引用（Weak Reference）——发现即回收</h3><p>弱引用也是用来描述那些非必需对象，只被弱引用关联的对象只能生存到下一次垃圾收集发生为止。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。</p><p>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。</p><p>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</p><p>软引用、弱引用都非常适合来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</p><p>在JDK1.2版之后提供了WeakReference类来实现弱引用</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650702557880-0118bd2d-ca07-48ce-be2c-e43d50ff816f.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u45b98683&margin=%5Bobject%20Object%5D&name=image.png&originHeight=415&originWidth=1036&originalType=url&ratio=1&rotation=0&showTitle=false&size=52357&status=done&style=none&taskId=u5f0c7c39-be4d-4dad-ab11-e8881ef8681&title=" alt="image.png"></p><h3 id="四，虚引用（Phantom-Reference）——对象回收跟踪"><a href="#四，虚引用（Phantom-Reference）——对象回收跟踪" class="headerlink" title="四，虚引用（Phantom Reference）——对象回收跟踪"></a>四，虚引用（Phantom Reference）——对象回收跟踪</h3><p>也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个。</p><p>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</p><p>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get()方法取得对象时，总是null</p><p>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</p><p>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</p><p>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</p><p>在JDK1.2版之后提供了PhantomReference类来实现虚引用。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650702558659-d63762a2-8702-4990-9f89-406189567f0f.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uefe448d3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=189&originWidth=1001&originalType=url&ratio=1&rotation=0&showTitle=false&size=18155&status=done&style=none&taskId=u4790cd59-20fb-460f-a837-10d3101aad2&title=" alt="image.png"></p><h3 id="五，终结器引用"><a href="#五，终结器引用" class="headerlink" title="五，终结器引用"></a>五，终结器引用</h3><p>它用于实现对象的finalize() 方法，也可以称为终结器引用。无需手动编码，其内部配合引用队列使用。</p><p>在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象调用它的finalize()方法，第二次GC时才回收被引用的对象</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JVM </tag>
            
            <tag> 垃圾回收 </tag>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
