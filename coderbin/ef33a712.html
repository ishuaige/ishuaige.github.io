<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>JVM-内存及垃圾回收 | coderbin</title><meta name="keywords" content="java,JVM,垃圾回收,内存"><meta name="author" content="coderbin"><meta name="copyright" content="coderbin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="类加载子系统类加载子系统一  类加载子系统作用 负责从文件系统或者网络中加载Class文件，Class文件开头有特定标识（cafebabe） Classloader只负责class文件的加载，至于是否可运行，则有执行引擎决定 加载的类信息存放于称为方法区的内存空间，除了类信息，方法区还会存放运行时常量池信息，还可能包括字符串字面量和数字常量。（常量池运行时加载到内存中，即运行时常量池）  类加">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM-内存及垃圾回收">
<meta property="og:url" content="http://ishuaige.github.io/coderbin/ef33a712.html">
<meta property="og:site_name" content="coderbin">
<meta property="og:description" content="类加载子系统类加载子系统一  类加载子系统作用 负责从文件系统或者网络中加载Class文件，Class文件开头有特定标识（cafebabe） Classloader只负责class文件的加载，至于是否可运行，则有执行引擎决定 加载的类信息存放于称为方法区的内存空间，除了类信息，方法区还会存放运行时常量池信息，还可能包括字符串字面量和数字常量。（常量池运行时加载到内存中，即运行时常量池）  类加">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/jvm.jpg">
<meta property="article:published_time" content="2021-12-04T21:20:00.000Z">
<meta property="article:modified_time" content="2022-08-05T03:30:56.275Z">
<meta property="article:author" content="coderbin">
<meta property="article:tag" content="java">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="垃圾回收">
<meta property="article:tag" content="内存">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/jvm.jpg"><link rel="shortcut icon" href="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/shutiao.png"><link rel="canonical" href="http://ishuaige.github.io/coderbin/ef33a712"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JVM-内存及垃圾回收',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-08-05 11:30:56'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="css/style.css"><meta name="generator" content="Hexo 6.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/touxiang.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">47</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">coderbin</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">JVM-内存及垃圾回收</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-04T21:20:00.000Z" title="发表于 2021-12-05 05:20:00">2021-12-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-08-05T03:30:56.275Z" title="更新于 2022-08-05 11:30:56">2022-08-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JVM/">JVM</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">36k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>109分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JVM-内存及垃圾回收"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><meta name="referrer" content="no-referrer" />

<h1 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h1><h2 id="类加载子系统一"><a href="#类加载子系统一" class="headerlink" title="类加载子系统一"></a>类加载子系统一</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699171422-27f069a7-962d-45ea-98c5-44bf524d1371.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u5a326163&margin=%5Bobject%20Object%5D&name=image.png&originHeight=579&originWidth=706&originalType=url&ratio=1&rotation=0&showTitle=false&size=161325&status=done&style=none&taskId=ub324f2a4-f9fe-428f-a987-f86af36f396&title=" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699171386-29e85e62-d7d9-4bf1-9714-2df26bec5cdc.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u4f09d4cd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=322&originWidth=856&originalType=url&ratio=1&rotation=0&showTitle=false&size=120382&status=done&style=none&taskId=u99b76d41-c99c-4f2c-99e7-6e91ba5d719&title=" alt="image.png"></p>
<h3 id="类加载子系统作用"><a href="#类加载子系统作用" class="headerlink" title="类加载子系统作用"></a>类加载子系统作用</h3><ol>
<li>负责从文件系统或者网络中加载Class文件，Class文件开头有特定标识（cafebabe）</li>
<li>Classloader只负责class文件的加载，至于是否可运行，则有执行引擎决定</li>
<li>加载的类信息存放于称为方法区的内存空间，除了类信息，方法区还会存放运行时常量池信息，还可能包括字符串字面量和数字常量。（常量池运行时加载到内存中，即运行时常量池）</li>
</ol>
<h3 id="类加载器ClassLoader的角色"><a href="#类加载器ClassLoader的角色" class="headerlink" title="类加载器ClassLoader的角色"></a>类加载器ClassLoader的角色</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699171350-4fd53ff9-f37b-42cc-899c-ef2257315573.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u937e1fd8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=607&originWidth=908&originalType=url&ratio=1&rotation=0&showTitle=false&size=56576&status=done&style=none&taskId=u59952d76-78a3-4bd6-9147-40b717103f9&title=" alt="image.png"></p>
<p>1.class file 存在与本地硬盘上。可以理解为设计师画在之上的模板，而最终这个模板在执行的时候是要加载到JVM当中来，根据这个文件实例化出n个一模一样的实例。</p>
<p>2.class file 加载带JVM中，被称为DNA元数据模块，放在方法区。</p>
<p>3.在 .class 文件 –&gt; JVM –&gt; 最终成为元数据模板，此过程就要一个运输工具（类装载器 Class Loader），扮演一个快递员的角色。</p>
<h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699189236-3f050a78-50fc-494d-8293-3e4c169c2a29.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u8f59760f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=239&originWidth=715&originalType=url&ratio=1&rotation=0&showTitle=false&size=185629&status=done&style=none&taskId=ue06f9f44-cd40-475f-9ab1-9f403b893ef&title=" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699189213-62e435db-9d7d-4f29-8d84-373274fd76eb.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uc746b309&margin=%5Bobject%20Object%5D&name=image.png&originHeight=437&originWidth=555&originalType=url&ratio=1&rotation=0&showTitle=false&size=66533&status=done&style=none&taskId=u97ec9e5e-9a9c-4365-a56b-62e9acb0e1a&title=" alt="image.png"></p>
<h4 id="一-加载"><a href="#一-加载" class="headerlink" title="一.加载"></a>一.加载</h4><ol>
<li>通过一个类的全限定名获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的**java.lang.Class **对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<p>&#x2F;**<br>补充：加载  .Class 文件的方式<br>1.从本地系统中直接加载<br>2.通过网络获取，典型场景：Web Applet<br>3.从 zip 压缩包中读取，成为日后 jar、war 格式的基础<br>4.运行时计算生成，使用最多的是：动态代理技术<br>5.有其他文件生成，典型场景：JSP应用<br>6.从专有数据库中提取 .class 文件，比较少见<br>7.从加密文件中获取，典型的防 Class 文件被反编译的保护措施<br>**&#x2F;</p>
<h4 id="二-链接"><a href="#二-链接" class="headerlink" title="二.链接"></a>二.链接</h4><h5 id="1-验证-Verify"><a href="#1-验证-Verify" class="headerlink" title="1.验证(Verify)"></a>1.验证(Verify)</h5><p>（1）目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。<br>（2）主要包括四种验证：<br>文件格式验证：</p>
<p>A.CA FE BA BE</p>
<p>B.主次版本号</p>
<p>C.常量池的常量中是否有不被支持的常量类型。</p>
<p>D. 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</p>
<p>元数据验证：</p>
<p>A.对字节码描述的信息进行语义分析，保证描述符合Java规范</p>
<p>B.类是否有父类，除了Object之外，所有的类都应该有父类</p>
<p>C.类的父类是否继承了不允许被继承的类（被final修饰的类）</p>
<p>D.如果这个类不是抽象类，是否实现了其父类或接口中要求实现的所有方法。<br>E.类的字段，方法是否与父类的产生矛盾。例如方法参数都一样，返回值不同</p>
<p>字节码验证：</p>
<p>A.通过数据流分析和控制流分析，确定程序语义是合法的，符合逻辑的。</p>
<p>B.对类的方法体，进行校验分析，保证在运行时不会做出危害虚拟机的行为</p>
<p>C.保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，不会出现类似于在操作数栈放了一个int类型的数据，使用时却按照long类型加载到本地变量表中的情况。</p>
<p>D.保障任何跳转指令都不会跳转到方法体之外的字节码指令上。</p>
<p>符号引用验证：</p>
<p>A.通过字符串描述的全限定名是否能找到对应的类</p>
<p>B.符号引用中的类、字段、方法的可访问性是否可被当前类访问</p>
<h5 id="2-准备-Prepare"><a href="#2-准备-Prepare" class="headerlink" title="2.准备(Prepare)"></a>2.准备(Prepare)</h5><p>(1)为类变量分配内存并且设置该类变量的默认初始值，即零值。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699189180-b3142004-5374-4d05-acac-2ad00a66b532.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ueba01c74&margin=%5Bobject%20Object%5D&name=image.png&originHeight=242&originWidth=848&originalType=url&ratio=1&rotation=0&showTitle=false&size=30561&status=done&style=none&taskId=u985e86a9-d1da-4bc8-8dcf-3d838aeefc5&title=" alt="image.png"></p>
<p>(2)不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显示初始化</p>
<p>(3)不会为实例变量分配初始化，类变量会分配在方法区中，实例变量会随着对象一<br>起分配到Java堆中-</p>
<h5 id="3-解析-Resolve"><a href="#3-解析-Resolve" class="headerlink" title="3.解析(Resolve)"></a>3.解析(Resolve)</h5><p>(1)将常量池内的符号引用转换为直接引用的过程<br>(2)解析操作往往会伴随着JVM在执行完初始化之后再执行<br>(3)符号引用就是一组符号来描述所应用的目标，符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中<br>(4)直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。<br>(5)解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info</p>
<h4 id="三-初始化"><a href="#三-初始化" class="headerlink" title="三.初始化"></a>三.初始化</h4><p>1.初始化阶段就是执行类构造器方法 <clinit>() 的过程。<br>2.此方法不需定义，是javac编译器自动收集类中的所有变量的赋值动作和静态代码块中的语句合并而来<br>3.构造器方法中指令按语句再源文件中出现的顺序执行<br>4.   <clinit>()  不同于类的构造器。（关联：构造器是虚拟机视角下的 <init>() ）<br>5.若该类具有父类，JVM会保证子类的<clinit>() 执行前，父类的<clinit>() 已经执行完毕<br>6.虚拟机必须保证一个类的<clinit>() 方法在多线程下被同步加锁</p>
<h4 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h4><p>一.加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的。</p>
<p>二.解析阶段不一定，在某些情况下可以在初始化阶段之后再开始，为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）</p>
<p>三.Java虚拟机规范严格规定了，有且只有六种情况，必须立即对类进行初始化</p>
<p>1、遇到new,getstatic，putstatic或invokestatic这四条字节码指令时。<br>使用new关键字实例化对象<br>读取或设置一个类型的静态字段（final修饰已在编译期将结果放入常量池的静态字段除外）<br>调用一个类型的静态方法的时候</p>
<p>2、对类型进行反射调用，如果类型没有经过初始化，则需要触发初始化</p>
<p>3、初始化类的时候，发现父类没有初始化，则先触发父类初始化</p>
<p>4、虚拟机启动时，用户需要指定一个要执行的主类（包含main方法的那个类），虚拟机会初始化这个主类</p>
<p>5、只用JDK7中新加入的动态语言支持，如果一个java.lang.invoke.MethodHandler实例最后的解析结果为REF_getStatic,REF_putStatic,REF_invokeStatic，REF_newInvokeSpecial四种类型的方法句柄，并且这个方法对应的类没有进行初始化，则先触发其初始化</p>
<p>6、当一个接口中定了JDK8新加入的默认方法时，如果这个接口的实现类发生了初始化，要先将接口进行初始化</p>
<p>除了以上几种情况，其他使用类的方式被看做是对类的被动使用，都不会导致类的初始化</p>
<h2 id="类加载子系统二"><a href="#类加载子系统二" class="headerlink" title="类加载子系统二"></a>类加载子系统二</h2><h3 id="一-类加载器分类"><a href="#一-类加载器分类" class="headerlink" title="一.类加载器分类"></a>一.类加载器分类</h3><p>1.引导类加载器（使用C&#x2F;C++编写）<br>2.自定义加载器<br>概念：所有派生于抽象类ClassLoader 的类加载器都划分为自定义类加载器</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699344121-d6003fc0-16bc-4346-93fe-2caf51656e35.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uc079fe01&margin=%5Bobject%20Object%5D&name=image.png&originHeight=484&originWidth=891&originalType=url&ratio=1&rotation=0&showTitle=false&size=29468&status=done&style=none&taskId=u732afc2e-5157-4eaa-b2f2-123ddb6564e&title=" alt="image.png"></p>
<p>类：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699344365-1a4fb04f-ba96-4806-8cc4-d586e7a2d26c.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uf57680ff&margin=%5Bobject%20Object%5D&name=image.png&originHeight=588&originWidth=1150&originalType=url&ratio=1&rotation=0&showTitle=false&size=358457&status=done&style=none&taskId=u89ce48e8-1be4-41a9-84b6-aebc8ca446d&title=" alt="image.png"></p>
<h3 id="二-代码获取类加载器："><a href="#二-代码获取类加载器：" class="headerlink" title="二.代码获取类加载器："></a>二.代码获取类加载器：</h3><p>1.截图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699344450-d664b00d-2026-49ee-a4e9-3622335086ec.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u845ff23c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=547&originWidth=1136&originalType=url&ratio=1&rotation=0&showTitle=false&size=470164&status=done&style=none&taskId=u9724d770-5f5b-421c-be84-ab87334e2b8&title=" alt="image.png"></p>
<p>2.对于用户来说定义器来说，默认使用系统类加载器进行加载</p>
<p>3.JAVA的核心类库，使用引导类加载器进行加载</p>
<h3 id="三-启动类加载器（引导类加载器，Bootstrap-ClassLoader）："><a href="#三-启动类加载器（引导类加载器，Bootstrap-ClassLoader）：" class="headerlink" title="三.启动类加载器（引导类加载器，Bootstrap,ClassLoader）："></a>三.启动类加载器（引导类加载器，Bootstrap,ClassLoader）：</h3><ol>
<li>C&#x2F;C++语言实现，嵌套在JVM内部</li>
<li>用来加载JAVA的核心库（JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar 、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类。<ol>
<li>代码获取加载路径</li>
</ol>
</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699344193-7f79c54a-6ae8-41b5-b791-2fcdaebc9685.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u6fe22e4a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=122&originWidth=892&originalType=url&ratio=1&rotation=0&showTitle=false&size=112503&status=done&style=none&taskId=u1e570db6-a961-4d0c-a73c-c6d089ce806&title=" alt="image.png"></p>
<ol>
<li>并不继承自java.lang.ClassLoader ，没有父加载器。</li>
<li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li>
<li>出于安全考虑，Boostrap启动类加载器只加载包名为Java、javax、sun等开头的类。</li>
</ol>
<h3 id="四-扩展类加载器（java9-平台类加载器"><a href="#四-扩展类加载器（java9-平台类加载器" class="headerlink" title="四.扩展类加载器（java9:平台类加载器)"></a>四.扩展类加载器（java9:平台类加载器)</h3><ol>
<li>JAVA语言编写，由 sun.misc.Launcher$ExtClassLoader 实现。</li>
<li>派生于ClassLoader类</li>
<li>父类加载器为启动类加载器</li>
<li>从 java.ext.dirs 系统属性所指定的目录中加载类库，或从JDK的安装目录的jre&#x2F;lib&#x2F;est子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。<ol>
<li>代码</li>
</ol>
</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699344239-7139606f-07bc-45a9-9ea4-25714d9bdb2f.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=udf0d5e47&margin=%5Bobject%20Object%5D&name=image.png&originHeight=212&originWidth=769&originalType=url&ratio=1&rotation=0&showTitle=false&size=144592&status=done&style=none&taskId=u3c5849d6-364c-4f34-99f6-919c318fe98&title=" alt="image.png"></p>
<h3 id="五-应用程序类加载器（系统类加载器：AppClassLoader）"><a href="#五-应用程序类加载器（系统类加载器：AppClassLoader）" class="headerlink" title="五.应用程序类加载器（系统类加载器：AppClassLoader）"></a>五.应用程序类加载器（系统类加载器：AppClassLoader）</h3><ol>
<li>java语言编写，由sun.misc.Launcher$AppClassLoader实现</li>
<li>派生于ClassLoader 类</li>
<li>父类加载器为扩展类加载器</li>
<li>负责加载环境变量classpath或系统属性 java.class.path 指定路径下的类库</li>
<li>该类加载时程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li>
<li>通过ClassLoader#getSystemClassLoader（）方法可以获取到该类加载器</li>
</ol>
<h3 id="六-用户自定义类加载器"><a href="#六-用户自定义类加载器" class="headerlink" title="六.用户自定义类加载器"></a>六.用户自定义类加载器</h3><ol>
<li>为什么要用自定义类加载器<ol>
<li>隔离加载类<ol>
<li>例如使中间件的Jar包与应用程序Jar包不冲突</li>
</ol>
</li>
<li>修改类加载的方式<ol>
<li>启动类加载器必须使用，其他可以根据需要自定义加载</li>
</ol>
</li>
<li>扩展加载源</li>
<li>防止源码泄露<ol>
<li>对字节码进行加密，自定义类加载器实现解密</li>
</ol>
</li>
</ol>
</li>
<li>实现步骤<ol>
<li>继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器</li>
<li>1.2之前，继承并重写loadClass方法，1.2之后，建议把自定义的类加载逻辑写在findClass()方法中</li>
<li>如果没有太过复杂的需求，可以直接继承URLClassLoader类，可以避免自己编写findClass（）方法，及其获取字节码流的方式，使自定义类加载器编写更加简洁</li>
</ol>
</li>
</ol>
<h3 id="七-关于CLassLoader"><a href="#七-关于CLassLoader" class="headerlink" title="七.关于CLassLoader"></a>七.关于CLassLoader</h3><ol>
<li>是一个抽象类，除了启动类加载器，其他类加载器都继承自他</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699345083-a88f974d-56f6-431b-bc9c-5d78b0b930db.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u7f0ab734&margin=%5Bobject%20Object%5D&name=image.png&originHeight=314&originWidth=1078&originalType=url&ratio=1&rotation=0&showTitle=false&size=193738&status=done&style=none&taskId=u496eafa5-7ebd-494a-a3ff-68e40039aca&title=" alt="image.png"></p>
<h3 id="八-双亲委派机制"><a href="#八-双亲委派机制" class="headerlink" title="八.双亲委派机制"></a>八.双亲委派机制</h3><p>原理：Java虚拟机对Class文件采用的是按需加载，而且加载class文件时，Java虚拟机使用的是双亲委派模式，即把请求交由父类处理，它是异种任务委派模式。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699378231-698c9adf-f26b-427f-9fa3-990866dd0489.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uc3644a1b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=531&originWidth=656&originalType=url&ratio=1&rotation=0&showTitle=false&size=224838&status=done&style=none&taskId=ud433fd7c-1d4a-479c-ae9f-d67178fec22&title=" alt="image.png"></p>
<ol>
<li>如果一个类加载器收到了类加载请求，它并不会自己先去加载。而是把这个请求委托给父类的加载器去执行</li>
<li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将达到顶层的启动类加载器</li>
<li>如果父类的加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699378428-6a14a1de-b264-4129-873e-c72b864f45d1.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ufa80679b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=576&originWidth=811&originalType=url&ratio=1&rotation=0&showTitle=false&size=509119&status=done&style=none&taskId=u7e6ecec2-d67d-4937-96c0-665ab4e9c3c&title=" alt="image.png"></p>
<h4 id="一-双亲委派机制优势"><a href="#一-双亲委派机制优势" class="headerlink" title="一.双亲委派机制优势"></a>一.双亲委派机制优势</h4><ol>
<li>避免类的重复加载</li>
<li></li>
</ol>
<h3 id="九-沙箱安全机制"><a href="#九-沙箱安全机制" class="headerlink" title="九.沙箱安全机制"></a>九.沙箱安全机制</h3><ol>
<li>保证对Java核心源代码的保护</li>
</ol>
<p>&#x2F;**<br>补充：</p>
<ol>
<li>在JVM中表示两个class对象，是否为同一个类存在两个必要条件<ol>
<li>类的完整类名必须一致，包括包名</li>
<li>加载这个类的ClassLoader必须相同</li>
</ol>
</li>
<li>JVM必须知道一个类型是由启动类加载器加载的，还是由用户类加载器加载的。如果是用户类加载器加载的，JVM会将这个类加载器的一个引用作为类型信息的一部分，保存到方法区中。</li>
</ol>
<p>**&#x2F;</p>
<h1 id="运行时数据区概述"><a href="#运行时数据区概述" class="headerlink" title="运行时数据区概述"></a>运行时数据区概述</h1><h2 id="⭐程序寄存器（PC寄存器）"><a href="#⭐程序寄存器（PC寄存器）" class="headerlink" title="⭐程序寄存器（PC寄存器）"></a>⭐程序寄存器（PC寄存器）</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699544276-20b8db39-7140-4fb3-a6e0-34f7c8c2add4.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u7eeeeedc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=545&originWidth=1021&originalType=url&ratio=1&rotation=0&showTitle=false&size=200125&status=done&style=none&taskId=ua5a90dc1-5bf7-41c7-9a44-3932d39ee14&title=" alt="image.png"></p>
<ul>
<li>运行时数据区中唯一不会出现OOM（OOM:out of memory）的区域，没有垃圾回收(GC)</li>
<li>当前线程所执行的字节码的行号指示器<ul>
<li>为了线程切换后能恢复到正确的位置</li>
</ul>
</li>
<li>每个线程有一个独立的程序计数器，线程之间互不影响。</li>
<li>如果线程执行的Java方法，则计数器记录正在执行的虚拟机字节码的指令的地址</li>
<li>如果正在执行的本地方法，这个计数器值则应为空。（undefined）</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699544325-dc158f8f-b18f-484f-942e-d430c6919817.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua1d43bb4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=589&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&size=241131&status=done&style=none&taskId=u4c4f529d-c1df-4cf1-a878-15303488957&title=" alt="image.png"></p>
<h2 id="⭐虚拟机栈"><a href="#⭐虚拟机栈" class="headerlink" title="⭐虚拟机栈"></a>⭐虚拟机栈</h2><h3 id="一，内存中的栈和堆"><a href="#一，内存中的栈和堆" class="headerlink" title="一，内存中的栈和堆"></a>一，内存中的栈和堆</h3><ul>
<li>栈是运行时的单位，而堆是存储的单位，栈解决程序如何执行，如何处理数据。堆解决的是数据存储问题，即数据怎么放，放在哪里。</li>
<li><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699564568-37d9f6c1-1e47-41e4-9598-306f4e524cdb.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u75c54b67&margin=%5Bobject%20Object%5D&name=image.png&originHeight=360&originWidth=490&originalType=url&ratio=1&rotation=0&showTitle=false&size=55445&status=done&style=none&taskId=ua63a0512-3428-41b1-8481-33db12bdec7&title=" alt="image.png"></li>
</ul>
<h3 id="二，基本内容"><a href="#二，基本内容" class="headerlink" title="二，基本内容"></a>二，基本内容</h3><ul>
<li>Java虚拟机栈，早起也叫Java栈，每个线程创建时都会创建一个虚拟机栈，内部保存一个个栈帧，对应着一次次的Java方法调用<ul>
<li>线程私有的</li>
<li><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699564581-c0610d3f-d586-4044-aab2-6bf098a4e1e6.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u5ee2737e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=400&originWidth=642&originalType=url&ratio=1&rotation=0&showTitle=false&size=56011&status=done&style=none&taskId=uc68664bf-161e-4c65-8068-066e89c89e6&title=" alt="image.png"></li>
</ul>
</li>
<li>生命周期<ul>
<li>生命周期和线程的一致</li>
</ul>
</li>
<li>作用<ul>
<li>主管Java程序的运行，保存方法的局部变量（8种基本数据类型，对象的引用地址），部分结果，并参与方法的调用和返回。<ul>
<li>局部变量  vs  成员变量</li>
<li>基本数据类型   VS 引用类型变量（类，数组，接口）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="三，优点"><a href="#三，优点" class="headerlink" title="三，优点"></a>三，优点</h3><ul>
<li>快速有效的存储方式，访问速度仅次于程序计数器</li>
<li>JVM直接对JAVA栈的操作只有两个<ul>
<li>每个方法执行，伴随着进栈（入栈，压栈）</li>
<li>执行结束的出栈</li>
</ul>
</li>
<li>栈不存在垃圾回收，但是存在OOM<ul>
<li>Java栈大小是动态或者固定不变的。如果是动态扩展，无法申请到足够内存OOM，如果是固定，线程请求的栈容量超过固定值，则StackOverflowError</li>
</ul>
</li>
<li>使用-Xss (记忆：站着做一个小手术，栈Xss)，设置线程的最大栈空间</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699564776-39fc4cb1-666a-40b4-a166-880e9c394508.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u90d2de3a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=561&originWidth=1274&originalType=url&ratio=1&rotation=0&showTitle=false&size=311025&status=done&style=none&taskId=u83e4b353-90dd-495c-a6e8-2fc8b764856&title=" alt="image.png"></p>
<h3 id="四，栈的存储单位"><a href="#四，栈的存储单位" class="headerlink" title="四，栈的存储单位"></a>四，栈的存储单位</h3><ul>
<li>每个线程都有自己的栈，栈中的数据以栈帧格式存储</li>
<li>线程上正在执行的每个方法都各自对应一个栈帧</li>
<li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各个数据信息</li>
<li>先进后出，后进先出</li>
<li>一条活动的线程中，一个时间点上，只会有一个活动的栈帧。只有当前正在执行的方法的栈顶栈帧是有效的，这个称为当前栈帧，对应方法是当前方法，对应类是当前类</li>
<li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作</li>
<li>如果方法中调用了其他方法，对应的新的栈帧会被创建出来，放在顶端，成为新的当前帧</li>
</ul>
<h3 id="五，栈运行原理"><a href="#五，栈运行原理" class="headerlink" title="五，栈运行原理"></a>五，栈运行原理</h3><ul>
<li>不同线程中包含的栈帧不允许存在相互引用。</li>
<li>当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为新的栈帧。</li>
<li>Java方法有两种返回方式<ul>
<li>一种是正常的函数返回，使用return指令</li>
<li>另外一种是抛出异常，不管哪种方式，都会导致栈帧被弹出</li>
</ul>
</li>
</ul>
<h3 id="六，栈帧的内部结构"><a href="#六，栈帧的内部结构" class="headerlink" title="六，栈帧的内部结构"></a>六，栈帧的内部结构</h3><ul>
<li><p><strong>每个栈帧中存储着：</strong></p>
<ul>
<li><strong>局部变量表（Local Variables）</strong></li>
<li><strong>操作数栈（operand Stack）(或表达式栈)</strong></li>
<li><strong>动态链接(Dynamic Linking)(或指向运行时常量池的方法引用)</strong></li>
<li><strong>方法返回地址（Return  Address）(或方法正常退出或者异常退出的定义)</strong></li>
<li><strong>一些附加信息</strong></li>
</ul>
</li>
<li><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699579695-1232cb55-000a-49b1-a12b-69d10981e476.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u292dbd06&margin=%5Bobject%20Object%5D&name=image.png&originHeight=363&originWidth=1030&originalType=url&ratio=1&rotation=0&showTitle=false&size=103478&status=done&style=none&taskId=u3744c93c-198a-4362-8396-fb7bb447972&title=" alt="image.png"></p>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699579772-ddf5ad9e-baf9-4e0a-a8bd-5d4ae5deb81f.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ud5c91f53&margin=%5Bobject%20Object%5D&name=image.png&originHeight=634&originWidth=1131&originalType=url&ratio=1&rotation=0&showTitle=false&size=214087&status=done&style=none&taskId=u4daf5dc7-c544-47b5-88d0-c3638d36fa6&title=" alt="image.png"></p>
<h2 id="局部变量表（Local-variables）"><a href="#局部变量表（Local-variables）" class="headerlink" title="局部变量表（Local variables）"></a>局部变量表（Local variables）</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>局部变量表也被称为局部变量数组或本地变量表</p>
<ul>
<li>定义为一个数字数组，主要用于存储方法参数，定义在方法体内部的局部变量，数据类型包括各类基本数据类型，对象引用，以及return address类型</li>
<li>局部变量表建立在线程的栈上，是线程私有的，因此不存在数据安全问题</li>
<li>局部变量表容量大小是在编译期确定下来的</li>
<li>局部变量表存放编译期可知的各种基本数据类型（8种），引用类型（reference）,return address 类型</li>
<li>最基本的存储单元是slot（变量槽）<ul>
<li>32位占用一个slot，64位类型（long和double）占用两个slot</li>
</ul>
</li>
<li>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。</li>
<li>局部变量表中的变量只有在当前方法调用中有效，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。</li>
<li>方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁</li>
</ul>
<h3 id="关于Slot的理解"><a href="#关于Slot的理解" class="headerlink" title="关于Slot的理解"></a>关于Slot的理解</h3><ul>
<li><p>VM虚拟机会为局部变量表中的每个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</p>
</li>
<li><p>如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this，会存放在index为0的slot处，其余的参数表顺序继续排列</p>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699631312-edeab655-97ba-45d2-b79a-1e8294b04d2d.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u1f7aab09&margin=%5Bobject%20Object%5D&name=image.png&originHeight=482&originWidth=453&originalType=url&ratio=1&rotation=0&showTitle=false&size=68285&status=done&style=none&taskId=uc438e17a-f29d-41e9-aeb3-2663149746f&title=" alt="image.png"></p>
<p>this截图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699631460-7183af0a-0f0c-47cf-b2c4-02eba68d35e3.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u1b4dc68d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=493&originWidth=1429&originalType=url&ratio=1&rotation=0&showTitle=false&size=322071&status=done&style=none&taskId=u0907194c-83ff-4b61-a596-7466bf52b99&title=" alt="image.png"></p>
<ul>
<li>栈帧中的局部变量表中的槽位是可以重复的，如果一个局部变量过了其作用域，那么其作用域之后申明的新的局部变量就有可能会复用过期局部变量的槽位，从而达到节省资源的目的</li>
</ul>
<h2 id="操作数栈-Operand-Stack"><a href="#操作数栈-Operand-Stack" class="headerlink" title="操作数栈(Operand Stack)"></a>操作数栈(Operand Stack)</h2><h3 id="操作数栈（数组实现）："><a href="#操作数栈（数组实现）：" class="headerlink" title="操作数栈（数组实现）："></a>操作数栈（数组实现）：</h3><ul>
<li><p>在方法执行的过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈&#x2F;出栈</p>
<ul>
<li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈，使用它们后再将结果压入栈</li>
<li>比如：执行复制、交换、求和等操作</li>
</ul>
</li>
<li><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699685117-193b192e-d1ff-48ae-8b75-25b5d61b4677.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u88048f45&margin=%5Bobject%20Object%5D&name=image.png&originHeight=211&originWidth=643&originalType=url&ratio=1&rotation=0&showTitle=false&size=46452&status=done&style=none&taskId=u9556b129-d22f-4901-a1a7-3aa870b3554&title=" alt="image.png"></p>
</li>
<li><p>如果被调用方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新程序计数器中下一条需要执行的字节码指令</p>
</li>
<li><p>Java虚拟机的解释引擎是基于栈的执行引擎，其中栈就是操作数栈</p>
</li>
<li><p>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</p>
</li>
<li><p>当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的</p>
</li>
<li><p>每一个操作数栈会拥有一个明确的栈深度，用于存储数值，最大深度在编译期就定义好</p>
</li>
<li><p>栈中，32bit类型占用一个栈单位深度，64bit类型占用两个栈单位深度</p>
</li>
<li><p>操作数栈并非采用访问索引方式进行数据访问，而是只能通过标准的入栈、出栈操作完成一次数据访问</p>
</li>
</ul>
<h3 id="栈顶缓存技术："><a href="#栈顶缓存技术：" class="headerlink" title="栈顶缓存技术："></a>栈顶缓存技术：</h3><ul>
<li>由于操作数是存储在内存中，频繁的进行内存读写操作影响执行速度，将栈顶元素全部缓存到物理CPU的寄存器中，依此降低对内存的读写次数，提升执行引擎的执行效率</li>
</ul>
<h2 id="动态链接（或指向运行时常量池的方法引用）"><a href="#动态链接（或指向运行时常量池的方法引用）" class="headerlink" title="动态链接（或指向运行时常量池的方法引用）"></a>动态链接（或指向运行时常量池的方法引用）</h2><h3 id="指向运行时常量池的方法引用"><a href="#指向运行时常量池的方法引用" class="headerlink" title="指向运行时常量池的方法引用"></a>指向运行时常量池的方法引用</h3><ul>
<li>每一个栈帧内部都包含一个指向运行时常量池中，该帧所属方法的引用</li>
<li>目的是为了支持当前方法的代码能够实现动态链接，比如invokedynamic指令</li>
<li>在java源文件被编译成字节码文件中时，所有的变量、方法引用都作为符号引用，保存在class文件的常量池中。</li>
<li>描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的。</li>
<li>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</li>
<li><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699736179-dcc1544a-d902-4485-8f0f-8fdc87ea266a.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=udcdb452a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=554&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&size=177438&status=done&style=none&taskId=u037a2d80-078c-4480-9f04-34ef32b8d47&title=" alt="image.png"></li>
</ul>
<h3 id="常量池、运行时常量池"><a href="#常量池、运行时常量池" class="headerlink" title="常量池、运行时常量池"></a>常量池、运行时常量池</h3><ul>
<li>常量池在字节码文件中，运行时常量池，在运行时的方法区中</li>
</ul>
<h2 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h2><h3 id="一，链接与方法的绑定"><a href="#一，链接与方法的绑定" class="headerlink" title="一，链接与方法的绑定"></a>一，链接与方法的绑定</h3><ul>
<li>静态链接<ul>
<li>当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行时期间保持不变，这种情况下降调用方的符号引用转为直接引用的过程称为静态链接</li>
</ul>
</li>
<li>动态链接<ul>
<li>如果被调用的方法无法再编译期被确定下来，只能在运行期将调用的方法的符号引用转为直接引用，这种引用转换过程具备动态性，因此被称为动态链接</li>
</ul>
</li>
<li>方法的绑定<ul>
<li>绑定是一个字段、方法、或者类在符号引用被替换为直接引用的过程。仅仅发生一次。</li>
<li>早期绑定<ul>
<li>被调用的目标方法如果在编译期可知，且运行期保持不变</li>
</ul>
</li>
<li>晚期绑定<ul>
<li>被调用的方法在编译期无法被确定，只能够在程序运行期根据实际的类型绑定相关的方法。</li>
</ul>
</li>
</ul>
</li>
<li>Java中任何一个普通方法都具备虚函数的特征（运行期确认，具备晚期绑定的特点），C++中则使用关键字virtual来显式定义</li>
<li>如果在java程序中，不希望某个方法拥有虚函数的特征，则可以使用关键字final来标记这个方法</li>
</ul>
<h3 id="二，虚方法和非虚方法"><a href="#二，虚方法和非虚方法" class="headerlink" title="二，虚方法和非虚方法"></a>二，虚方法和非虚方法</h3><ul>
<li>非虚方法<ul>
<li>如果方法在编译期就确定了具体的调用版本，则这个版本在运行时是不可变的。这样的方法称为非虚方法，静态方法，私有方法，final方法，实例构造器，父类方法都是非虚方法</li>
</ul>
</li>
<li>其他方法称为虚方法</li>
</ul>
<h3 id="三，方法调用指令"><a href="#三，方法调用指令" class="headerlink" title="三，方法调用指令"></a>三，方法调用指令</h3><ul>
<li>普通调用指令<ul>
<li>invokestatic<ul>
<li>调用静态方法，解析阶段确定唯一方法版本</li>
</ul>
</li>
<li>invokespecial<ul>
<li>调用<init>方法，私有及父类方法，解析阶段确定唯一方法版本</li>
</ul>
</li>
<li>invokevirtual<ul>
<li>调用所有虚方法（除了final修饰的）</li>
</ul>
</li>
<li>invokeinterface<ul>
<li>调用接口方法</li>
</ul>
</li>
<li>其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法</li>
</ul>
</li>
<li>动态调用指令JDK1.7新增<ul>
<li>invokedynamic<ul>
<li>动态解析出需要调用的方法，然后执行</li>
</ul>
</li>
<li>直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式</li>
</ul>
</li>
<li>静态语言和动态语言<ul>
<li>区别在于对类型的检查是编译器还是运行期，满足编译期就是静态类型语言，反之就是动态类型语言。</li>
<li>Java是静态类型语言，动态调用指令增加了动态语言的特性</li>
</ul>
</li>
</ul>
<h3 id="四，方法重写的本质"><a href="#四，方法重写的本质" class="headerlink" title="四，方法重写的本质"></a>四，方法重写的本质</h3><ul>
<li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记做C</li>
<li>如果在类型C中找到与常量池中描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束，如果不通过，则返回java.lang.IllegalAccessError异常</li>
<li>否则，按照继承关系从下往上依次对C的各个父类进行上一步的搜索和验证过程。</li>
<li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常</li>
</ul>
<h3 id="五，虚方法表"><a href="#五，虚方法表" class="headerlink" title="五，虚方法表"></a>五，虚方法表</h3><ul>
<li>面向对象的编程中，会很频繁的使用动态分配，如果每次动态分配的过程都要重新在类的方法元数据中搜索合适的目标的话，就可能影响到执行效率，因此为了提高性能，JVM采用在类的方法区建立一个虚方法表，使用索引表来代替查找</li>
<li>每个类都有一个虚方法表，表中存放着各个方法的实际入口</li>
<li>虚方法表会在类加载的链接阶段被创建，并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法也初始化完毕</li>
<li><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699770979-268cf4d1-9763-4177-a066-f02bb4685d71.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u724d7bd0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=624&originWidth=992&originalType=url&ratio=1&rotation=0&showTitle=false&size=335789&status=done&style=none&taskId=u04a429d1-ef3c-4d67-b152-e691c688f8f&title=" alt="image.png"></li>
</ul>
<h2 id="方法返回地址及栈的面试题"><a href="#方法返回地址及栈的面试题" class="headerlink" title="方法返回地址及栈的面试题"></a>方法返回地址及栈的面试题</h2><h3 id="一，方法返回地址"><a href="#一，方法返回地址" class="headerlink" title="一，方法返回地址"></a>一，方法返回地址</h3><ul>
<li>存放调用该方法的pc寄存器的值</li>
<li>方法的结束<ul>
<li>正常执行完成</li>
<li>出现未处理异常，非正常退出</li>
</ul>
</li>
<li>无论哪种方式退出，方法退出后，都会返回该方法被调用的位置。方法正常退出时，调用者的PC计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。</li>
<li>异常退出的，返回地址是通过异常表来确定，栈帧中一般不会保存这部分信息</li>
<li>执行引擎遇到任意一个方法返回的字节码指令（return）,会有返回值传递给上层的方法调用者，简称正常完成出口<ul>
<li>返回指令包括<ul>
<li>ireturn返回值是boolean，byte，char，short，和int类型时使用</li>
<li>lreturn</li>
<li>dreturn</li>
<li>areturn<ul>
<li>引用类型</li>
</ul>
</li>
<li>还有一个return指供声明为 void的方法、实例初始化方法、类和接口的初始化方法使用</li>
</ul>
</li>
</ul>
</li>
<li>本质上，方法的退出就是当前栈帧出栈的过程。此时需要恢复上层方法的局部变量表，操作数栈，将返回值压入调用者栈帧的操作数栈，设置PC寄存器值等，让调用者方法继续执行下去。</li>
<li>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值</li>
</ul>
<h3 id="二，一些附加信息"><a href="#二，一些附加信息" class="headerlink" title="二，一些附加信息"></a>二，一些附加信息</h3><ul>
<li>允许携带与Java虚拟机实现相关的一些附加信息，例如对程序调试提供支持的信息。不确定有，可选情况</li>
</ul>
<h3 id="三，面试题"><a href="#三，面试题" class="headerlink" title="三，面试题"></a>三，面试题</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699816203-dfaa7c1f-4481-4c4f-9606-05a87c1e1cd2.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua916ea76&margin=%5Bobject%20Object%5D&name=image.png&originHeight=320&originWidth=787&originalType=url&ratio=1&rotation=0&showTitle=false&size=104013&status=done&style=none&taskId=udf9816f3-831c-45cb-b277-1cfd6fe5a11&title=" alt="image.png"></p>
<h2 id="⭐本地方法接口与本地方法栈"><a href="#⭐本地方法接口与本地方法栈" class="headerlink" title="⭐本地方法接口与本地方法栈"></a>⭐本地方法接口与本地方法栈</h2><h3 id="一，本地方法接口"><a href="#一，本地方法接口" class="headerlink" title="一，本地方法接口"></a>一，本地方法接口</h3><ul>
<li>什么是本地方法<ul>
<li>简单讲，就是一个Java调用非Java代码的接口</li>
</ul>
</li>
<li>为什么使用native method<ul>
<li>与Java环境外交互<ul>
<li>例如与操作系统底层或硬件交换信息时的情况</li>
<li>例如启动一个线程</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="二，本地方法栈"><a href="#二，本地方法栈" class="headerlink" title="二，本地方法栈"></a>二，本地方法栈</h3><ul>
<li>Java虚拟机栈管理Java方法的调用，而本地方法栈用于管理本地方法的调用</li>
<li>本地方法栈，也是线程私有的。</li>
<li>允许被实现成固定或者是可动态扩展的内存大小。<ul>
<li>内存溢出情况和Java虚拟机栈相同</li>
</ul>
</li>
<li>使用C语言实现</li>
<li>具体做法是Native Method Stack 中登记native方法，在Execution Engine执行时加载到本地方法库</li>
<li>当某个线程调用一个本地方法时，就会进入一个全新，不受虚拟机限制的世界，它和虚拟机拥有同样的权限。</li>
<li>并不是所有的JVM都支持本地方法，因为Java虚拟机规范并没有明确要求本地方法栈的使用语言，具体实现方式，数据结构等</li>
<li>Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一</li>
</ul>
<h2 id="⭐堆"><a href="#⭐堆" class="headerlink" title="⭐堆"></a>⭐堆</h2><h3 id="一，堆的核心概念"><a href="#一，堆的核心概念" class="headerlink" title="一，堆的核心概念"></a>一，堆的核心概念</h3><ul>
<li>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域</li>
<li>Java堆区在JVM启动的时候即被创建，其空间大小也就确认了。堆内存的大小是可调节的</li>
<li>Java虚拟机规范规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</li>
<li><strong>所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（TLAB）</strong></li>
<li>“几乎”所有的对象实例都在这里分配内存</li>
<li>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，引用指向对象或者数组在堆中的位置</li>
<li>方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</li>
<li>堆是GC执行垃圾回收的重点区域</li>
<li>堆空间细分为：<ul>
<li>Java7及之前<ul>
<li>内存逻辑上分为：<ul>
<li>新生区<ul>
<li>Eden区（伊甸园区）</li>
<li>Survivor区（幸存者区）<ul>
<li>from</li>
<li>to<ul>
<li>谁空谁是to</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>养老区</li>
<li>永久区</li>
</ul>
</li>
</ul>
</li>
<li>Java8及之后<ul>
<li>内存逻辑上分为：<ul>
<li>新生区<ul>
<li>Eden区</li>
<li>Survivor区<ul>
<li>from</li>
<li>to<ul>
<li>谁空谁是to</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>养老区</li>
<li>元空间</li>
</ul>
</li>
</ul>
</li>
<li>约定<ul>
<li>新生区&#x3D;&#x3D;新生代&#x3D;&#x3D;年轻代</li>
<li>养老区&#x3D;&#x3D;老年区&#x3D;&#x3D;老年代</li>
<li>永久区&#x3D;&#x3D;永久代</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699890317-38196b21-ac49-48e3-abcf-1a0a2052dae1.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uead3a694&margin=%5Bobject%20Object%5D&name=image.png&originHeight=529&originWidth=987&originalType=url&ratio=1&rotation=0&showTitle=false&size=137359&status=done&style=none&taskId=u0b48d8cf-0ef7-4382-938d-a888a294402&title=" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699890485-bf6d64fc-7567-44df-9a9a-1c72ebf643b0.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u0dcfe437&margin=%5Bobject%20Object%5D&name=image.png&originHeight=609&originWidth=1168&originalType=url&ratio=1&rotation=0&showTitle=false&size=404260&status=done&style=none&taskId=uf6e5294b-db7a-4ea4-9aaf-75cf031333f&title=" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699890279-fac113a1-41f1-43d3-a751-e370e5a83488.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=udb2113fc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=339&originWidth=596&originalType=url&ratio=1&rotation=0&showTitle=false&size=91261&status=done&style=none&taskId=ue7cee9cf-a8a9-4852-b92e-69d7fb956eb&title=" alt="image.png"></p>
<h3 id="二，设置堆内存大小与OOM"><a href="#二，设置堆内存大小与OOM" class="headerlink" title="二，设置堆内存大小与OOM"></a>二，设置堆内存大小与OOM</h3><ul>
<li>-Xms ：小秘书表示堆空间的起始内存。</li>
<li>-Xmx：小明星表示堆空间的最大内存<ul>
<li>超过最大内存将抛出OOM</li>
</ul>
</li>
<li><strong>通常将-Xms和-Xmx两个参数配置相同的值，其目的是为了能够在java垃圾会后清理完堆区后，不需要重新分隔计算堆区的大小，从而提高性能</strong></li>
<li><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699905303-c1cc8471-99c4-4196-aece-2b0af01803fa.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u37429759&margin=%5Bobject%20Object%5D&name=image.png&originHeight=108&originWidth=672&originalType=url&ratio=1&rotation=0&showTitle=false&size=46206&status=done&style=none&taskId=u9e967fc3-a17a-4b3b-a3b8-3ec861d80e8&title=" alt="image.png"></li>
<li></li>
<li><strong>代码：</strong></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699905518-a79b2777-758e-4067-b0d9-b64c2c27c343.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u83353842&margin=%5Bobject%20Object%5D&name=image.png&originHeight=444&originWidth=1197&originalType=url&ratio=1&rotation=0&showTitle=false&size=390653&status=done&style=none&taskId=u3614caa3-0e2d-43fa-be27-c33f21f0839&title=" alt="image.png"></p>
<ul>
<li><p>jps命令</p>
<ul>
<li>查看当前程序运行的进程</li>
</ul>
</li>
<li><p>jstat</p>
<ul>
<li>查看JVM在gc时的统计信息<ul>
<li>jstat -gc 进程号</li>
</ul>
</li>
</ul>
</li>
<li><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650699905311-f227ea29-13d3-4496-aae2-eb11bb0e3054.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u6a245d68&margin=%5Bobject%20Object%5D&name=image.png&originHeight=81&originWidth=600&originalType=url&ratio=1&rotation=0&showTitle=false&size=41272&status=done&style=none&taskId=ubd01b523-ed83-4105-8504-76f903e16ce&title=" alt="image.png"></p>
</li>
</ul>
<h3 id="三，年轻代与老年代"><a href="#三，年轻代与老年代" class="headerlink" title="三，年轻代与老年代"></a>三，年轻代与老年代</h3><ul>
<li>-XX:NewRatio&#x3D;2，表示新生代占1，老年代占2，新生代占整个堆的1&#x2F;3<ul>
<li>ratio：比率比例的意思</li>
</ul>
</li>
<li>jinfo -flag NewRatio 进程号，查看参数设定值</li>
<li>在HotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是：8:1:1<ul>
<li>-XX:SurvivorRatio调整这个空间比例<ul>
<li>Eden与Survivor区的比例</li>
</ul>
</li>
<li>实际是6:1:1，因为有自适应机制<ul>
<li>-XX:-UseAdaptiveSizePolicy：-表示关闭自适应，实际没有用。直接用Ratio分配即可</li>
</ul>
</li>
</ul>
</li>
<li>几乎所有的Java对象都是在Eden区被new出来的。<ul>
<li>Eden放不了的大对象，直接进入老年代了。</li>
</ul>
</li>
<li>IBM研究表明，新生代80%的对象都是朝生夕死</li>
<li>-Xmn：洗面奶，设置新生代最大内存大小，如果同时设置了新生代比例与此参数冲突，则以此参数为准。</li>
</ul>
<h3 id="四，图解对象分配一般过程"><a href="#四，图解对象分配一般过程" class="headerlink" title="四，图解对象分配一般过程"></a>四，图解对象分配一般过程</h3><ul>
<li>1、new的对象先放在Eden区，此区有大小限制</li>
<li>2、当创建新对象，<strong>Eden空间填满时，会触发Minor GC</strong>，将Eden不再被其他对象引用的对象进行销毁。再加载新的对象放到Eden区</li>
<li>3、将Eden中剩余的对象移到幸存者0区</li>
<li>4、再次触发垃圾回收，此时上次幸存者下来的，放在幸存者0区的，如果没有回收，就会放到幸存者1区</li>
<li>5、再次经历垃圾回收，又会将幸存者重新放回幸存者0区，依次类推</li>
<li>6、可以设置一个次数，默认是15次，超过15次，则会将幸存者区幸存下来的转去老年区<ul>
<li>-XX:MaxTenuringThreshold&#x3D;N进行设置</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700009211-c51e14d4-f36f-406a-bb50-a920c8df2338.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ucb93d5db&margin=%5Bobject%20Object%5D&name=image.png&originHeight=761&originWidth=1001&originalType=url&ratio=1&rotation=0&showTitle=false&size=253292&status=done&style=none&taskId=ufd7f2dd9-4b02-4382-ac66-37b29c8c1a0&title=" alt="image.png"></p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul>
<li><strong>针对幸存者s0，s1区的总结：复制之后有交换，谁空谁是to</strong></li>
<li><strong>频繁在新生区收集，很少在养老区收集，几乎不在永久区&#x2F;元空间搜集</strong></li>
</ul>
<p>对象分配特殊过程：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700009211-bed9e395-7313-41a7-99b2-176559159f86.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u5d8ef843&margin=%5Bobject%20Object%5D&name=image.png&originHeight=649&originWidth=804&originalType=url&ratio=1&rotation=0&showTitle=false&size=259251&status=done&style=none&taskId=u00425c32-832d-4365-ae71-8b02f1fae83&title=" alt="image.png"></p>
<ul>
<li><strong>触发YGC，幸存者区就会进行回收，不会主动进行回收</strong></li>
<li><strong>超大对象eden放不下，就要看Old区大小是否可以放下</strong><ul>
<li><strong>old区也放不下，需要FullGC（MajorGC），这两GC概念还是有区别的。下面详解</strong></li>
</ul>
</li>
</ul>
<h2 id="MinorGC，MajorGC，FullGC"><a href="#MinorGC，MajorGC，FullGC" class="headerlink" title="MinorGC，MajorGC，FullGC"></a>MinorGC，MajorGC，FullGC</h2><h3 id="一，MinorGC，MajorGC，FullGC"><a href="#一，MinorGC，MajorGC，FullGC" class="headerlink" title="一，MinorGC，MajorGC，FullGC"></a>一，MinorGC，MajorGC，FullGC</h3><ul>
<li>针对HotSpotVM的实现<ul>
<li>GC按照内存回收区域分为<ul>
<li>部分收集<ul>
<li>新生代收集<ul>
<li>MinorGC （YoungGC）</li>
</ul>
</li>
<li>老年代收集<ul>
<li>MajorGC&#x2F;oldGC<ul>
<li>目前只有CMS GC会单独收集老年代的行为</li>
<li>很多时候MajorGC与FullGC混淆使用，具体分辨是老年代回收还是整堆回收</li>
</ul>
</li>
</ul>
</li>
<li>混合收集<ul>
<li>收集整个新生代以及部分老年代的垃圾收集<ul>
<li>目前只有G1 GC会有这种行为</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>整堆收集<ul>
<li>收集整个Java堆和方法区的垃圾收集</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="二，MinorGC的触发条件"><a href="#二，MinorGC的触发条件" class="headerlink" title="二，MinorGC的触发条件"></a>二，MinorGC的触发条件</h3><ul>
<li>当年轻代空间不足时，就会触发MinorGC，这里的年轻代指的是Eden代满，Survivor满不会触发GC。每次MinorGC会清理年轻代的内存</li>
<li>因为Java对象大多朝生夕灭，所以MinorGC非常频繁<ul>
<li>Minor翻译，较小的，未成年的</li>
</ul>
</li>
<li>MinorGC会引发STW</li>
</ul>
<h3 id="三，老年代GC（MajorGC-x2F-FullGC）触发条件"><a href="#三，老年代GC（MajorGC-x2F-FullGC）触发条件" class="headerlink" title="三，老年代GC（MajorGC&#x2F;FullGC）触发条件"></a>三，老年代GC（MajorGC&#x2F;FullGC）触发条件</h3><ul>
<li>指发生在老年代的GC，对象从老年代消失，我们说“MajorGC”“FullGC”发生了</li>
<li>出现了MajorGC，经常会伴随至少一次MinorGC<ul>
<li>非绝对，在Parallel Scavenge收集器的收集策略里就直接进行MajorGC的策略选择过程</li>
<li>也就是老年代空间不足，会先尝试触发MinorGC，如果之后空间还不足，则触发MajorGC</li>
</ul>
</li>
<li>MajorGC的速度比MinorGC慢10倍以上，STW的时间更长</li>
<li>如果MajorGC后，内存还不足，就报OOM了</li>
</ul>
<h3 id="四，FullGC的触发机制"><a href="#四，FullGC的触发机制" class="headerlink" title="四，FullGC的触发机制"></a>四，FullGC的触发机制</h3><ul>
<li>1、调用System.gc()时，系统建议执行FullGC，但是不必然执行</li>
<li>2、老年代空间不足</li>
<li>3、方法区空间不足</li>
<li>4、通过MinorGC后进入老年代的平均大小，大于老年代的可用内存</li>
<li>5、由Eden区，Survivor 0区向Survivor 1区复制时，对象的大小大于ToSpace可用内存，则把改对象转存到老年代，且老年代的可用内存小于该对象的大小</li>
<li>FullGC是开发或调优中尽量要避免的，这样暂停时间会短一些。</li>
</ul>
<h2 id="堆空间分代思想、内存分配策略"><a href="#堆空间分代思想、内存分配策略" class="headerlink" title="堆空间分代思想、内存分配策略"></a>堆空间分代思想、内存分配策略</h2><h3 id="一，堆空间分代思想"><a href="#一，堆空间分代思想" class="headerlink" title="一，堆空间分代思想"></a>一，堆空间分代思想</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700116760-2593405d-ee21-494a-9a58-7519d8d72e08.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uf8d7b78e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=534&originWidth=1143&originalType=url&ratio=1&rotation=0&showTitle=false&size=263007&status=done&style=none&taskId=u1cd52902-79d3-4443-bbdb-9c22dd1eb55&title=" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700116991-edb01ec4-3012-44f2-b774-d2fde449fce5.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u8f1bc4da&margin=%5Bobject%20Object%5D&name=image.png&originHeight=579&originWidth=1065&originalType=url&ratio=1&rotation=0&showTitle=false&size=343299&status=done&style=none&taskId=ua3ab0d47-3974-414c-8314-e30eda739c7&title=" alt="image.png"></p>
<h3 id="二，内存分配策略"><a href="#二，内存分配策略" class="headerlink" title="二，内存分配策略"></a>二，内存分配策略</h3><ul>
<li>如果对象再Eden出生并经过第一次MinorGC后仍然存活，并且能被Survivor区容纳，则被移动到Survivor空间中，并将对象年龄设置为1，对象再Survivor区每熬过一次MinorGC，年龄就+1，当年龄增加到一定程度（默认为15，不同Jvm，GC都所有不同）时，就会被晋升到老年代中<ul>
<li>-XX:MaxTenuringThreshold</li>
</ul>
</li>
<li>优先分配到Eden</li>
<li>大对象直接分配到老年代<ul>
<li>尽量避免程序中出现过多的大对象</li>
</ul>
</li>
<li>长期存活的对象分配到老年代</li>
<li>动态对象年龄分配<ul>
<li>如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄</li>
</ul>
</li>
</ul>
<h3 id="三，空间分配担保"><a href="#三，空间分配担保" class="headerlink" title="三，空间分配担保"></a>三，空间分配担保</h3><ul>
<li>-XX:HandlePromotionFailure</li>
<li>在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间，是否大于新生代所有对象的总空间<ul>
<li>如果大于，则此次MinorGC是安全的</li>
<li>如果小于，则查看-XX:HandlePromotionFailure设置是否允许担保失败<ul>
<li>true<ul>
<li>会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小</li>
<li>大于，则尝试进行一次MinorGC，但是这次MinorGC依然是有风险的</li>
<li>小于，则改为进行一次FullGC</li>
</ul>
</li>
<li>false<ul>
<li>则改为进行一次FullGC</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>jdk6update24之后，这个参数不会再影响到虚拟机的空间分配担保策略。<ul>
<li>规则改为只要老年代的连续空间大于新生代对象总大小，或者历次晋升的平均大小，就会进行MinorGC</li>
<li>否则进行FullGC</li>
</ul>
</li>
</ul>
<h3 id="四，为对象分配内存：TLAB"><a href="#四，为对象分配内存：TLAB" class="headerlink" title="四，为对象分配内存：TLAB"></a>四，为对象分配内存：TLAB</h3><h4 id="为什么有TLAB（Thread-Local-Allocation-Buffer）？"><a href="#为什么有TLAB（Thread-Local-Allocation-Buffer）？" class="headerlink" title="为什么有TLAB（Thread Local Allocation Buffer）？"></a>为什么有TLAB（Thread Local Allocation Buffer）？</h4><ol>
<li>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据 </li>
<li>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的 </li>
<li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</li>
</ol>
<h4 id="什么是TLAB？"><a href="#什么是TLAB？" class="headerlink" title="什么是TLAB？"></a>什么是TLAB？</h4><ol>
<li>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。 </li>
<li>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。 </li>
<li>据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700144566-d6e48744-3803-4e09-8997-7f7f239736ae.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u3592e483&margin=%5Bobject%20Object%5D&name=image.png&originHeight=517&originWidth=903&originalType=url&ratio=1&rotation=0&showTitle=false&size=68242&status=done&style=none&taskId=u7ad1c4aa-8cd6-4c15-aaca-3ada7ffbde6&title=" alt="image.png"></p>
<h4 id="TLAB的再说明"><a href="#TLAB的再说明" class="headerlink" title="TLAB的再说明"></a>TLAB的再说明</h4><ol>
<li>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。 </li>
<li>在程序中，开发人员可以通过选项“-XX:UseTLAB”设置是否开启TLAB空间。 </li>
<li>默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项 “-XX:TLABWasteTargetPercent” 设置TLAB空间所占用Eden空间的百分比大小。 </li>
<li>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700144670-59dcfa44-dbd1-40cd-8368-2cf9b42fa0fe.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua6454fb5&margin=%5Bobject%20Object%5D&name=image.png&originHeight=487&originWidth=1048&originalType=url&ratio=1&rotation=0&showTitle=false&size=163864&status=done&style=none&taskId=u9fa9e5f2-2530-45b5-85bf-96748dc053b&title=" alt="image.png"></p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>五，小结：堆空间的参数设置<br>官网地址：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html</a><br><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700180501-3c2a7bdf-4090-4cde-8a10-ba1f2e4b65c8.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u3d74fa17&margin=%5Bobject%20Object%5D&name=image.png&originHeight=436&originWidth=978&originalType=url&ratio=1&rotation=0&showTitle=false&size=118140&status=done&style=none&taskId=uee763d54-e553-467e-b06f-f13c5f98775&title=" alt="image.png"></p>
<ul>
<li><p>在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。</p>
</li>
<li><p>如果大于，则此次Minor GC是安全的</p>
</li>
<li><p>如果小于，则虚拟机会查看-XX:HandlePromotionFailure设置值是否允担保失败。 </p>
<ul>
<li>如果HandlePromotionFailure&#x3D;true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。 <ul>
<li>如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；</li>
<li>如果小于，则改为进行一次Full GC。</li>
</ul>
</li>
<li>如果HandlePromotionFailure&#x3D;false，则改为进行一次Full Gc。</li>
</ul>
</li>
<li><p>在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行FullGC。</p>
</li>
</ul>
<h2 id="堆补充"><a href="#堆补充" class="headerlink" title="堆补充"></a>堆补充</h2><p><strong>堆是分配对象的唯一选择么？</strong></p>
<ul>
<li>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</li>
<li>随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</li>
<li>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配.。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</li>
<li>此外，前面提到的基于OpenJDK深度定制的TaoBaoVM，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</li>
</ul>
<h3 id="一，逃逸分析概述"><a href="#一，逃逸分析概述" class="headerlink" title="一，逃逸分析概述"></a>一，逃逸分析概述</h3><ul>
<li><p>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</p>
</li>
<li><p>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</p>
</li>
<li><p>通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p>
</li>
<li><p>逃逸分析的基本行为就是分析对象动态作用域：</p>
</li>
<li><p>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</p>
</li>
<li><p>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</p>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700228524-69b4c439-98a9-460b-98ae-7cfed82d8951.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua1c3121b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1143&originWidth=1026&originalType=url&ratio=1&rotation=0&showTitle=false&size=95391&status=done&style=none&taskId=u3f235879-49e9-433b-8a64-c3fa28f1a31&title=" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700228531-a5cdc677-2e1a-4489-8a7f-f06896cf5455.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uf52d9bad&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1133&originWidth=1022&originalType=url&ratio=1&rotation=0&showTitle=false&size=95471&status=done&style=none&taskId=u0520db81-f79b-4575-b8e1-054858e4f34&title=" alt="image.png"></p>
<p>参数设置：</p>
<ul>
<li><p>在JDK 6u23 版本之后，HotSpot中默认就已经开启了逃逸分析</p>
</li>
<li><p>如果使用的是较早的版本，开发人员则可以通过：</p>
</li>
<li><p>选项“-XX:+DoEscapeAnalysis”显式开启逃逸分析</p>
</li>
<li><p>通过选项“-XX:+PrintEscapeAnalysis”查看逃逸分析的筛选结果</p>
</li>
<li><p><strong>结论：开发中能使用局部变量的，就不要使用在方法外定义。</strong></p>
</li>
</ul>
<h3 id="二，逃逸分析代码优化"><a href="#二，逃逸分析代码优化" class="headerlink" title="二，逃逸分析代码优化"></a>二，逃逸分析代码优化</h3><p>使用逃逸分析，编译器可以对代码做如下优化：</p>
<p>一、<strong>栈上分配</strong>：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</p>
<p>二、<strong>同步省略</strong>：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</p>
<p>三、<strong>分离对象或标量替换</strong>：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</p>
<h4 id="1-栈上分配"><a href="#1-栈上分配" class="headerlink" title="1.栈上分配"></a>1.栈上分配</h4><ul>
<li><p>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</p>
</li>
<li><p><strong>常见的栈上分配的场景：</strong></p>
<ul>
<li>在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传递。</li>
</ul>
</li>
</ul>
<h4 id="2-同步省略"><a href="#2-同步省略" class="headerlink" title="2.同步省略"></a>2.同步省略</h4><ul>
<li><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</p>
</li>
<li><p>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。</p>
</li>
<li><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700247509-773030b3-6b48-4879-b915-e5ba44858c0b.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uec37e248&margin=%5Bobject%20Object%5D&name=image.png&originHeight=738&originWidth=1033&originalType=url&ratio=1&rotation=0&showTitle=false&size=60525&status=done&style=none&taskId=u83ee98e5-ffbb-40ce-b461-4e9de022053&title=" alt="image.png"></p>
</li>
</ul>
<h4 id="3-标量替换"><a href="#3-标量替换" class="headerlink" title="3.标量替换"></a>3.标量替换</h4><ul>
<li><p><strong>标量（scalar）</strong>是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</p>
</li>
<li><p>相对的，那些还可以分解的数据叫做<strong>聚合量（Aggregate）</strong>，Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p>
</li>
<li><p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</p>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700247564-f9b162f3-1e14-4f19-9977-f0a342e2d8f9.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u653b9e42&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1003&originWidth=1042&originalType=url&ratio=1&rotation=0&showTitle=false&size=99794&status=done&style=none&taskId=uaebf011c-a7f7-485b-bed5-0a9f2615e76&title=" alt="image.png"></p>
<p>标量替换参数设置：</p>
<p>参数-XX:EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配到栈上。</p>
<p>上述代码在主函数中进行了1亿次alloc。调用进行对象创建，由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生GC。使用如下参数运行上述代码：<br>-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700247567-c48b0347-53f3-4f63-ab1c-91b696353fe4.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ub1e22248&margin=%5Bobject%20Object%5D&name=image.png&originHeight=377&originWidth=991&originalType=url&ratio=1&rotation=0&showTitle=false&size=83775&status=done&style=none&taskId=ubc526af2-244b-4133-82f7-48d1e5c76a0&title=" alt="image.png"></p>
<h3 id="三，逃逸分析小结：逃逸分析并不成熟"><a href="#三，逃逸分析小结：逃逸分析并不成熟" class="headerlink" title="三，逃逸分析小结：逃逸分析并不成熟"></a>三，逃逸分析小结：逃逸分析并不成熟</h3><ul>
<li>关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟。</li>
<li>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。 </li>
<li>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</li>
<li>虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。</li>
<li>注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，Oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。</li>
<li>目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。</li>
</ul>
<h2 id="⭐方法区"><a href="#⭐方法区" class="headerlink" title="⭐方法区"></a>⭐方法区</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700338333-b5e4f91e-7fd6-4be9-837a-d373e9cdefe8.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u1c58bbbd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=267&originWidth=963&originalType=url&ratio=1&rotation=0&showTitle=false&size=153776&status=done&style=none&taskId=u2b71e328-e6ae-4062-b9f2-d4098714b17&title=" alt="image.png"></p>
<h3 id="从线程共享与否的角度来看："><a href="#从线程共享与否的角度来看：" class="headerlink" title="从线程共享与否的角度来看："></a>从线程共享与否的角度来看：</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700338383-aec24b40-f04e-4a20-bfca-48d86e56e08d.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uf287de92&margin=%5Bobject%20Object%5D&name=image.png&originHeight=477&originWidth=972&originalType=url&ratio=1&rotation=0&showTitle=false&size=216667&status=done&style=none&taskId=u5147fca9-a6f2-4860-a664-c53c0ee2e4d&title=" alt="image.png"></p>
<h3 id="栈、堆、方法区的交互关系"><a href="#栈、堆、方法区的交互关系" class="headerlink" title="栈、堆、方法区的交互关系"></a>栈、堆、方法区的交互关系</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700338342-d43f300b-8738-4aac-a725-2f7313e47332.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u6678511d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=600&originWidth=1149&originalType=url&ratio=1&rotation=0&showTitle=false&size=180313&status=done&style=none&taskId=ua6ae8bce-9890-430c-a036-9b0d8618552&title=" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700366346-01164f3d-d87c-4b6f-b128-96d575c7e85f.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u1fb4e940&margin=%5Bobject%20Object%5D&name=image.png&originHeight=353&originWidth=1496&originalType=url&ratio=1&rotation=0&showTitle=false&size=45104&status=done&style=none&taskId=u2b637b31-09fe-4a76-8d4e-bed96955be9&title=" alt="image.png"></p>
<h2 id="方法区的理解"><a href="#方法区的理解" class="headerlink" title="方法区的理解"></a>方法区的理解</h2><h3 id="一，方法区在哪里？"><a href="#一，方法区在哪里？" class="headerlink" title="一，方法区在哪里？"></a>一，方法区在哪里？</h3><p>《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。</p>
<p>所以，方法区看作是一块独立于Java堆的内存空间。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700366404-6bdd380e-757f-40cd-bc7f-6c1fe2af155e.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u4bfe390d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=298&originWidth=805&originalType=url&ratio=1&rotation=0&showTitle=false&size=104775&status=done&style=none&taskId=u92b5807a-fde3-440d-ae97-fde32acd694&title=" alt="image.png"></p>
<h3 id="二，方法区的基本理解"><a href="#二，方法区的基本理解" class="headerlink" title="二，方法区的基本理解"></a>二，方法区的基本理解</h3><ul>
<li>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。</li>
<li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</li>
<li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li>
<li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：java.lang.OutOfMemoryError: PermGen space 或者java.lang.OutOfMemoryError: Metaspace <ul>
<li>加载大量的第三方的jar包；Tomcat部署的工程过多（30~50个）；大量动态的生成反射类</li>
</ul>
</li>
<li>关闭JVM就会释放这个区域的内存。</li>
</ul>
<h3 id="三，HotSpot中方法区的演进"><a href="#三，HotSpot中方法区的演进" class="headerlink" title="三，HotSpot中方法区的演进"></a>三，HotSpot中方法区的演进</h3><p>在jdk7及以前，习惯上把方法区，称为永久代。jdk8开始，使用元空间取代了永久代。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700366373-0dccdc62-e1b5-4990-9886-f1b68cd0e3f2.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ufdb71da8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=74&originWidth=751&originalType=url&ratio=1&rotation=0&showTitle=false&size=28581&status=done&style=none&taskId=ub81d1a1c-236b-4bff-9eef-cc6eba27fbb&title=" alt="image.png"></p>
<p>本质上，方法区和永久代并不等价。仅是对hotspot而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEA JRockit &#x2F; IBM J9 中不存在永久代的概念。</p>
<p>现在来看，当年使用永久代，不是好的idea。导致Java程序更容易OOM（超过-XX:MaxPermsize上限）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700366472-92d8473f-5d9f-47e2-9513-db4f91b633cd.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ufe9613ab&margin=%5Bobject%20Object%5D&name=image.png&originHeight=617&originWidth=1188&originalType=url&ratio=1&rotation=0&showTitle=false&size=166902&status=done&style=none&taskId=u30e99f18-ebc8-4c7d-80cc-19aa12e6573&title=" alt="image.png"></p>
<p>而到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700366421-c7c92f21-cff9-4626-840d-0999ce91a50d.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ufbfccdd3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=273&originWidth=800&originalType=url&ratio=1&rotation=0&showTitle=false&size=86516&status=done&style=none&taskId=u33919bf4-9170-434d-b4b5-d5c0679ad33&title=" alt="image.png"></p>
<p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：<strong>元空间不在虚拟机设置的内存中，而是使用本地内存</strong></p>
<p>永久代、元空间二者并不只是名字变了，内部结构也调整了</p>
<p>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常</p>
<h2 id="设置方法区大小与OOM"><a href="#设置方法区大小与OOM" class="headerlink" title="设置方法区大小与OOM"></a>设置方法区大小与OOM</h2><p>方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。</p>
<h3 id="jdk7及以前"><a href="#jdk7及以前" class="headerlink" title="jdk7及以前"></a>jdk7及以前</h3><ul>
<li>通过来设置永久代初始分配空间。默认值是20.75M-XX:Permsize</li>
<li>通过来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M-XX:MaxPermsize</li>
<li>当JVM加载的类信息容量超过了这个值，会报异常OutOfMemoryError:PermGen space。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700440997-d3f3978e-cf7c-4216-8f22-cfb4c2c78676.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uc278d647&margin=%5Bobject%20Object%5D&name=image.png&originHeight=244&originWidth=651&originalType=url&ratio=1&rotation=0&showTitle=false&size=82156&status=done&style=none&taskId=u699bc77b-1d54-437c-aa00-645ebc6ae71&title=" alt="image.png"></p>
<h3 id="JDK8以后"><a href="#JDK8以后" class="headerlink" title="JDK8以后"></a>JDK8以后</h3><ul>
<li>元数据区大小可以使用参数 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize指定</li>
<li>默认值依赖于平台。windows下，-XX:MetaspaceSize&#x3D;21M -XX:MaxMetaspaceSize&#x3D;-1&#x2F;&#x2F;即没有限制。</li>
<li>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace</li>
<li>-XX:MetaspaceSize：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的-XX:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。</li>
<li>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值。</li>
</ul>
<p>举例1<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700441091-1d3b64bb-7aaf-4721-85a5-fd4a4f9ada55.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u944ac304&margin=%5Bobject%20Object%5D&name=image.png&originHeight=570&originWidth=1144&originalType=url&ratio=1&rotation=0&showTitle=false&size=245957&status=done&style=none&taskId=ubf5e2b60-75db-4182-96ec-46348bfeb1e&title=" alt="image.png"></p>
<p>举例2<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700441005-06849b1e-f1ea-459c-a0b4-a760b606e07c.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u1792e537&margin=%5Bobject%20Object%5D&name=image.png&originHeight=704&originWidth=932&originalType=url&ratio=1&rotation=0&showTitle=false&size=66479&status=done&style=none&taskId=uc1c9bd0c-5b7f-4f9f-b71e-80e38ec2ce3&title=" alt="image.png"></p>
<h3 id="如何解决这些OOM"><a href="#如何解决这些OOM" class="headerlink" title="如何解决这些OOM"></a>如何解决这些OOM</h3><ol>
<li>要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Eclipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow） </li>
<li>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GCRoots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GCRoots引用链的信息，就可以比较准确地定位出泄漏代码的位置。 </li>
<li>如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</li>
</ol>
<h2 id="方法区内部结构"><a href="#方法区内部结构" class="headerlink" title="方法区内部结构"></a>方法区内部结构</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700513450-2ae650d0-dfe2-4b08-8626-b2447e12c4a6.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uf476128c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=657&originWidth=1144&originalType=url&ratio=1&rotation=0&showTitle=false&size=306652&status=done&style=none&taskId=u7989ed2c-780a-46b9-801f-000d51447fc&title=" alt="image.png"></p>
<h3 id="一，方法区（Method-Area）存储什么？"><a href="#一，方法区（Method-Area）存储什么？" class="headerlink" title="一，方法区（Method Area）存储什么？"></a>一，方法区（Method Area）存储什么？</h3><p>《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：</p>
<p>“它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。”</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700513332-0b7a07fd-0e70-4c44-8ca0-85001d1cc729.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uc67e02b6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=191&originWidth=1058&originalType=url&ratio=1&rotation=0&showTitle=false&size=113172&status=done&style=none&taskId=u62ba79d6-bd68-4d33-aea6-8ad4a9b9f32&title=" alt="image.png"></p>
<h3 id="二，方法区的内部结构"><a href="#二，方法区的内部结构" class="headerlink" title="二，方法区的内部结构"></a>二，方法区的内部结构</h3><h4 id="类型信-息"><a href="#类型信-息" class="headerlink" title="类型信 息"></a>类型信 息</h4><ul>
<li>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：<ul>
<li>这个类型的完整有效名称（全名&#x3D;包名.类名）</li>
<li>这个类型直接父类的完整有效名（对于interface或是java.lang.object，都没有父类）</li>
<li>这个类型的修饰符（public，abstract，final的某个子集）</li>
<li>这个类型直接接口的一个有序列表</li>
</ul>
</li>
</ul>
<h4 id="域（Field）信息"><a href="#域（Field）信息" class="headerlink" title="域（Field）信息"></a>域（Field）信息</h4><ul>
<li><p>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</p>
</li>
<li><p>域的相关信息包括：域名称、域类型、域修饰符（public，private，protected，static，final，volatile，transient的某个子集）</p>
</li>
</ul>
<h4 id="方法（Method）信息"><a href="#方法（Method）信息" class="headerlink" title="方法（Method）信息"></a>方法（Method）信息</h4><ul>
<li>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：<ul>
<li>方法名称</li>
<li>方法的返回类型（或void）</li>
<li>方法参数的数量和类型（按顺序）</li>
<li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）</li>
<li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）</li>
<li>异常表（abstract和native方法除外） </li>
<li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li>
</ul>
</li>
</ul>
<h4 id="non-final的类变量"><a href="#non-final的类变量" class="headerlink" title="non-final的类变量"></a>non-final的类变量</h4><pre><code>  - 静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分
  - 类变量被类的所有实例共享，即使没有类实例时，你也可以访问它
</code></pre>
<h4 id="补充说明：全局常量（static-final）"><a href="#补充说明：全局常量（static-final）" class="headerlink" title="补充说明：全局常量（static final）"></a>补充说明：全局常量（static final）</h4><pre><code>  - 被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。
</code></pre>
<h3 id="三，运行时常量池-VS-常量池"><a href="#三，运行时常量池-VS-常量池" class="headerlink" title="三，运行时常量池 VS 常量池"></a>三，运行时常量池 VS 常量池</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700513611-6873c89b-82b4-47dc-ab4d-62150b75eff4.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ubc6948d2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=597&originWidth=1115&originalType=url&ratio=1&rotation=0&showTitle=false&size=516639&status=done&style=none&taskId=ua5c9f60d-2174-4c8c-9b5e-676faac53ce&title=" alt="image.png"></p>
<ul>
<li>方法区，内部包含了运行时常量池</li>
<li>字节码文件，内部包含了常量池</li>
<li>要弄清楚方法区，需要理解清楚ClassFile，因为加载类的信息都在方法区。</li>
<li>要弄清楚方法区的运行时常量池，需要理解清楚ClassFile中的常量池。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700513443-55653793-360c-46a2-bfeb-0aee394bd430.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uf5c99de9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=480&originWidth=958&originalType=url&ratio=1&rotation=0&showTitle=false&size=238229&status=done&style=none&taskId=u5409aed6-8343-4821-8a5a-b9c60b45eca&title=" alt="image.png"></p>
<p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外，还包含一项信息就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用</p>
<h4 id="为什么需要常量池？"><a href="#为什么需要常量池？" class="headerlink" title="为什么需要常量池？"></a>为什么需要常量池？</h4><p>一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700513346-68f46486-b206-4654-bbcf-0081f8f85517.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ud871e406&margin=%5Bobject%20Object%5D&name=image.png&originHeight=439&originWidth=1006&originalType=url&ratio=1&rotation=0&showTitle=false&size=78218&status=done&style=none&taskId=uc1bdb545-579a-486e-820c-8fc98de1ad4&title=" alt="image.png"></p>
<h4 id="常量池中有什么"><a href="#常量池中有什么" class="headerlink" title="常量池中有什么?"></a>常量池中有什么?</h4><p>击中常量池内存储的数据类型包括：</p>
<ul>
<li>数量值</li>
<li>字符串值</li>
<li>类引用</li>
<li>字段引用</li>
<li>方法引用</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700514061-6a82d1da-a547-4533-8360-5d8eb80a4c64.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u1f44ba79&margin=%5Bobject%20Object%5D&name=image.png&originHeight=538&originWidth=1018&originalType=url&ratio=1&rotation=0&showTitle=false&size=31853&status=done&style=none&taskId=uc0468192-2440-4f29-8280-abeca6ac7b7&title=" alt="image.png"></p>
<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>● 运行时常量池（Runtime Constant Pool）是方法区的一部分。<br>● 常量池表（Constant Pool Table）是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。<br>● 运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。<br>● JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。<br>● 运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。<br>● 运行时常量池，相对于Class文件常量池的另一重要特征是：具备动态性。<br>● 运行时常量池类似于传统编程语言中的符号表（symboltable），但是它所包含的数据却比符号表要更加丰富一些。<br>●当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OutOfMemoryError异常。</p>
<h2 id="方法区使用举例"><a href="#方法区使用举例" class="headerlink" title="方法区使用举例"></a>方法区使用举例</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700755023-e4857fbb-16d1-476e-ab53-8169b01930c8.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u085fa899&margin=%5Bobject%20Object%5D&name=image.png&originHeight=255&originWidth=552&originalType=url&ratio=1&rotation=0&showTitle=false&size=11872&status=done&style=none&taskId=u67b5d20b-4eaf-4f41-b8c2-89f711d9296&title=" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700755146-a4b69713-39d0-4cff-99e9-7560c38a0b4e.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ub24e4119&margin=%5Bobject%20Object%5D&name=image.png&originHeight=632&originWidth=1193&originalType=url&ratio=1&rotation=0&showTitle=false&size=245338&status=done&style=none&taskId=uea0db5ab-1ab1-4690-9867-e05a0f998c1&title=" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700755252-102238ba-4fd2-41d0-9cb6-a7d351fd01d5.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u3547fce8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=615&originWidth=1156&originalType=url&ratio=1&rotation=0&showTitle=false&size=309786&status=done&style=none&taskId=u5e6808a2-6c4a-4374-80db-57b1c6816eb&title=" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700755212-ce8ab711-7bae-4af9-a413-0e713eb7fb74.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ud4f35ef8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=626&originWidth=1187&originalType=url&ratio=1&rotation=0&showTitle=false&size=271950&status=done&style=none&taskId=u8c5e3cfe-93ea-4056-8904-12bd8dc44c4&title=" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700755221-5d73807e-4c5f-4902-964e-69caefe656da.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u418fb7ff&margin=%5Bobject%20Object%5D&name=image.png&originHeight=633&originWidth=1190&originalType=url&ratio=1&rotation=0&showTitle=false&size=294900&status=done&style=none&taskId=u8de45fb1-a8a3-4338-865c-10ba57827da&title=" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700756015-d4136a4e-bcf0-4a72-8a88-dc07fee50687.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u8de9a465&margin=%5Bobject%20Object%5D&name=image.png&originHeight=629&originWidth=1185&originalType=url&ratio=1&rotation=0&showTitle=false&size=273163&status=done&style=none&taskId=ua0d47ae3-9093-4fe6-b78b-370584ab2d6&title=" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700756318-c41d070f-7418-416e-a340-95fc294e4970.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u5da94d1c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=639&originWidth=1197&originalType=url&ratio=1&rotation=0&showTitle=false&size=261378&status=done&style=none&taskId=u61dd10a0-a34b-4732-8f17-bd2b5ccf474&title=" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700756468-411f1b03-8d90-4208-b6f3-c608696fba0b.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9e779eda&margin=%5Bobject%20Object%5D&name=image.png&originHeight=636&originWidth=1196&originalType=url&ratio=1&rotation=0&showTitle=false&size=294241&status=done&style=none&taskId=ub5a29c6a-598c-422e-980c-8d88d545308&title=" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700756677-f49e3b97-97e7-470c-8209-4c90770b964f.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u1e6d833c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=628&originWidth=1192&originalType=url&ratio=1&rotation=0&showTitle=false&size=297390&status=done&style=none&taskId=u129ce437-0ce5-46a0-92d5-fa58a09f903&title=" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700756791-c268a45b-b36a-43c9-a47c-0a1a92337df0.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ub6d02765&margin=%5Bobject%20Object%5D&name=image.png&originHeight=615&originWidth=1162&originalType=url&ratio=1&rotation=0&showTitle=false&size=285499&status=done&style=none&taskId=uc4144ef3-675d-482e-b998-da886b24499&title=" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700757339-9171830b-016b-4fda-85b5-1cb2006ff7c6.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9f7193d3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=627&originWidth=1182&originalType=url&ratio=1&rotation=0&showTitle=false&size=267677&status=done&style=none&taskId=ua4263390-eb0e-47dd-bd74-4c626a27a03&title=" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700758071-292a43c9-6068-43c7-a9fa-b4bc3a0fe443.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ucd342475&margin=%5Bobject%20Object%5D&name=image.png&originHeight=613&originWidth=1158&originalType=url&ratio=1&rotation=0&showTitle=false&size=347513&status=done&style=none&taskId=u6f03b005-99f8-44f9-b2bb-0584ab7dc89&title=" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700758254-3262792a-e413-459f-a102-8f0af5d57bd5.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u5b8ec141&margin=%5Bobject%20Object%5D&name=image.png&originHeight=619&originWidth=1173&originalType=url&ratio=1&rotation=0&showTitle=false&size=265921&status=done&style=none&taskId=u67418e40-91fc-4e82-bf42-a99def2c84a&title=" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700758329-fe1ed8e2-6cce-4830-91b5-2f55ae2567a0.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ue8031870&margin=%5Bobject%20Object%5D&name=image.png&originHeight=623&originWidth=1184&originalType=url&ratio=1&rotation=0&showTitle=false&size=290143&status=done&style=none&taskId=ubef80249-80de-4045-8910-f065ee4e515&title=" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700758538-6aac9bca-4627-4a43-9b68-a91b9e768cda.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u8995a338&margin=%5Bobject%20Object%5D&name=image.png&originHeight=685&originWidth=1290&originalType=url&ratio=1&rotation=0&showTitle=false&size=344488&status=done&style=none&taskId=u248dd826-9d0e-4ee8-a0e7-6e608ce9fcf&title=" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700758853-90b998cb-a11e-433e-852c-e63d4a2a7eb0.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ubbf1cc9d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=690&originWidth=1310&originalType=url&ratio=1&rotation=0&showTitle=false&size=443139&status=done&style=none&taskId=u3cf83831-2142-4d30-9e40-d97e6a85177&title=" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700759641-28355c60-8d0a-4b0d-ae79-8d05df3ec8c5.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uacf598d2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=637&originWidth=1195&originalType=url&ratio=1&rotation=0&showTitle=false&size=297008&status=done&style=none&taskId=u6717e05e-8e1c-4b09-bd9d-370dd96989b&title=" alt="image.png"></p>
<h2 id="方法区的演进细节"><a href="#方法区的演进细节" class="headerlink" title="方法区的演进细节"></a>方法区的演进细节</h2><ol>
<li>首先明确：只有Hotspot才有永久代。BEA JRockit、IBMJ9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一</li>
<li>Hotspot中方法区的变化：</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700774517-b44d7653-694a-4338-851a-5356077c6df8.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uc91cade1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=255&originWidth=998&originalType=url&ratio=1&rotation=0&showTitle=false&size=43914&status=done&style=none&taskId=u95fd093b-74ed-493d-97c0-ef0e13c6f31&title=" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700774626-7b3387f4-5089-450d-b9f5-0a7c8ba60489.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ue5fc641e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=454&originWidth=925&originalType=url&ratio=1&rotation=0&showTitle=false&size=151148&status=done&style=none&taskId=ude7b5773-9d67-4f8a-934c-304acf74d90&title=" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700774637-5968efdc-b089-46d8-85b8-2127d941fd62.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u443f5190&margin=%5Bobject%20Object%5D&name=image.png&originHeight=452&originWidth=916&originalType=url&ratio=1&rotation=0&showTitle=false&size=161826&status=done&style=none&taskId=ufa27a426-457d-47d4-9d30-5323973e14b&title=" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700774692-d754fc0b-1f69-4cdf-86ca-45e4591bff0d.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uacdb79ad&margin=%5Bobject%20Object%5D&name=image.png&originHeight=438&originWidth=1114&originalType=url&ratio=1&rotation=0&showTitle=false&size=244724&status=done&style=none&taskId=u3d36a394-8926-4a84-9dae-115ba3c69a3&title=" alt="image.png"></p>
<h3 id="一，为什么永久代要被元空间替代？"><a href="#一，为什么永久代要被元空间替代？" class="headerlink" title="一，为什么永久代要被元空间替代？"></a>一，为什么永久代要被元空间替代？</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700774968-ea365f26-60ac-4155-bdbc-01b2a06e0da5.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u1e733a28&margin=%5Bobject%20Object%5D&name=image.png&originHeight=844&originWidth=1272&originalType=url&ratio=1&rotation=0&showTitle=false&size=661460&status=done&style=none&taskId=u277f05ff-0170-4809-a95a-7e5a582c061&title=" alt="image.png"></p>
<ul>
<li><p>JRockit是和HotSpot融合后的结果，因为JRockit没有永久代，所以他们不需要配置永久代</p>
</li>
<li><p>随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。</p>
</li>
<li><p>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。</p>
</li>
<li><p>这项改动是很有必要的，原因有：</p>
</li>
<li><p>为永久代设置空间大小是很难确定的。在某些场景下，如果动态加载类过多，容易产生Perm区的oom。比如某个实际Web工 程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。 </p>
</li>
<li><p>而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，元空间的大小仅受本地内存限制。 </p>
</li>
<li><p>对永久代进行调优是很困难的。</p>
</li>
</ul>
<p>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK 11时期的ZGC收集器就不支持类卸载）。 一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏</p>
<p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型</p>
<h3 id="二，StringTable为什么要调整位置？"><a href="#二，StringTable为什么要调整位置？" class="headerlink" title="二，StringTable为什么要调整位置？"></a>二，StringTable为什么要调整位置？</h3><p>jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才会触发。而full gc是老年代的空间不足、永久代不足时才会触发。</p>
<p>这就导致StringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p>
<h3 id="三，静态变量存放在那里？"><a href="#三，静态变量存放在那里？" class="headerlink" title="三，静态变量存放在那里？"></a>三，静态变量存放在那里？</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700775495-109bf95c-2a8e-48ad-87d9-7cbcdc90d378.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uaeabafdf&margin=%5Bobject%20Object%5D&name=image.png&originHeight=2225&originWidth=1051&originalType=url&ratio=1&rotation=0&showTitle=false&size=490242&status=done&style=none&taskId=u8dda91f3-26f9-4b38-9d61-3579d8c7b45&title=" alt="image.png"></p>
<h2 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h2><ul>
<li><p>有些人认为方法区（如Hotspot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的zGC收集器就不支持类卸载）。</p>
</li>
<li><p>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p>
</li>
<li><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</p>
</li>
<li><p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p>
</li>
<li><p>类和接口的全限定名</p>
</li>
<li><p>字段的名称和描述符</p>
</li>
<li><p>方法的名称和描述符</p>
</li>
<li><p>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p>
</li>
<li><p>回收废弃常量与回收Java堆中的对象非常类似。</p>
</li>
<li><p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p>
</li>
<li><p>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。 </p>
</li>
<li><p>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。 </p>
</li>
<li><p>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 </p>
</li>
<li><p>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class 以及 -XX:+TraceClassLoading、-XX:+TraceClassUnLoading查看类加载和卸载信息</p>
</li>
<li><p>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</p>
</li>
</ul>
<h2 id="方法区总结及面试题"><a href="#方法区总结及面试题" class="headerlink" title="方法区总结及面试题"></a>方法区总结及面试题</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700862287-fe4b7315-03ee-42a8-a296-5b6a30a970e6.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ud3b4ebbb&margin=%5Bobject%20Object%5D&name=image.png&originHeight=475&originWidth=1102&originalType=url&ratio=1&rotation=0&showTitle=false&size=236187&status=done&style=none&taskId=u649952ea-fdfe-4ace-8e8d-3b8b625ab09&title=" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700862289-06bcae20-49c6-4b7b-ba48-ac5bef57613f.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u6a45b9be&margin=%5Bobject%20Object%5D&name=image.png&originHeight=534&originWidth=1094&originalType=url&ratio=1&rotation=0&showTitle=false&size=231766&status=done&style=none&taskId=ua631daba-3346-46d5-8d07-d139325dc90&title=" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700862285-6f01df5f-1874-4969-8bcc-004a3cbe2218.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u8acbea39&margin=%5Bobject%20Object%5D&name=image.png&originHeight=523&originWidth=1104&originalType=url&ratio=1&rotation=0&showTitle=false&size=240117&status=done&style=none&taskId=ud18eac66-cde3-4f8c-9c66-f986c484a9f&title=" alt="image.png"></p>
<h2 id="⭐对象实例化及直接内存"><a href="#⭐对象实例化及直接内存" class="headerlink" title="⭐对象实例化及直接内存"></a>⭐对象实例化及直接内存</h2><h2 id="对象实例化"><a href="#对象实例化" class="headerlink" title="对象实例化"></a>对象实例化</h2><p>面试题：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700895296-b556b290-2f95-4565-8925-dcee2899cd55.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua1f0ffef&margin=%5Bobject%20Object%5D&name=image.png&originHeight=363&originWidth=922&originalType=url&ratio=1&rotation=0&showTitle=false&size=102673&status=done&style=none&taskId=ub705596d-9c33-4abf-83f5-180b502851f&title=" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700895478-c2e564f0-9a6b-47e7-bd4b-19a65bc25482.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u3716cede&margin=%5Bobject%20Object%5D&name=image.png&originHeight=591&originWidth=1110&originalType=url&ratio=1&rotation=0&showTitle=false&size=283595&status=done&style=none&taskId=u0a3af62d-d1ea-4457-9640-4737be048b4&title=" alt="image.png"></p>
<h3 id="一，创建对象的方式"><a href="#一，创建对象的方式" class="headerlink" title="一，创建对象的方式"></a>一，创建对象的方式</h3><ul>
<li><p><strong>new：</strong>最常见的方式、Xxx的静态方法，XxxBuilder&#x2F;XxxFactory的静态方法</p>
</li>
<li><p><strong>Class的newInstance方法：</strong>反射的方式，只能调用空参的构造器，权限必须是public</p>
</li>
<li><p><strong>Constructor的newInstance(XXX)：</strong>反射的方式，可以调用空参、带参的构造器，权限没有要求</p>
</li>
<li><p><strong>使用clone()：</strong>不调用任何的构造器，要求当前的类需要实现Cloneable接口，实现clone()</p>
</li>
<li><p><strong>使用序列化：</strong>从文件中、从网络中获取一个对象的二进制流</p>
</li>
<li><p><strong>第三方库 Objenesis</strong></p>
</li>
</ul>
<h3 id="二，创建对象的步骤"><a href="#二，创建对象的步骤" class="headerlink" title="二，创建对象的步骤"></a>二，创建对象的步骤</h3><p>从执行步骤角度分析：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650700895483-ab3a4752-078b-45e4-9562-37416eeeaa07.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ufcb5c68a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=378&originWidth=885&originalType=url&ratio=1&rotation=0&showTitle=false&size=197824&status=done&style=none&taskId=u5e9393b0-94a5-4efd-b7a0-814828ff88f&title=" alt="image.png"></p>
<h4 id="1-判断对象对应的类是否加载、链接、初始化"><a href="#1-判断对象对应的类是否加载、链接、初始化" class="headerlink" title="1.判断对象对应的类是否加载、链接、初始化"></a>1.判断对象对应的类是否加载、链接、初始化</h4><ul>
<li><p>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化（即判断类元信息是否存在）。</p>
</li>
<li><p>如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的 .class文件；</p>
</li>
<li><p>如果没有找到文件，则抛出ClassNotFoundException异常</p>
</li>
<li><p>如果找到，则进行类加载，并生成对应的Class对象</p>
</li>
</ul>
<h4 id="2-为对象分配内存"><a href="#2-为对象分配内存" class="headerlink" title="2.为对象分配内存"></a>2.为对象分配内存</h4><ul>
<li><p>首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小</p>
</li>
<li><p><strong>如果内存规整</strong>：虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。</p>
</li>
<li><p>意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。</p>
</li>
<li><p><strong>如果内存不规整</strong>：虚拟机需要维护一个空闲列表（Free List）来为对象分配内存。</p>
</li>
<li><p>已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。意思是虚拟机维护了一个列表，记录上那些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。</p>
</li>
<li><p>选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p>
</li>
</ul>
<h4 id="3-处理并发问题"><a href="#3-处理并发问题" class="headerlink" title="3.处理并发问题"></a>3.处理并发问题</h4><ul>
<li>采用CAS失败重试、区域加锁保证更新的原子性</li>
<li>每个线程预先分配一块TLAB：通过设置 -XX:+UseTLAB参数来设定</li>
</ul>
<h4 id="4-初始化分配到的内存"><a href="#4-初始化分配到的内存" class="headerlink" title="4.初始化分配到的内存"></a>4.初始化分配到的内存</h4><ul>
<li>所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用</li>
</ul>
<h4 id="5-设置对象的对象头"><a href="#5-设置对象的对象头" class="headerlink" title="5.设置对象的对象头"></a>5.设置对象的对象头</h4><ul>
<li>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</li>
</ul>
<h4 id="6-执行init方法进行初始化"><a href="#6-执行init方法进行初始化" class="headerlink" title="6.执行init方法进行初始化"></a>6.执行init方法进行初始化</h4><ul>
<li><p>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。</p>
</li>
<li><p>因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。</p>
</li>
</ul>
<h3 id="给对象属性赋值的操作"><a href="#给对象属性赋值的操作" class="headerlink" title="给对象属性赋值的操作"></a>给对象属性赋值的操作</h3><ul>
<li>属性的默认初始化</li>
<li>显式初始化</li>
<li>代码块中初始化</li>
<li>构造器中初始化</li>
</ul>
<h3 id="对象实例化的过程"><a href="#对象实例化的过程" class="headerlink" title="对象实例化的过程"></a>对象实例化的过程</h3><ul>
<li>加载类元信息</li>
<li>为对象分配内存</li>
<li>处理并发问题</li>
<li>属性的默认初始化（零值初始化）</li>
<li>设置对象头信息</li>
<li>属性的显示初始化、代码块中初始化、构造器中初始化</li>
</ul>
<h2 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h2><h3 id="一，对象头（Header）"><a href="#一，对象头（Header）" class="headerlink" title="一，对象头（Header）"></a>一，对象头（Header）</h3><p><strong>对象头包含了两部分，分别是运行时元数据（Mark Word）和类型指针。如果是数组，还需要记录数组的长度</strong></p>
<ul>
<li><p>运行时元数据</p>
</li>
<li><p>哈希值（HashCode）</p>
</li>
<li><p>GC分代年龄</p>
</li>
<li><p>锁状态标志</p>
</li>
<li><p>线程持有的锁</p>
</li>
<li><p>偏向线程ID</p>
</li>
<li><p>偏向时间戳</p>
</li>
<li><p>类型指针</p>
</li>
<li><p>指向类元数据InstanceClass，确定该对象所属的类型。</p>
</li>
</ul>
<h3 id="二，实例数据（Instance-Data）"><a href="#二，实例数据（Instance-Data）" class="headerlink" title="二，实例数据（Instance Data）"></a>二，实例数据（Instance Data）</h3><ul>
<li><p>它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承下来的和本身拥有的字段）</p>
</li>
<li><p>相同宽度的字段总是被分配在一起</p>
</li>
<li><p>父类中定义的变量会出现在子类之前</p>
</li>
<li><p>如果CompactFields参数为true（默认为true）：子类的窄变量可能插入到父类变量的空隙</p>
</li>
</ul>
<h3 id="三，对齐填充（Padding）"><a href="#三，对齐填充（Padding）" class="headerlink" title="三，对齐填充（Padding）"></a>三，对齐填充（Padding）</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701000227-7d0079c0-1d11-49fb-8c34-9151f7c28700.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u98fee42f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=516&originWidth=954&originalType=url&ratio=1&rotation=0&showTitle=false&size=21394&status=done&style=none&taskId=u439545e5-b231-46c1-8d88-c425785942c&title=" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701000568-bf547880-14c2-48fe-9655-9596f3c2c242.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ubf5e7d5f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=621&originWidth=1188&originalType=url&ratio=1&rotation=0&showTitle=false&size=519643&status=done&style=none&taskId=ue11e42ca-4ca4-471f-af06-b89b299de26&title=" alt="image.png"></p>
<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701000374-48001c10-c36d-4e0d-9b12-05386d921530.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u4a3ee008&margin=%5Bobject%20Object%5D&name=image.png&originHeight=373&originWidth=1005&originalType=url&ratio=1&rotation=0&showTitle=false&size=224810&status=done&style=none&taskId=u2bf4f85d-09ed-4998-b889-e10f79ab27d&title=" alt="image.png"></p>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701037558-54b61ac4-7493-4c4e-b259-62c3021f6e48.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u86ae31d0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=362&originWidth=1271&originalType=url&ratio=1&rotation=0&showTitle=false&size=190428&status=done&style=none&taskId=ue470a89d-5c85-4ec6-890e-805fe72fe21&title=" alt="image.png"></p>
<p>JVM是如何通过栈帧中的对象引用访问到其内部的对象实例呢？</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701037529-9b83875d-f338-431e-9d16-23d42fa47bf3.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ud575dfd4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=346&originWidth=631&originalType=url&ratio=1&rotation=0&showTitle=false&size=113186&status=done&style=none&taskId=u2a9916a1-467a-440a-9181-1d08d0c36ba&title=" alt="image.png"></p>
<h3 id="一，句柄访问"><a href="#一，句柄访问" class="headerlink" title="一，句柄访问"></a>一，句柄访问</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701037660-014072cc-9d9b-4dd3-9c4b-6d55448feeca.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u4e071b06&margin=%5Bobject%20Object%5D&name=image.png&originHeight=661&originWidth=1157&originalType=url&ratio=1&rotation=0&showTitle=false&size=308430&status=done&style=none&taskId=u70f5f218-b31e-4b41-a3d3-672b22f7196&title=" alt="image.png"></p>
<p>reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改</p>
<h3 id="二，直接指针（HotSpot采用）"><a href="#二，直接指针（HotSpot采用）" class="headerlink" title="二，直接指针（HotSpot采用）"></a>二，直接指针（HotSpot采用）</h3><p>直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据</p>
<h2 id="直接内存（Direct-Memory）"><a href="#直接内存（Direct-Memory）" class="headerlink" title="直接内存（Direct Memory）"></a>直接内存（Direct Memory）</h2><h3 id="一，直接内存概述"><a href="#一，直接内存概述" class="headerlink" title="一，直接内存概述"></a>一，直接内存概述</h3><ul>
<li><p>不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。直接内存是在Java堆外的、直接向系统申请的内存区间。来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存。通常，访问直接内存的速度会优于Java堆，即读写性能高。</p>
</li>
<li><p>因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。</p>
</li>
<li><p>Java的NIO库允许Java程序使用直接内存，用于数据缓冲区</p>
</li>
</ul>
<h3 id="二，非直接缓存区"><a href="#二，非直接缓存区" class="headerlink" title="二，非直接缓存区"></a>二，非直接缓存区</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701066605-d206e461-d9f7-4f74-8a13-b719776e3ce2.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u6631a346&margin=%5Bobject%20Object%5D&name=image.png&originHeight=547&originWidth=849&originalType=url&ratio=1&rotation=0&showTitle=false&size=131481&status=done&style=none&taskId=ubcc54dcf-4ff1-40c5-a9f1-600f425d33d&title=" alt="image.png"></p>
<h3 id="三，直接缓存区"><a href="#三，直接缓存区" class="headerlink" title="三，直接缓存区"></a>三，直接缓存区</h3><p>使用NIO时，操作系统划出的直接缓存区可以被java代码直接访问，只有一份。NIO适合对大文件的读写操作。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701066635-4244d859-890f-4f9c-83ea-22d1230f1151.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u1b4bed5d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=584&originWidth=900&originalType=url&ratio=1&rotation=0&showTitle=false&size=172431&status=done&style=none&taskId=u260c4734-bd11-4830-b2c7-98aad0e919d&title=" alt="image.png"></p>
<p>也可能导致OutOfMemoryError异常<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701066535-3706eaed-decd-4acc-9019-81044c7c0e37.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u8383a6ad&margin=%5Bobject%20Object%5D&name=image.png&originHeight=207&originWidth=1005&originalType=url&ratio=1&rotation=0&showTitle=false&size=20469&status=done&style=none&taskId=u593b81da-c5ff-40cc-b1ea-b45fefec409&title=" alt="image.png"></p>
<ul>
<li><p>由于直接内存在Java堆外，因此它的大小不会直接受限于-Xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。</p>
</li>
<li><p>分配回收成本较高</p>
</li>
<li><p>不受JVM内存回收管理</p>
</li>
<li><p>直接内存大小可以通过MaxDirectMemorySize设置。如果不指定，默认与堆的最大值-Xmx参数值一致</p>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701066715-00e94c2e-bc5d-441d-a8fc-af98a566b7b1.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua35d6aac&margin=%5Bobject%20Object%5D&name=image.png&originHeight=598&originWidth=1082&originalType=url&ratio=1&rotation=0&showTitle=false&size=319601&status=done&style=none&taskId=u7fb172bb-6d20-4ab9-8c4a-b656ce3c784&title=" alt="image.png"></p>
<h2 id="⭐执行引擎"><a href="#⭐执行引擎" class="headerlink" title="⭐执行引擎"></a>⭐执行引擎</h2><h3 id="一，执行引擎概述"><a href="#一，执行引擎概述" class="headerlink" title="一，执行引擎概述"></a>一，执行引擎概述</h3><p>执行引擎属于JVM的下层，里面包括解释器、及时编译器、垃圾回收器</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701100187-cf4a4554-85dc-42d2-84f7-6c89a0265c32.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ue46a5495&margin=%5Bobject%20Object%5D&name=image.png&originHeight=530&originWidth=857&originalType=url&ratio=1&rotation=0&showTitle=false&size=246665&status=done&style=none&taskId=u6bb0da9a-ed10-46ae-8feb-39d2bd95f59&title=" alt="image.png"></p>
<p>执行引擎是Java虚拟机核心的组成部分之一。</p>
<p>“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。</p>
<p>JVM的主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701100215-a8c05d81-116a-4fe3-932e-2156b2ce0b61.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u94eb4285&margin=%5Bobject%20Object%5D&name=image.png&originHeight=495&originWidth=1038&originalType=url&ratio=1&rotation=0&showTitle=false&size=303866&status=done&style=none&taskId=u2cd7c9ca-3580-4167-900c-3b8302497d6&title=" alt="image.png"></p>
<p>那么，如果想要让一个Java程序运行起来，执行引擎（Execution Engine）的任务就是将字节码指令解释&#x2F;编译为对应平台上的本地机器指令.才可以。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。</p>
<h3 id="二，执行引擎的工作流程"><a href="#二，执行引擎的工作流程" class="headerlink" title="二，执行引擎的工作流程"></a>二，执行引擎的工作流程</h3><ol>
<li>执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器。</li>
<li>每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。</li>
<li>当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701100133-69eef82e-6af6-4c6f-8853-e29274eb1a2f.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u26478910&margin=%5Bobject%20Object%5D&name=image.png&originHeight=525&originWidth=612&originalType=url&ratio=1&rotation=0&showTitle=false&size=164335&status=done&style=none&taskId=u52702469-ea12-4ec2-96e9-5abddd379e8&title=" alt="image.png"></p>
<h2 id="Java代码编译和执行过程"><a href="#Java代码编译和执行过程" class="headerlink" title="Java代码编译和执行过程"></a>Java代码编译和执行过程</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701136666-6a93624c-58fb-430e-b82b-6f9c8db6acd9.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ucfff5d77&margin=%5Bobject%20Object%5D&name=image.png&originHeight=406&originWidth=898&originalType=url&ratio=1&rotation=0&showTitle=false&size=153855&status=done&style=none&taskId=ua8647958-7b18-467f-a1ff-e068ee63dc8&title=" alt="image.png"></p>
<p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图中的各个步骤</p>
<p>Java代码编译是由Java源码编译器（前端编译器）来完成，流程图如下所示：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701136742-653ba9e8-1733-4b5f-8976-4e8084c43f9a.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u5419cb69&margin=%5Bobject%20Object%5D&name=image.png&originHeight=234&originWidth=778&originalType=url&ratio=1&rotation=0&showTitle=false&size=265130&status=done&style=none&taskId=uc5047aee-97e2-4b13-b805-71997d8e861&title=" alt="image.png"></p>
<p>Java字节码的执行是由JVM执行引擎（后端编译器）来完成，流程图 如下所示：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701136762-aaa09067-89bd-4417-a63b-08712169e570.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uf14f6ff8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=364&originWidth=840&originalType=url&ratio=1&rotation=0&showTitle=false&size=279649&status=done&style=none&taskId=u66e1f9e6-9e8a-49f6-bdeb-11344024d6b&title=" alt="image.png"></p>
<h3 id="一，什么是解释器（Interpreter）？什么是JIT编译器？"><a href="#一，什么是解释器（Interpreter）？什么是JIT编译器？" class="headerlink" title="一，什么是解释器（Interpreter）？什么是JIT编译器？"></a>一，什么是解释器（Interpreter）？什么是JIT编译器？</h3><p>解释器：当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p>
<p>JIT（Just In Time Compiler）编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。</p>
<h3 id="二，为什么Java是半编译半解释型语言？"><a href="#二，为什么Java是半编译半解释型语言？" class="headerlink" title="二，为什么Java是半编译半解释型语言？"></a>二，为什么Java是半编译半解释型语言？</h3><p>JDK1.0时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701136905-0f8bf0df-209b-4284-b11b-3e71b08e97ff.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u378ee1b3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=607&originWidth=1218&originalType=url&ratio=1&rotation=0&showTitle=false&size=506823&status=done&style=none&taskId=u5c34fac1-ef42-4126-a419-e71f99d185f&title=" alt="image.png"></p>
<h2 id="机器码、指令、汇编语言"><a href="#机器码、指令、汇编语言" class="headerlink" title="机器码、指令、汇编语言"></a>机器码、指令、汇编语言</h2><h3 id="一，机器码"><a href="#一，机器码" class="headerlink" title="一，机器码"></a>一，机器码</h3><p>各种用二进制编码方式表示的指令，叫做机器指令码。开始，人们就用它采编写程序，这就是机器语言。</p>
<p>机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。</p>
<p>用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，执行速度最快。</p>
<p>机器指令与CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同。</p>
<h3 id="二，指令"><a href="#二，指令" class="headerlink" title="二，指令"></a>二，指令</h3><p>由于机器码是有0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。</p>
<p>指令就是把机器码中特定的0和1序列，简化成对应的指令（一般为英文简写，如mov，inc等），可读性稍好</p>
<p>由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov），对应的机器码也可能不同。</p>
<h3 id="三，指令集"><a href="#三，指令集" class="headerlink" title="三，指令集"></a>三，指令集</h3><ul>
<li><p>不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。 如常见的</p>
</li>
<li><p>x86指令集，对应的是x86架构的平台</p>
</li>
<li><p>ARM指令集，对应的是ARM架构的平台</p>
</li>
</ul>
<h3 id="四，汇编语言"><a href="#四，汇编语言" class="headerlink" title="四，汇编语言"></a>四，汇编语言</h3><p>由于指令的可读性还是太差，于是人们又发明了汇编语言。</p>
<p>在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用&lt;mark地址符号（Symbol）或标号（Label）代替指令或操作数的地址。在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。</p>
<p>由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译成机器指令码，计算机才能识别和执行。</p>
<h3 id="五，高级语言"><a href="#五，高级语言" class="headerlink" title="五，高级语言"></a>五，高级语言</h3><p>为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。高级语言比机器语言、汇编语言更接近人的语言</p>
<p>当计算机执行高级语言编写的程序时，仍然需要把程序解释和编译成机器的指令码。完成这个过程的程序就叫做解释程序或编译程序。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701175966-e1f41c91-ed5e-4513-9794-98fdd038431d.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u0b53a86b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=476&originWidth=802&originalType=url&ratio=1&rotation=0&showTitle=false&size=80134&status=done&style=none&taskId=u95b76c93-fd1f-43e6-a60f-0fe4f831e64&title=" alt="image.png"></p>
<p>高级语言也不是直接翻译成机器指令，而是翻译成汇编语言码，如下面说的C和C++</p>
<h4 id="C、C-源程序执行过程"><a href="#C、C-源程序执行过程" class="headerlink" title="C、C++源程序执行过程"></a>C、C++源程序执行过程</h4><p>编译过程又可以分成两个阶段：编译和汇编。</p>
<p>编译过程：是读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码</p>
<p>汇编过程：实际上指把汇编语言代码翻译成目标机器指令的过程。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701174819-c75299ba-7853-4e07-adfd-09a1b746d4f5.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ub2f02240&margin=%5Bobject%20Object%5D&name=image.png&originHeight=492&originWidth=488&originalType=url&ratio=1&rotation=0&showTitle=false&size=295465&status=done&style=none&taskId=u82927b4e-b8ff-48c8-90a9-54ed4b74e1a&title=" alt="image.png"></p>
<h3 id="六，字节码"><a href="#六，字节码" class="headerlink" title="六，字节码"></a>六，字节码</h3><p>字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码</p>
<p>字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。</p>
<p>字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。字节码典型的应用为：Java bytecode</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701174697-1b471cc5-68ec-4f7b-8f18-a775bdfd3048.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u0fcdde28&margin=%5Bobject%20Object%5D&name=image.png&originHeight=322&originWidth=752&originalType=url&ratio=1&rotation=0&showTitle=false&size=81146&status=done&style=none&taskId=u6e61718e-abe8-49e3-b605-c612833a99f&title=" alt="image.png"></p>
<h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><p>JVM设计者们的初衷仅仅只是单纯地为了满足Java程序实现跨平台特性，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701225296-a8b1f899-0567-4b4e-893b-5c55fcf49aba.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9f690e7b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=352&originWidth=935&originalType=url&ratio=1&rotation=0&showTitle=false&size=127727&status=done&style=none&taskId=ucd02339b-2e90-42ec-8cf3-24c2105211c&title=" alt="image.png"></p>
<p>为什么Java源文件不直接翻译成JVM，而是翻译成字节码文件？可能是因为直接翻译的代价是比较大的</p>
<h3 id="一，解释器工作机制"><a href="#一，解释器工作机制" class="headerlink" title="一，解释器工作机制"></a>一，解释器工作机制</h3><p>解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p>
<p>当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</p>
<h3 id="二，解释器分类"><a href="#二，解释器分类" class="headerlink" title="二，解释器分类"></a>二，解释器分类</h3><ul>
<li><p>在Java的发展历史里，一共有两套解释执行器，即古老的字节码解释器、现在普遍使用的模板解释器。</p>
</li>
<li><p>字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。</p>
</li>
<li><p>而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。</p>
</li>
<li><p>在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。</p>
</li>
<li><p>Interpreter模块：实现了解释器的核心功能</p>
</li>
<li><p>Code模块：用于管理HotSpot VM在运行时生成的本地机器指令</p>
</li>
</ul>
<h3 id="三，现状"><a href="#三，现状" class="headerlink" title="三，现状"></a>三，现状</h3><p>由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Perl、Ruby等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些C&#x2F;C++程序员所调侃。</p>
<p>为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。</p>
<p>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</p>
<h2 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h2><h3 id="一，Java代码的执行分类"><a href="#一，Java代码的执行分类" class="headerlink" title="一，Java代码的执行分类"></a>一，Java代码的执行分类</h3><pre><code>• 第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行 
• 第二种是编译执行（直接编译成机器码，但是要知道不同机器上编译的机器码是不一样，而字节码是可以跨平台的）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT，Just In Time）将方法编译成机器码后再执行 
</code></pre>
<p>HotSpot VM是目前市面上高性能虚拟机的代表作之一。它采用解释器与即时编译器并存的架构。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。</p>
<p>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C&#x2F;C++ 程序一较高下的地步。</p>
<p>问题来了</p>
<p>有些开发人员会感觉到诧异，既然HotSpot VM中已经内置JIT编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？比如JRockit VM内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。</p>
<p>首先明确： 当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。 编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。</p>
<p>所以： 尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。在此模式下，当Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</p>
<p>同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”。</p>
<h3 id="二，HotSpot-JVM执行方式"><a href="#二，HotSpot-JVM执行方式" class="headerlink" title="二，HotSpot JVM执行方式"></a>二，HotSpot JVM执行方式</h3><p>当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。</p>
<h3 id="三，概念解释"><a href="#三，概念解释" class="headerlink" title="三，概念解释"></a>三，概念解释</h3><p>Java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器（其实叫“编译器的前端”更准确一些）把.java文件转变成.class文件的过程；</p>
<p>也可能是指虚拟机的后端运行期编译器（JIT编译器，Just In Time Compiler）把字节码转变成机器码的过程。</p>
<p>还可能是指使用静态提前编译器（AOT编译器，Ahead of Time Compiler）直接把.java文件编译成本地机器代码的过程。</p>
<pre><code>• 前端编译器：Sun的Javac、Eclipse JDT中的增量式编译器（ECJ）。 
• JIT编译器：HotSpot VM的C1、C2编译器。 
• AOT 编译器：GNU Compiler for the Java（GCJ）、Excelsior JET。 
</code></pre>
<h3 id="四，热点代码及探测技术"><a href="#四，热点代码及探测技术" class="headerlink" title="四，热点代码及探测技术"></a>四，热点代码及探测技术</h3><p>当然是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被调用执行的频率而定。关于那些需要被编译为本地代码的字节码，也被称之为“热点代码”，JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出深度优化，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能。</p>
<p>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此被称之为栈上替换，或简称为OSR（On Stack Replacement）编译。</p>
<p>一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能。</p>
<p>目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测。</p>
<p>采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。</p>
<pre><code>• 方法调用计数器用于统计方法的调用次数
• 回边计数器则用于统计循环体执行的循环次数
</code></pre>
<h4 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a>方法调用计数器</h4><p>这个计数器就用于统计方法被调用的次数，它的默认阀值在Client模式下是1500次，在Server模式下是10000次。超过这个阈值，就会触发JIT编译。</p>
<p>这个阀值可以通过虚拟机参数 -XX:CompileThreshold来人为设定。</p>
<p>当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阀值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</p>
<h4 id="热点衰减"><a href="#热点衰减" class="headerlink" title="热点衰减"></a>热点衰减</h4><p>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期（Counter Half Life Time）</p>
<p>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 -XX:-UseCounterDecay 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</p>
<p>另外，可以使用-XX:CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。</p>
<h4 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h4><p>它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发OSR编译。</p>
<h3 id="五，HotSpotVM-可以设置程序执行方法"><a href="#五，HotSpotVM-可以设置程序执行方法" class="headerlink" title="五，HotSpotVM 可以设置程序执行方法"></a>五，HotSpotVM 可以设置程序执行方法</h3><p>缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：</p>
<pre><code>• -Xint：完全采用解释器模式执行程序；
• -Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行
• -Xmixed：采用解释器+即时编译器的混合模式共同执行程序。
</code></pre>
<h3 id="六，HotSpotVM中-JIT-分类"><a href="#六，HotSpotVM中-JIT-分类" class="headerlink" title="六，HotSpotVM中 JIT 分类"></a>六，HotSpotVM中 JIT 分类</h3><p>JIT的编译器还分为了两种，分别是C1和C2，在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server Compiler，但大多数情况下我们简称为C1编译器 和 C2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：</p>
<pre><code>• -client：指定Java虚拟机运行在Client模式下，并使用C1编译器；C1编译器会对字节码进行简单和可靠的优化，耗时短，以达到更快的编译速度。
• -server：指定Java虚拟机运行在server模式下，并使用C2编译器。C2进行耗时较长的优化，以及激进优化，但优化的代码执行效率更高。
</code></pre>
<p>分层编译（Tiered Compilation）策略：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。</p>
<p>不过在Java7版本之后，一旦开发人员在程序中显式指定命令“-server”时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务。</p>
<p>C1 和 C2编译器不同的优化策略</p>
<p>在不同的编译器上有不同的优化策略，C1编译器上主要有方法内联、去虚拟化、冗余消除。</p>
<pre><code>• 方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程
• 去虚拟化：对唯一的实现类进行内联
• 冗余消除：在运行期间把一些不会执行的代码折叠掉
</code></pre>
<p>C2的优化主要是在全局层面，逃逸分析（前面讲过，并不成熟）是优化的基础。基于逃逸分析在C2上有如下几种优化：</p>
<pre><code>• 标量替换：用标量值代替聚合对象的属性值
• 栈上分配：对于未逃逸的对象分配对象在栈而不是堆
• 同步消除：清除同步操作，通常指synchronized
</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一般来讲，JIT编译出来的机器码性能比解释器高。C2编译器启动时长比C1慢，系统稳定执行以后，C2编译器执行速度远快于C1编译器</p>
<h3 id="写到最后1"><a href="#写到最后1" class="headerlink" title="写到最后1"></a>写到最后1</h3><ul>
<li>自JDK10起，HotSpot又加入了一个全新的及时编译器：Graal编译器</li>
<li>编译效果短短几年时间就追评了C2编译器，未来可期</li>
<li>目前，带着实验状态标签，需要使用开关参数-XX:+UnlockExperimentalvMOptions -XX:+UseJVMCICompiler去激活才能使用</li>
</ul>
<h3 id="写到最后2：AOT编译器"><a href="#写到最后2：AOT编译器" class="headerlink" title="写到最后2：AOT编译器"></a>写到最后2：AOT编译器</h3><p>jdk9引入了AOT编译器（静态提前编译器，Ahead of Time Compiler）</p>
<p>Java 9引入了实验性AOT编译工具jaotc。它借助了Graal编译器，将所输入的Java类文件转换为机器码，并存放至生成的动态共享库之中。</p>
<p>所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。</p>
<p>最大的好处：Java虚拟机加载已经预编译成二进制库，可以直接执行。不必等待及时编译器的预热，减少Java应用给人带来“第一次运行慢” 的不良体验</p>
<p>缺点：</p>
<ul>
<li>破坏了 java “ 一次编译，到处运行”的理念，必须为每个不同的硬件，OS编译对应的发行包</li>
<li>降低了Java链接过程的动态性，加载的代码在编译器就必须全部已知。</li>
<li>还需要继续优化中，最初只支持Linux X64 java base</li>
</ul>
<h1 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h1><p><strong>一， String的基本特性</strong></p>
<ul>
<li>String：字符串，使用一对””引起来表示</li>
<li>String声明为final的，不可被继承</li>
<li>String实现了Serializable接口：表示字符串是支持序列化的。</li>
<li>String实现了Comparable接口：表示string可以比较大小</li>
<li>String在jdk8及以前内部定义了final char[] value用于存储字符串数据。JDK9时改为byte[]</li>
</ul>
<p><strong>二，String在jdk9中存储结构变更</strong></p>
<p>官网地址：JEP 254: Compact Strings (java.net)</p>
<ul>
<li><p><strong>动机</strong></p>
</li>
<li><p>目前String类的实现将字符存储在一个char数组中，每个字符使用两个字节（16位）。从许多不同的应用中收集到的数据表明，字符串是堆使用的主要组成部分，此外，大多数字符串对象只包含Latin-1字符。这些字符只需要一个字节的存储空间，因此这些字符串对象的内部字符数组中有一半的空间没有被使用。</p>
</li>
<li><p><strong>说明</strong></p>
</li>
<li><p>我们建议将String类的内部表示方法从UTF-16字符数组改为字节数组加编码标志域。新的String类将根据字符串的内容，以ISO-8859-1&#x2F;Latin-1（每个字符一个字节）或UTF-16（每个字符两个字节）的方式存储字符编码。编码标志将表明使用的是哪种编码。</p>
</li>
<li><p>与字符串相关的类，如AbstractStringBuilder、StringBuilder和StringBuffer将被更新以使用相同的表示方法，HotSpot VM的内在字符串操作也是如此。</p>
</li>
<li><p>这纯粹是一个实现上的变化，对现有的公共接口没有变化。目前没有计划增加任何新的公共API或其他接口。</p>
</li>
<li><p>迄今为止所做的原型设计工作证实了内存占用的预期减少，GC活动的大幅减少，以及在某些角落情况下的轻微性能倒退。</p>
</li>
<li><p>结论：String再也不用char[] 来存储了，改成了byte [] 加上编码标记，节约了一些空间</p>
</li>
</ul>
<p><strong>三，String的基本特性</strong></p>
<ul>
<li><p>String：代表不可变的字符序列。简称：不可变性。</p>
</li>
<li><p>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</p>
</li>
<li><p>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</p>
</li>
<li><p>当调用string的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</p>
</li>
<li><p>通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</p>
</li>
<li><p>字符串常量池是不会存储相同内容的字符串的</p>
</li>
<li><p>String的String Pool是一个固定大小的Hashtable，默认值大小长度是1009。如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern时性能会大幅下降。</p>
</li>
<li><p>使用-XX:StringTablesize可设置StringTable的长度</p>
<ul>
<li>在jdk6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。StringTablesize设置没有要求 </li>
<li>在jdk7中，StringTable的长度默认值是60013，StringTablesize设置没有要求 </li>
<li>在JDK8中，设置StringTable长度的话，1009是可以设置的最小值</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701368685-63012c27-1b8c-46f1-be13-6e14f764223e.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u6854193f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=604&originWidth=759&originalType=url&ratio=1&rotation=0&showTitle=false&size=247316&status=done&style=none&taskId=u7d079eea-8294-4cb0-be41-b98167780f5&title=" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701368613-99c8ff09-733b-4291-97a9-20a880a8e1f5.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u221a9300&margin=%5Bobject%20Object%5D&name=image.png&originHeight=781&originWidth=1435&originalType=url&ratio=1&rotation=0&showTitle=false&size=109326&status=done&style=none&taskId=u16d7f0ae-f458-4ff0-a39b-552b31cdf7e&title=" alt="image.png"></p>
<h2 id="String的内存分配"><a href="#String的内存分配" class="headerlink" title="String的内存分配"></a>String的内存分配</h2><ul>
<li><p>在Java语言中有8种基本数据类型和一种比较特殊的类型String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。</p>
</li>
<li><p>常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，String类型的常量池比较特殊。它的主要使用方法有两种。</p>
</li>
<li><p>直接使用双引号声明出来的String对象会直接存储在常量池中。 </p>
</li>
<li><p>如果不是用双引号声明的String对象，可以使用String提供的intern()方法。这个后面重点谈 </p>
</li>
<li><p>Java 6及以前，字符串常量池存放在永久代</p>
</li>
<li><p>Java 7中 Oracle的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到Java堆内</p>
</li>
<li><p>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。 </p>
</li>
<li><p>字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java 7中使用String.intern()。 </p>
</li>
<li><p>Java8元空间，字符串常量在堆</p>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701413407-a8010168-8212-4cd7-8e13-d5c9f242bbe7.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u3b092e8e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=432&originWidth=891&originalType=url&ratio=1&rotation=0&showTitle=false&size=96538&status=done&style=none&taskId=u1579ad67-ae74-4957-9488-6114be1b783&title=" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701413420-70e523b2-6712-44d1-ab44-9079193e2698.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u4b720dc8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=425&originWidth=864&originalType=url&ratio=1&rotation=0&showTitle=false&size=83929&status=done&style=none&taskId=u4f98d0b6-bc72-4da5-91b7-90b102b1e86&title=" alt="image.png"></p>
<h3 id="StringTable为什么要调整？"><a href="#StringTable为什么要调整？" class="headerlink" title="StringTable为什么要调整？"></a>StringTable为什么要调整？</h3><p>官网地址：<a target="_blank" rel="noopener" href="https://www.oracle.com/java/technologies/javase/jdk7-relnotes.html#jdk7changes">Java SE 7 Features and Enhancements (oracle.com)</a></p>
<p>简介：在JDK 7中，内部字符串不再分配在Java堆的永久代中，而是分配在Java堆的主要部分（称为年轻代和老年代），与应用程序创建的其他对象一起。这种变化将导致更多的数据驻留在主Java堆中，而更少的数据在永久代中，因此可能需要调整堆的大小。大多数应用程序将看到由于这一变化而导致的堆使用的相对较小的差异，但加载许多类或大量使用String.intern()方法的大型应用程序将看到更明显的差异。</p>
<h2 id="String的基本操作"><a href="#String的基本操作" class="headerlink" title="String的基本操作"></a>String的基本操作</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701444022-df3e1534-711b-48a3-b02a-9632f64c7536.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u2ac1ccf3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=718&originWidth=491&originalType=url&ratio=1&rotation=0&showTitle=false&size=67826&status=done&style=none&taskId=u0f79bf1b-3c9d-4fb0-b904-bad04b9b709&title=" alt="image.png"></p>
<p>Java语言规范里要求完全相同的字符串字面量，应该包含同样的Unicode字符序列（包含同一份码点序列的常量），并且必须是指向同一个String类实例。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701443999-a4cbf460-2083-4c7a-91bf-e8708c76bb73.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u7dcbdd34&margin=%5Bobject%20Object%5D&name=image.png&originHeight=383&originWidth=1004&originalType=url&ratio=1&rotation=0&showTitle=false&size=27857&status=done&style=none&taskId=udd93a7e1-d982-4dbb-a6b7-49046c21f22&title=" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701444081-03bd9ff8-c586-470a-a163-0b0d3fd605ea.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u4ec3f506&margin=%5Bobject%20Object%5D&name=image.png&originHeight=492&originWidth=1134&originalType=url&ratio=1&rotation=0&showTitle=false&size=160657&status=done&style=none&taskId=uebbbb82b-3ad2-492e-b5a9-34bc9f0ef3c&title=" alt="image.png"></p>
<h2 id="字符串拼接操作"><a href="#字符串拼接操作" class="headerlink" title="字符串拼接操作"></a>字符串拼接操作</h2><ul>
<li>常量与常量的拼接结果在常量池，原理是编译期优化</li>
<li>常量池中不会存在相同内容的变量</li>
<li>只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder</li>
<li>如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址</li>
</ul>
<p>例子1：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701471308-a0bec55d-bcf0-49f7-9924-dabe3ae14ff2.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u388e145c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=311&originWidth=998&originalType=url&ratio=1&rotation=0&showTitle=false&size=40026&status=done&style=none&taskId=u39b28164-22d2-4e53-9f75-fc19b2af925&title=" alt="image.png"></p>
<p>例子2：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701471366-8b407a39-72c1-47cb-9b42-8726665e1dcb.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u3bcee9de&margin=%5Bobject%20Object%5D&name=image.png&originHeight=621&originWidth=1002&originalType=url&ratio=1&rotation=0&showTitle=false&size=86841&status=done&style=none&taskId=u67291a28-d43c-445d-9b31-6218c710dd5&title=" alt="image.png"></p>
<p>例子3：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701471317-20920841-ee98-4d96-9a5f-5b7f9342cd8d.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=udb2e56cc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=395&originWidth=997&originalType=url&ratio=1&rotation=0&showTitle=false&size=40575&status=done&style=none&taskId=u96b9bb16-6618-4aef-a00f-d961b5815f9&title=" alt="image.png"></p>
<ul>
<li>不使用final修饰，即为变量。如s3行的s1和s2，会通过new StringBuilder进行拼接</li>
<li>使用final修饰，即为常量。会在编译器进行代码优化。在实际开发中，能够使用final的，尽量使用</li>
</ul>
<p>例子4：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701471438-98907e47-3493-48e1-8d20-e5ea120a1b99.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u815e3d43&margin=%5Bobject%20Object%5D&name=image.png&originHeight=259&originWidth=997&originalType=url&ratio=1&rotation=0&showTitle=false&size=13185&status=done&style=none&taskId=u42bc880e-bea0-481d-887d-3f81e4bf5c4&title=" alt="image.png"></p>
<h3 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h3><p>我们拿例4的字节码进行查看，可以发现s1 + s2实际上是new了一个StringBuilder对象，并使用了append方法将s1和s2添加进来，最后调用了toString方法赋给s4</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701471359-82cd63c3-c9d6-4023-9a34-c01623354d10.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ub2380c98&margin=%5Bobject%20Object%5D&name=image.png&originHeight=703&originWidth=996&originalType=url&ratio=1&rotation=0&showTitle=false&size=50915&status=done&style=none&taskId=u93214db8-a4c0-466c-a029-8a271f890bf&title=" alt="image.png"></p>
<h3 id="字符串拼接操作性能对比"><a href="#字符串拼接操作性能对比" class="headerlink" title="字符串拼接操作性能对比"></a>字符串拼接操作性能对比</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701472316-7718b7d2-1116-49d0-bcf3-6f350671079a.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u6d690c18&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1382&originWidth=999&originalType=url&ratio=1&rotation=0&showTitle=false&size=80897&status=done&style=none&taskId=u563f4977-7833-4497-bdae-df3d88ede34&title=" alt="image.png"></p>
<ul>
<li><p>本实验进行5万次循环，String拼接方式的时间是StringBuilder.append方式的约8000倍，StringBuffer.append()方式的时间是StringBuilder.append()方式的约4倍</p>
</li>
<li><p>可以看到，通过StringBuilder的append方式的速度，要比直接对String使用“+”拼接的方式快的不是一点半点</p>
</li>
<li><p>那么，在实际开发中，对于需要多次或大量拼接的操作，在不考虑线程安全问题时，我们就应该尽可能使用StringBuilder进行append操作</p>
</li>
<li><p>除此之外，还有那些操作能够帮助我们提高字符串方面的运行效率呢？</p>
</li>
<li><p>StringBuilder空参构造器的初始化大小为16。那么，如果提前知道需要拼接String的个数，就应该直接使用带参构造器指定capacity，以减少扩容的次数（扩容的逻辑可以自行查看源代码）</p>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701472366-fb839f20-8ebc-4354-9802-6565627891c5.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uca17c5e4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=572&originWidth=997&originalType=url&ratio=1&rotation=0&showTitle=false&size=37865&status=done&style=none&taskId=uc30c04c7-e698-4a12-bc8c-294bb8c18bf&title=" alt="image.png"></p>
<h3 id="intern-的使用"><a href="#intern-的使用" class="headerlink" title="intern()的使用"></a>intern()的使用</h3><p>当调用intern方法时，如果池子里已经包含了一个与这个String对象相等的字符串，正如equals(Object)方法所确定的，那么池子里的字符串会被返回。否则，这个String对象被添加到池中，并返回这个String对象的引用。</p>
<p>由此可见，对于任何两个字符串s和t，当且仅当s.equals(t)为真时，s.intern() &#x3D;&#x3D; t.intern()为真。</p>
<p>所有字面字符串和以字符串为值的常量表达式都是interned。</p>
<p>返回一个与此字符串内容相同的字符串，但保证是来自一个唯一的字符串池。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701549929-3447e97a-de0d-47bc-91a4-eb29dec725da.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u5b6e8295&margin=%5Bobject%20Object%5D&name=image.png&originHeight=441&originWidth=1065&originalType=url&ratio=1&rotation=0&showTitle=false&size=372365&status=done&style=none&taskId=uff4de93e-1c51-445e-a351-0f5f8556efa&title=" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701549753-2c07e298-bc11-48e3-87df-f686dff7e5b7.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u56fa143b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=336&originWidth=1063&originalType=url&ratio=1&rotation=0&showTitle=false&size=78953&status=done&style=none&taskId=uc251ea97-e3b7-4d33-9a87-2ca0303d46e&title=" alt="image.png"></p>
<h3 id="一，intern的使用：JDK6-vs-JDK7-x2F-8"><a href="#一，intern的使用：JDK6-vs-JDK7-x2F-8" class="headerlink" title="一，intern的使用：JDK6 vs JDK7&#x2F;8"></a>一，intern的使用：JDK6 vs JDK7&#x2F;8</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701549774-4872e035-76e0-4083-aaec-da6aab057ad7.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u1a322953&margin=%5Bobject%20Object%5D&name=image.png&originHeight=809&originWidth=1022&originalType=url&ratio=1&rotation=0&showTitle=false&size=86389&status=done&style=none&taskId=ue82e57e8-33ba-4bc2-bf74-d676f702923&title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701549828-29681724-87eb-416d-ad16-c75d4b2d800d.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u6c4fe5e6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=610&originWidth=1026&originalType=url&ratio=1&rotation=0&showTitle=false&size=191915&status=done&style=none&taskId=uaca7f057-2113-4c08-8e21-4d3803574fa&title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701549839-469e302c-e693-4e02-a39e-e0df4a733a2b.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u3c94d63b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=469&originWidth=1097&originalType=url&ratio=1&rotation=0&showTitle=false&size=205898&status=done&style=none&taskId=u4e48b0da-3106-4a15-998d-b95fe0d3d94&title=" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701550646-d6283d7d-21c4-4091-b91f-ebcb8ae833ba.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ue0431826&margin=%5Bobject%20Object%5D&name=image.png&originHeight=395&originWidth=822&originalType=url&ratio=1&rotation=0&showTitle=false&size=40861&status=done&style=none&taskId=u79350454-1da4-4f6a-9af7-e22263fd036&title=" alt="image.png"></p>
<p><strong>练习1：</strong></p>
<p>JDK6：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701550860-764166fa-57e6-453e-bfe8-9763eaa1eae8.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u035d81b7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=576&originWidth=1105&originalType=url&ratio=1&rotation=0&showTitle=false&size=215543&status=done&style=none&taskId=uc54f47c4-82a6-4c87-b837-df5b879e1c6&title=" alt="image.png"></p>
<p>JDK7：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701550928-17ee4db2-31c0-4b49-817e-dc4aa1ec14df.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u808d7d21&margin=%5Bobject%20Object%5D&name=image.png&originHeight=562&originWidth=1074&originalType=url&ratio=1&rotation=0&showTitle=false&size=212133&status=done&style=none&taskId=u9a792c26-e5b5-4d1b-a5c8-07768e48753&title=" alt="image.png"></p>
<p><strong>练习2：</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701551179-b3a1f0ec-4124-4517-9715-ff083ec05747.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ud2573815&margin=%5Bobject%20Object%5D&name=image.png&originHeight=592&originWidth=1122&originalType=url&ratio=1&rotation=0&showTitle=false&size=240101&status=done&style=none&taskId=u352a1542-fc94-46ad-bfe4-b7b067a040c&title=" alt="image.png"></p>
<h3 id="二，intern的效率测试：空间角度"><a href="#二，intern的效率测试：空间角度" class="headerlink" title="二，intern的效率测试：空间角度"></a>二，intern的效率测试：空间角度</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701551279-6587d8b9-bead-4292-bdaf-d61104b703ad.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u957530c3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1000&originWidth=1050&originalType=url&ratio=1&rotation=0&showTitle=false&size=77653&status=done&style=none&taskId=uf3d5b6a5-93ee-46e5-8816-2cd27b22d5c&title=" alt="image.png"></p>
<h3 id="三，StringTable的垃圾回收"><a href="#三，StringTable的垃圾回收" class="headerlink" title="三，StringTable的垃圾回收"></a>三，StringTable的垃圾回收</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701551764-e6e102c4-5d5a-4d30-9e47-57f799327eca.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u7ec679fa&margin=%5Bobject%20Object%5D&name=image.png&originHeight=884&originWidth=1049&originalType=url&ratio=1&rotation=0&showTitle=false&size=73566&status=done&style=none&taskId=u87b07ceb-c93b-4e40-a1ce-5ff686c8f80&title=" alt="image.png"></p>
<h3 id="四：G1中的String去重操作"><a href="#四：G1中的String去重操作" class="headerlink" title="四：G1中的String去重操作"></a>四：G1中的String去重操作</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701552694-1ec23dc3-0abe-4bae-8d5f-e4c0100c5038.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uff4b7329&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1877&originWidth=1051&originalType=url&ratio=1&rotation=0&showTitle=false&size=249019&status=done&style=none&taskId=ub0956120-3379-4062-8cca-7685c493d17&title=" alt="image.png"></p>
<h1 id="垃圾回收概述及算法"><a href="#垃圾回收概述及算法" class="headerlink" title="垃圾回收概述及算法"></a>垃圾回收概述及算法</h1><h2 id="垃圾回收概述"><a href="#垃圾回收概述" class="headerlink" title="垃圾回收概述"></a>垃圾回收概述</h2><h3 id="一，垃圾回收概述"><a href="#一，垃圾回收概述" class="headerlink" title="一，垃圾回收概述"></a>一，垃圾回收概述</h3><h4 id="1，什么是垃圾？"><a href="#1，什么是垃圾？" class="headerlink" title="1，什么是垃圾？"></a>1，什么是垃圾？</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701641712-936948e5-4424-4777-88c1-ae89272bca1a.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u848a5cb0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=450&originWidth=478&originalType=url&ratio=1&rotation=0&showTitle=false&size=35433&status=done&style=none&taskId=u538b96c3-22fe-4023-8b9d-1d9875ad440&title=" alt="image.png"></p>
<ul>
<li><p>垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。</p>
</li>
<li><p>关于垃圾收集有三个经典问题：</p>
</li>
<li><p>哪些内存需要回收？</p>
</li>
<li><p>什么时候回收？</p>
</li>
<li><p>如何回收？</p>
</li>
<li><p>垃圾收集机制是Java的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。</p>
</li>
</ul>
<h4 id="2，大厂面试题"><a href="#2，大厂面试题" class="headerlink" title="2，大厂面试题"></a>2，大厂面试题</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701641756-910ee23d-3d9d-4154-a35d-4fb4fb5c744c.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uee540be5&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1472&originWidth=1010&originalType=url&ratio=1&rotation=0&showTitle=false&size=90313&status=done&style=none&taskId=uf4b4fbbc-64f3-4407-a0c1-6ceccfc3258&title=" alt="image.png"></p>
<h4 id="3，什么是垃圾？"><a href="#3，什么是垃圾？" class="headerlink" title="3，什么是垃圾？"></a>3，什么是垃圾？</h4><p>An object is considered garbage when it can no longer be reached from any pointer in the running program</p>
<p>垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。</p>
<p>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序的结束，被保留的空间无法被其它对象使用，甚至可能导致内存溢出。</p>
<h4 id="4，为什么需要GC"><a href="#4，为什么需要GC" class="headerlink" title="4，为什么需要GC"></a>4，为什么需要GC</h4><p><strong>想要学习GC，首先需要理解为什么需要GC？</strong></p>
<p>对于高级语言来说，一个基本认知是如果不进行垃圾回收，内存迟早都会被消耗完，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。</p>
<p>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便JVM将整理出的内存分配给新的对象。</p>
<p>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序的正常进行。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</p>
<h4 id="5，早期垃圾回收"><a href="#5，早期垃圾回收" class="headerlink" title="5，早期垃圾回收"></a>5，早期垃圾回收</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701641751-40b0d952-e2d0-435c-991a-dbf27068fade.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u776cf894&margin=%5Bobject%20Object%5D&name=image.png&originHeight=823&originWidth=1079&originalType=url&ratio=1&rotation=0&showTitle=false&size=82748&status=done&style=none&taskId=u6622ea75-be12-44f5-be1e-5c23748f635&title=" alt="image.png"></p>
<h4 id="6，Java垃圾回收机制"><a href="#6，Java垃圾回收机制" class="headerlink" title="6，Java垃圾回收机制"></a>6，Java垃圾回收机制</h4><ul>
<li><p>自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险</p>
<ul>
<li>没有垃圾回收器，java也会和cpp一样，各种悬垂指针，野指针，泄露问题让你头疼不已。</li>
</ul>
</li>
<li><p>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发</p>
</li>
<li><p>oracle官网关于垃圾回收的介绍 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html</a></p>
</li>
<li><p><strong>担忧</strong></p>
</li>
<li><p>对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力。</p>
</li>
<li><p>此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见outofMemoryError时，快速地根据错误异常日志定位问题和解决问题。</p>
</li>
<li><p>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节。</p>
</li>
</ul>
<h5 id="GC主要关注的区域"><a href="#GC主要关注的区域" class="headerlink" title="GC主要关注的区域"></a>GC主要关注的区域</h5><ul>
<li>GC主要关注于 方法区 和堆中的垃圾收集</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701641810-e52760fa-96b7-4201-8162-f7508fc84991.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u32928307&margin=%5Bobject%20Object%5D&name=image.png&originHeight=476&originWidth=681&originalType=url&ratio=1&rotation=0&showTitle=false&size=159753&status=done&style=none&taskId=u31c92e36-f289-4dcd-9462-ded8bf73212&title=" alt="image.png"></p>
<ul>
<li><p>垃圾收集器可以对年轻代回收，也可以对老年代回收，甚至是全栈和方法区的回收。其中，Java堆是垃圾收集器的工作重点</p>
</li>
<li><p>从次数上讲：</p>
</li>
<li><p>频繁收集Young区</p>
</li>
<li><p>较少收集Old区</p>
</li>
<li><p>基本不收集Perm区（元空间）</p>
</li>
</ul>
<h2 id="垃圾回收相关算法——标记阶段"><a href="#垃圾回收相关算法——标记阶段" class="headerlink" title="垃圾回收相关算法——标记阶段"></a>垃圾回收相关算法——标记阶段</h2><h3 id="对象存活判断"><a href="#对象存活判断" class="headerlink" title="对象存活判断"></a>对象存活判断</h3><p>在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为垃圾标记阶段。</p>
<p>那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</p>
<p>判断对象存活一般有两种方式：引用计数算法和可达性分析算法。</p>
<h3 id="一，-标记阶段"><a href="#一，-标记阶段" class="headerlink" title="一， 标记阶段"></a>一， 标记阶段</h3><h4 id="方式一：引用计数算法"><a href="#方式一：引用计数算法" class="headerlink" title="方式一：引用计数算法"></a>方式一：引用计数算法</h4><p>引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。</p>
<p>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</p>
<p>优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</p>
<p>缺点：</p>
<ul>
<li>它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。</li>
<li>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。</li>
<li>引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。</li>
</ul>
<h5 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h5><p>当p的指针断开的时候，内部的引用形成一个循环，这就是循环引用</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701787244-19d75e80-d026-40fe-a9c4-c5a13fa46057.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9d743124&margin=%5Bobject%20Object%5D&name=image.png&originHeight=516&originWidth=942&originalType=url&ratio=1&rotation=0&showTitle=false&size=107150&status=done&style=none&taskId=u69cd7a85-b23f-4c17-9059-b34fb7aaa2e&title=" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701787371-706bf3b1-88aa-4fe6-84fa-7c399f277dd5.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u2c2fd1ba&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1432&originWidth=1071&originalType=url&ratio=1&rotation=0&showTitle=false&size=268782&status=done&style=none&taskId=u9335147d-6dd1-453d-a2a8-74e7e986b9a&title=" alt="image.png"></p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制。</p>
<p>具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。</p>
<p>Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。</p>
<p>Python如何解决循环引用？</p>
<ul>
<li>手动解除：很好理解，就是在合适的时机，解除引用关系。 使用弱引用weakref，weakref是Python提供的标准库，旨在解决循环引用。</li>
</ul>
<h4 id="方式二：可达性分析算法"><a href="#方式二：可达性分析算法" class="headerlink" title="方式二：可达性分析算法"></a>方式二：可达性分析算法</h4><h5 id="可达性分析算法（根搜索算法、追踪性垃圾收集）"><a href="#可达性分析算法（根搜索算法、追踪性垃圾收集）" class="headerlink" title="可达性分析算法（根搜索算法、追踪性垃圾收集）"></a>可达性分析算法（根搜索算法、追踪性垃圾收集）</h5><p>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。</p>
<p>相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫作追踪性垃圾收集（Tracing Garbage Collection）</p>
<p>所谓”GCRoots”根集合就是一组必须活跃的引用。</p>
<h5 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h5><ul>
<li>可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。</li>
<li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链（Reference Chain）</li>
<li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。</li>
<li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701909773-afa1935b-85a2-4c65-a758-f6a4beb8cabd.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u8e8d4155&margin=%5Bobject%20Object%5D&name=image.png&originHeight=524&originWidth=779&originalType=url&ratio=1&rotation=0&showTitle=false&size=112517&status=done&style=none&taskId=u49e66fdb-e50f-4a56-8832-daccb318e64&title=" alt="image.png"></p>
<p>在Java语言中，GC Roots包括以下几类元素：</p>
<ul>
<li>虚拟机栈中引用的对象 <ul>
<li>比如：各个线程被调用的方法中使用到的参数、局部变量等。</li>
</ul>
</li>
<li>本地方法栈内JNI（通常说的本地方法）引用的对象</li>
<li>方法区中类静态属性引用的对象 <ul>
<li>比如：Java类的引用类型静态变量</li>
</ul>
</li>
<li>方法区中常量引用的对象 <ul>
<li>比如：字符串常量池（String Table）里的引用</li>
</ul>
</li>
<li>所有被同步锁synchronized持有的对象</li>
<li>Java虚拟机内部的引用。 <ul>
<li>基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError），系统类加载器。</li>
<li>反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701909915-69eef607-a77f-4495-9303-a5291d0ccfda.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u89806c15&margin=%5Bobject%20Object%5D&name=image.png&originHeight=539&originWidth=756&originalType=url&ratio=1&rotation=0&showTitle=false&size=279253&status=done&style=none&taskId=ua010a551-a565-4a50-9f00-d41f9f0fe7e&title=" alt="image.png"></p>
<p>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：分代收集和局部回收（PartialGC）。</p>
<p>如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GCRoots集合中去考虑，才能保证可达性分析的准确性。</p>
<p>小技巧：由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root。</p>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。</p>
<p>这点也是导致GC进行时必须“stop The World”的一个重要原因。</p>
<ul>
<li>即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。</li>
</ul>
<h2 id="对象的finalization机制"><a href="#对象的finalization机制" class="headerlink" title="对象的finalization机制"></a>对象的finalization机制</h2><ul>
<li><p>Java语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。</p>
</li>
<li><p>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法。</p>
</li>
<li><p>finalize() 方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</p>
</li>
<li><p>永远不要主动调用某个对象的finalize()方法I应该交给垃圾回收机制调用。理由包括下面三点：</p>
</li>
<li><p>在finalize()时可能会导致对象复活。</p>
</li>
<li><p>finalize()方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize()方法将没有执行机会。</p>
</li>
<li><p>一个糟糕的finalize()会严重影响Gc的性能。</p>
</li>
<li><p>从功能上来说，finalize()方法与C中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize()方法在本质上不同于C中的析构函数。</p>
</li>
<li><p>由于finalize()方法的存在，虚拟机中的对象一般处于三种可能的状态。</p>
</li>
</ul>
<h3 id="一，生存还是死亡？"><a href="#一，生存还是死亡？" class="headerlink" title="一，生存还是死亡？"></a>一，生存还是死亡？</h3><ul>
<li><p>如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。一个无法触及的对象有可能在某一个条件下“复活”自己，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：</p>
</li>
<li><p>可触及的：从根节点开始，可以到达这个对象。</p>
</li>
<li><p>可复活的：对象的所有引用都被释放，但是对象有可能在finalize()中复活。</p>
</li>
<li><p>不可触及的：对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，<strong>因为finalize()只会被调用一次</strong>。</p>
</li>
<li><p>以上3种状态中，是由于inalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</p>
</li>
</ul>
<h3 id="二，具体过程"><a href="#二，具体过程" class="headerlink" title="二，具体过程"></a>二，具体过程</h3><p>判定一个对象objA是否可回收，至少要经历两次标记过程：</p>
<ol>
<li>如果对象objA到GC Roots没有引用链，则进行第一次标记。</li>
<li>进行筛选，判断此对象是否有必要执行finalize()方法</li>
<li>如果对象objA没有重写finalize()方法，或者finalize()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。</li>
<li>如果对象objA重写了finalize()方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize()方法执行。</li>
<li><strong>finalize()方法是对象逃脱死亡的最后机会</strong>，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701947314-90f1a887-2459-482f-8203-e53ac39f2727.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u23617756&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1516&originWidth=1089&originalType=url&ratio=1&rotation=0&showTitle=false&size=116251&status=done&style=none&taskId=u2f7567f5-91ef-4adb-a79e-feb8128df06&title=" alt="image.png"></p>
<h2 id="MAT与JProfiler的GC-Roots溯源"><a href="#MAT与JProfiler的GC-Roots溯源" class="headerlink" title="MAT与JProfiler的GC Roots溯源"></a>MAT与JProfiler的GC Roots溯源</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650701983768-a742b535-4090-49a9-b7d4-090dbb958ab0.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u0e0f2708&margin=%5Bobject%20Object%5D&name=image.png&originHeight=2686&originWidth=1098&originalType=url&ratio=1&rotation=0&showTitle=false&size=855105&status=done&style=none&taskId=u6721337f-73b7-4fdd-91d9-c02ce1a378d&title=" alt="image.png"></p>
<h2 id="垃圾回收相关算法——清除阶段"><a href="#垃圾回收相关算法——清除阶段" class="headerlink" title="垃圾回收相关算法——清除阶段"></a>垃圾回收相关算法——清除阶段</h2><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。</p>
<p>目前在JVM中比较常见的三种垃圾收集算法是标记一清除算法（Mark-Sweep）、复制算法（copying）、标记-压缩算法（Mark-Compact）</p>
<h4 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h4><p>标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并并应用于Lisp语言。</p>
<h5 id="一，执行过程"><a href="#一，执行过程" class="headerlink" title="一，执行过程"></a>一，执行过程</h5><ul>
<li><p>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除</p>
</li>
<li><p>标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。 </p>
</li>
<li><p>清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收</p>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650702090561-3ff0ad48-89e1-4181-9b85-7968e6568a74.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u40171925&margin=%5Bobject%20Object%5D&name=image.png&originHeight=652&originWidth=832&originalType=url&ratio=1&rotation=0&showTitle=false&size=128374&status=done&style=none&taskId=u3821320d-ac2b-4f29-b74b-789c8a4085d&title=" alt="image.png"></p>
<h5 id="二，缺点"><a href="#二，缺点" class="headerlink" title="二，缺点"></a>二，缺点</h5><ul>
<li>标记清除算法的效率不算高</li>
<li>在进行GC的时候，需要停止整个应用程序，用户体验较差</li>
<li>这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个空闲列表</li>
</ul>
<h5 id="三，何为清除"><a href="#三，何为清除" class="headerlink" title="三，何为清除"></a>三，何为清除</h5><p>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放覆盖原有的地址。</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><h4 id="复制（Copying）算法"><a href="#复制（Copying）算法" class="headerlink" title="复制（Copying）算法"></a>复制（Copying）算法</h4><p>为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky于1963年发表了著名的论文，“使用双存储区的Lisp语言垃圾收集器CA LISP Garbage Collector Algorithm Using Serial Secondary Storage）”。M.L.Minsky在该论文中描述的算法被人们称为复制（Copying）算法，它也被M.L.Minsky本人成功地引入到了Lisp语言的一个实现版本中。</p>
<h4 id="一，核心思想"><a href="#一，核心思想" class="headerlink" title="一，核心思想"></a>一，核心思想</h4><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650702156239-6fa40c4d-df56-476c-9616-d46a4a5840bc.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u67639ff7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=539&originWidth=1040&originalType=url&ratio=1&rotation=0&showTitle=false&size=113511&status=done&style=none&taskId=u964cacc8-b137-44d7-9ab1-b5c9f74b2c2&title=" alt="image.png"></p>
<h4 id="二，优点"><a href="#二，优点" class="headerlink" title="二，优点"></a>二，优点</h4><ul>
<li>没有标记和清除过程，实现简单，运行高效</li>
<li>复制过去以后保证空间的连续性，不会出现“碎片”问题。</li>
</ul>
<h4 id="三，缺点"><a href="#三，缺点" class="headerlink" title="三，缺点"></a>三，缺点</h4><ul>
<li>此算法的缺点也是很明显的，就是需要两倍的内存空间。</li>
<li>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小</li>
</ul>
<h4 id="四，特别的"><a href="#四，特别的" class="headerlink" title="四，特别的"></a>四，特别的</h4><p>如果系统中的垃圾对象很多，复制算法不会很理想，因为复制算法需要复制的存活对象数量并不会太大，或者说非常低才行</p>
<h4 id="五，应用场景"><a href="#五，应用场景" class="headerlink" title="五，应用场景"></a>五，应用场景</h4><p>在新生代，对常规应用的垃圾回收，一次通常可以回收70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650702156251-2c7eec83-41fa-4db9-b025-b6c0f4844e4d.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ub6e3073f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=415&originWidth=799&originalType=url&ratio=1&rotation=0&showTitle=false&size=83983&status=done&style=none&taskId=u59492047-1855-4e03-b7e4-e2fbe6be770&title=" alt="image.png"></p>
<h3 id="标记-压缩（整理）算法"><a href="#标记-压缩（整理）算法" class="headerlink" title="标记-压缩（整理）算法"></a>标记-压缩（整理）算法</h3><h4 id="标记-压缩（或标记-整理、Mark-Compact）算法"><a href="#标记-压缩（或标记-整理、Mark-Compact）算法" class="headerlink" title="标记-压缩（或标记-整理、Mark-Compact）算法"></a>标记-压缩（或标记-整理、Mark-Compact）算法</h4><p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。</p>
<p>标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JVM的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact）算法由此诞生。</p>
<p>1970年前后，G.L.Steele、C.J.Chene和D.s.Wise等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。</p>
<h4 id="一，执行过程-1"><a href="#一，执行过程-1" class="headerlink" title="一，执行过程"></a>一，执行过程</h4><ol>
<li>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象 </li>
<li>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。 </li>
<li>之后，清理边界外所有的空间。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650702224736-ae1e3cc6-c6ab-40ee-beba-9a5a8a48c397.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u8b7b8be6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=538&originWidth=667&originalType=url&ratio=1&rotation=0&showTitle=false&size=113741&status=done&style=none&taskId=uca262698-4ee9-495d-8ab3-78fcb11dc90&title=" alt="image.png"></p>
<p>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（Mark-Sweep-Compact）算法。</p>
<p>二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</p>
<h4 id="二，指针碰撞（Bump-the-Pointer）"><a href="#二，指针碰撞（Bump-the-Pointer）" class="headerlink" title="二，指针碰撞（Bump the Pointer）"></a>二，指针碰撞（Bump the Pointer）</h4><p>如果内存空间以规整和有序的方式分布，即已用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做<strong>指针碰撞（Bump tHe Pointer）</strong>。</p>
<h4 id="三，优点-1"><a href="#三，优点-1" class="headerlink" title="三，优点"></a>三，优点</h4><ul>
<li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</li>
<li>消除了复制算法当中，内存减半的高额代价。</li>
</ul>
<h4 id="四，缺点"><a href="#四，缺点" class="headerlink" title="四，缺点"></a>四，缺点</h4><ul>
<li>从效率上来说，标记-整理算法要低于复制算法。</li>
<li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址</li>
<li>移动过程中，需要全程暂停用户应用程序。即：STW</li>
</ul>
<h4 id="小结：-1"><a href="#小结：-1" class="headerlink" title="小结："></a>小结：</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650702224698-ebf88486-9940-49fc-b97b-3b6f631733c2.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u91d2661d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=599&originWidth=1047&originalType=url&ratio=1&rotation=0&showTitle=false&size=54779&status=done&style=none&taskId=u46a9f6ac-3570-4578-a5a6-1e296e2277d&title=" alt="image.png"></p>
<h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。</p>
<p>分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p>
<p>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p>
<p><strong>目前几乎所有的GC都采用分代手机算法执行垃圾回收的。</strong></p>
<p>在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p>
<h3 id="一，年轻代（Young-Gen）"><a href="#一，年轻代（Young-Gen）" class="headerlink" title="一，年轻代（Young Gen）"></a>一，年轻代（Young Gen）</h3><p>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</p>
<p>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</p>
<h3 id="二，老年代（Tenured-Gen）"><a href="#二，老年代（Tenured-Gen）" class="headerlink" title="二，老年代（Tenured Gen）"></a>二，老年代（Tenured Gen）</h3><p>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</p>
<p>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。</p>
<ul>
<li>Mark阶段的开销与存活对象的数量成正比。</li>
<li>Sweep阶段的开销与所管理区域的大小成正相关。</li>
<li>Compact阶段的开销与存活对象的数据成正比。</li>
</ul>
<p>以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理。</p>
<p>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代</p>
<h2 id="增量收集算法、分区算法"><a href="#增量收集算法、分区算法" class="headerlink" title="增量收集算法、分区算法"></a>增量收集算法、分区算法</h2><h4 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h4><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种Stop the World的状态。在Stop the World状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。</p>
<h5 id="一，基本思想"><a href="#一，基本思想" class="headerlink" title="一，基本思想"></a>一，基本思想</h5><p>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</p>
<p>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</p>
<h5 id="二，缺点-1"><a href="#二，缺点-1" class="headerlink" title="二，缺点"></a>二，缺点</h5><p>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</p>
<h4 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h4><p>一般来说，在相同条件下，堆空间越大，一次Gc时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</p>
<p>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。</p>
<p>每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650702306182-7ba9374d-de46-43f3-9b7f-364fd954bee6.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u5acb9dc2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=517&originWidth=781&originalType=url&ratio=1&rotation=0&showTitle=false&size=302996&status=done&style=none&taskId=u0ddc8ffd-7179-4599-9992-763d355bfed&title=" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650702305999-d5ca46f5-021c-4c14-b139-e6ad2abbebdc.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=udddc3495&margin=%5Bobject%20Object%5D&name=image.png&originHeight=155&originWidth=1041&originalType=url&ratio=1&rotation=0&showTitle=false&size=14627&status=done&style=none&taskId=u5bf8fdec-7aa4-41bd-a7f8-3b2a01fc433&title=" alt="image.png"></p>
<h1 id="垃圾回收相关概念"><a href="#垃圾回收相关概念" class="headerlink" title="垃圾回收相关概念"></a>垃圾回收相关概念</h1><h2 id="一，System-gc-的理解"><a href="#一，System-gc-的理解" class="headerlink" title="一，System.gc()的理解"></a>一，System.gc()的理解</h2><p>在默认情况下，通过system.gc()或者Runtime.getRuntime().gc() 的调用，会显式触发Full GC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</p>
<p>然而System.gc() 调用附带一个免责声明，无法保证对垃圾收集器的调用。(<strong>不能确保立即生效</strong>)</p>
<p>JVM实现者可以通过System.gc() 调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650702370112-0f7efa93-5f7b-414e-b597-02da1ac18f3c.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u8fd13a56&margin=%5Bobject%20Object%5D&name=image.png&originHeight=471&originWidth=999&originalType=url&ratio=1&rotation=0&showTitle=false&size=53045&status=done&style=none&taskId=ua31c3f5e-6cb1-4495-a5e0-67dc578069e&title=" alt="image.png"></p>
<h2 id="内存溢出与内存泄露与STW"><a href="#内存溢出与内存泄露与STW" class="headerlink" title="内存溢出与内存泄露与STW"></a>内存溢出与内存泄露与STW</h2><h3 id="一，内存溢出（OOM）"><a href="#一，内存溢出（OOM）" class="headerlink" title="一，内存溢出（OOM）"></a>一，内存溢出（OOM）</h3><p>内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。</p>
<p>由于GC一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现ooM的情况。</p>
<p>大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的Full GC操作，这时候会回收大量的内存，供应用程序继续使用。</p>
<p>javadoc中对OutOfMemoryError的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。</p>
<p>首先说没有空闲内存的情况：说明Java虚拟机的堆内存不够。原因有二：</p>
<ol>
<li><strong>Java虚拟机的堆内存设置不够。</strong><br>比如：可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小。我们可以通过参数-Xms 、-Xmx来调整。 </li>
<li><strong>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）</strong><br>对于老版本的Oracle JDK，因为永久代的大小是有限的，并且JVM对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现OutOfMemoryError也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似intern字符串缓存占用太多空间，也会导致OOM问题。对应的异常信息，会标记出来和永久代相关：“java.lang.OutOfMemoryError: PermGen space”。<br>随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的ooM有所改观，出现OOM，异常信息则变成了：“java.lang.OutofMemoryError:Metaspace”。直接内存不足，也会导致OOM。</li>
</ol>
<p>这里面隐含着一层意思是，在抛出OutOfMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间。</p>
<ul>
<li><p>例如：在引用机制分析中，涉及到JVM会去尝试回收软引用指向的对象等。</p>
</li>
<li><p>在java.nio.BIts.reserveMemory()方法中，我们能清楚的看到，System.gc()会被调用，以清理空间。</p>
</li>
<li><p>当然，也不是在任何情况下垃圾收集器都会被触发的</p>
<ul>
<li>比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出OutOfMemoryError。</li>
</ul>
</li>
</ul>
<h3 id="二，内存泄漏（Memory-Leak）"><a href="#二，内存泄漏（Memory-Leak）" class="headerlink" title="二，内存泄漏（Memory Leak）"></a>二，内存泄漏（Memory Leak）</h3><p>也称作“存储渗漏”。严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。</p>
<p>但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致00M，也可以叫做宽泛意义上的“内存泄漏”。</p>
<p>尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现OutOfMemory异常，导致程序崩溃。</p>
<p>注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650702401304-bb089921-301b-490b-a81e-725fa00588ed.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u97c791a2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=511&originWidth=1079&originalType=url&ratio=1&rotation=0&showTitle=false&size=254148&status=done&style=none&taskId=u99878d4a-401f-430d-ab2a-02a4cb48b26&title=" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650702401185-4a3dcaa4-b64f-4003-8a35-f173f22ede23.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u2b7d2e7f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=296&originWidth=1054&originalType=url&ratio=1&rotation=0&showTitle=false&size=35430&status=done&style=none&taskId=ufb097c65-90a0-453f-899f-af4910297e0&title=" alt="image.png"></p>
<h3 id="三，Stop-The-World"><a href="#三，Stop-The-World" class="headerlink" title="三，Stop The World"></a>三，Stop The World</h3><p>Stop-the-World，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。</p>
<p>可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿。</p>
<ul>
<li>分析工作必须在一个能确保一致性的快照中进行</li>
<li>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</li>
<li>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</li>
</ul>
<p>被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少STW的发生。</p>
<p>STW事件和采用哪款GC无关，所有的GC都有这个事件。</p>
<p>哪怕是G1也不能完全避免Stop-the-World情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。</p>
<p>STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉。</p>
<p><strong>开发中不要用System.gc() 会导致Stop-the-World的发生</strong>。</p>
<h2 id="垃圾回收的并行与并发"><a href="#垃圾回收的并行与并发" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h2><h4 id="并发（Concurrent）"><a href="#并发（Concurrent）" class="headerlink" title="并发（Concurrent）"></a>并发（Concurrent）</h4><p>在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行。</p>
<p>并发不是真正意义上的“同时进行”，只是CPU把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换，由于CPU处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650702434204-bf383107-d1aa-4a98-a92f-98c54ca2e2f1.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u5a5c318d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=307&originWidth=502&originalType=url&ratio=1&rotation=0&showTitle=false&size=74988&status=done&style=none&taskId=ub12a5816-7a43-4ee9-a7e0-9944af99e02&title=" alt="image.png"></p>
<h4 id="并行（Parallel）"><a href="#并行（Parallel）" class="headerlink" title="并行（Parallel）"></a>并行（Parallel）</h4><p>当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，我们称之为并行（Parallel）。</p>
<p>其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行。</p>
<p>适合科学计算，后台处理等弱交互场景</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650702434177-57d2314a-3109-4554-a062-e4db224468b9.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u8dd20a64&margin=%5Bobject%20Object%5D&name=image.png&originHeight=285&originWidth=490&originalType=url&ratio=1&rotation=0&showTitle=false&size=54227&status=done&style=none&taskId=ufdd50b45-75d8-4641-9314-3d228f36270&title=" alt="image.png"></p>
<h4 id="并发-vs-并行"><a href="#并发-vs-并行" class="headerlink" title="并发 vs 并行"></a>并发 vs 并行</h4><ul>
<li>并发，指的是多个事情，在同一时间段内同时发生了。 </li>
<li>并行，指的是多个事情，在同一时间点上同时发生了。 </li>
<li>并发的多个任务之间是互相抢占资源的。 </li>
<li>并行的多个任务之间是不互相抢占资源的。 </li>
<li>只有在多CPU或者一个CPU多核的情况中，才会发生并行。 </li>
<li>否则，看似同时发生的事情，其实都是并发执行的。</li>
</ul>
<h4 id="垃圾回收的并发与并行"><a href="#垃圾回收的并发与并行" class="headerlink" title="垃圾回收的并发与并行"></a>垃圾回收的并发与并行</h4><h5 id="一，并行（Parallel）"><a href="#一，并行（Parallel）" class="headerlink" title="一，并行（Parallel）"></a>一，并行（Parallel）</h5><p>指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。如ParNew、Parallel Scavenge、Parallel Old；</p>
<h5 id="二，串行（Serial）"><a href="#二，串行（Serial）" class="headerlink" title="二，串行（Serial）"></a>二，串行（Serial）</h5><p>相较于并行的概念，单线程执行。如果内存不够，则程序暂停，启动JM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650702434249-5d368e8c-4534-4c53-860d-840c38374a38.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u7be9d313&margin=%5Bobject%20Object%5D&name=image.png&originHeight=323&originWidth=1143&originalType=url&ratio=1&rotation=0&showTitle=false&size=104439&status=done&style=none&taskId=u028b9a31-ef15-4241-b9b5-c3942bf3d35&title=" alt="image.png"></p>
<h5 id="三，并发（Concurrent）"><a href="#三，并发（Concurrent）" class="headerlink" title="三，并发（Concurrent）"></a>三，并发（Concurrent）</h5><p>指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上；如：CMS、G1</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650702434252-50d3d1ae-6a83-43a2-b715-48b272c8cb9c.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u3ac9062b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=306&originWidth=649&originalType=url&ratio=1&rotation=0&showTitle=false&size=77551&status=done&style=none&taskId=u3d6f03f4-b64b-4900-bc7f-6211ed08836&title=" alt="image.png"></p>
<h2 id="安全点与安全区域"><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h2><h3 id="一，安全点"><a href="#一，安全点" class="headerlink" title="一，安全点"></a>一，安全点</h3><p>程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点（Safepoint）”。</p>
<p>Safe Point的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。比如：选择一些执行时间较长的指令作为Safe Point，如方法调用、循环跳转和异常跳转等。</p>
<p>如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？</p>
<ul>
<li><p>抢先式中断：（目前没有虚拟机采用了）</p>
<ul>
<li>首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</li>
</ul>
</li>
<li><p>主动式中断</p>
<ul>
<li>设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。（有轮询的机制）</li>
</ul>
</li>
</ul>
<h3 id="二，安全区域（Safe-Resion）"><a href="#二，安全区域（Safe-Resion）" class="headerlink" title="二，安全区域（Safe Resion）"></a>二，安全区域（Safe Resion）</h3><p>Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？例如线程处于Sleep 状态或Blocked 状态，这时候线程无法响应JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。</p>
<p>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始Gc都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650702499644-5865ef5e-0c59-46e9-ba65-92f57ea9ba51.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u40a9afee&margin=%5Bobject%20Object%5D&name=image.png&originHeight=246&originWidth=1051&originalType=url&ratio=1&rotation=0&showTitle=false&size=37361&status=done&style=none&taskId=uc5824753-4347-4e4f-a8ee-85f0edc3000&title=" alt="image.png"></p>
<h2 id="强软弱虚引用"><a href="#强软弱虚引用" class="headerlink" title="强软弱虚引用"></a>强软弱虚引用</h2><p>我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。</p>
<p><strong>【既偏门又非常高频的面试题】强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？</strong></p>
<p>在JDK1.2版之后，Java对引用的概念进行了扩充，将引用分为：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）这4种引用强度依次逐渐减弱。</p>
<p>除强引用外，其他3种引用均可以在java.lang.ref包中找到它们的身影。如下图，显示了这3种引用类型对应的类，开发人员可以在应用程序中直接使用它们。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650702557892-16ebcfb4-a9c4-4012-bac3-cf57d503a4b5.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua2092e8b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=150&originWidth=442&originalType=url&ratio=1&rotation=0&showTitle=false&size=81572&status=done&style=none&taskId=u6e4c413f-a04d-49ac-ae2a-791ca329708&title=" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650702557894-f0fc4f8b-1c77-4f43-a574-364d21881883.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ud3eb5c4d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=430&originWidth=1050&originalType=url&ratio=1&rotation=0&showTitle=false&size=88492&status=done&style=none&taskId=u99fddc0d-4b17-4730-ba0e-89894f7f650&title=" alt="image.png"></p>
<h3 id="一，强引用（Strong-Reference）——不回收"><a href="#一，强引用（Strong-Reference）——不回收" class="headerlink" title="一，强引用（Strong Reference）——不回收"></a>一，强引用（Strong Reference）——不回收</h3><p>在Java程序中，最常见的引用类型是强引用（普通系统99%以上都是强引用），也就是我们最常见的普通对象引用，也是默认的引用类型。</p>
<p>当在Java语言中使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</p>
<p>强引用的对象是<strong>可触及的</strong>，垃圾收集器就永远不会回收掉被引用的对象。</p>
<p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为nu11，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</p>
<p>相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，<strong>强引用是造成Java内存泄漏的主要原因之一</strong>。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650702558047-475a6734-a01b-456c-8659-6d7d64d99b53.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u5cd487c1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1382&originWidth=1078&originalType=url&ratio=1&rotation=0&showTitle=false&size=302465&status=done&style=none&taskId=ufc612a6d-e708-4ee9-a596-ef5fced1a72&title=" alt="image.png"></p>
<h3 id="二，软引用（Soft-Reference）——内存不足即回收"><a href="#二，软引用（Soft-Reference）——内存不足即回收" class="headerlink" title="二，软引用（Soft Reference）——内存不足即回收"></a>二，软引用（Soft Reference）——内存不足即回收</h3><ul>
<li>软引用是用来描述一些还有用，但非必需的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</li>
<li>软引用通常用来实现内存敏感的缓存。比如：高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</li>
<li>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue）。</li>
<li>类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</li>
<li>在JDK1.2版之后提供了java.lang.ref.SoftReference类来实现软引用</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650702557879-c81cc41d-5cb4-4987-8eb6-6c45ec223104.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u33ac8371&margin=%5Bobject%20Object%5D&name=image.png&originHeight=164&originWidth=1002&originalType=url&ratio=1&rotation=0&showTitle=false&size=16058&status=done&style=none&taskId=u5a71615d-4e86-4856-836b-73741cff7f8&title=" alt="image.png"></p>
<h3 id="三，弱引用（Weak-Reference）——发现即回收"><a href="#三，弱引用（Weak-Reference）——发现即回收" class="headerlink" title="三，弱引用（Weak Reference）——发现即回收"></a>三，弱引用（Weak Reference）——发现即回收</h3><p>弱引用也是用来描述那些非必需对象，只被弱引用关联的对象只能生存到下一次垃圾收集发生为止。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。</p>
<p>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。</p>
<p>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</p>
<p>软引用、弱引用都非常适合来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</p>
<p>在JDK1.2版之后提供了WeakReference类来实现弱引用</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650702557880-0118bd2d-ca07-48ce-be2c-e43d50ff816f.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u45b98683&margin=%5Bobject%20Object%5D&name=image.png&originHeight=415&originWidth=1036&originalType=url&ratio=1&rotation=0&showTitle=false&size=52357&status=done&style=none&taskId=u5f0c7c39-be4d-4dad-ab11-e8881ef8681&title=" alt="image.png"></p>
<h3 id="四，虚引用（Phantom-Reference）——对象回收跟踪"><a href="#四，虚引用（Phantom-Reference）——对象回收跟踪" class="headerlink" title="四，虚引用（Phantom Reference）——对象回收跟踪"></a>四，虚引用（Phantom Reference）——对象回收跟踪</h3><p>也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个。</p>
<p>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</p>
<p>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get()方法取得对象时，总是null</p>
<p>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</p>
<p>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</p>
<p>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</p>
<p>在JDK1.2版之后提供了PhantomReference类来实现虚引用。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26481411/1650702558659-d63762a2-8702-4990-9f89-406189567f0f.png#clientId=u63881b7d-4089-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uefe448d3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=189&originWidth=1001&originalType=url&ratio=1&rotation=0&showTitle=false&size=18155&status=done&style=none&taskId=u4790cd59-20fb-460f-a837-10d3101aad2&title=" alt="image.png"></p>
<h3 id="五，终结器引用"><a href="#五，终结器引用" class="headerlink" title="五，终结器引用"></a>五，终结器引用</h3><p>它用于实现对象的finalize() 方法，也可以称为终结器引用。无需手动编码，其内部配合引用队列使用。</p>
<p>在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象调用它的finalize()方法，第二次GC时才回收被引用的对象</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://ishuaige.github.io">coderbin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://ishuaige.github.io/coderbin/ef33a712.html">http://ishuaige.github.io/coderbin/ef33a712.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://ishuaige.github.io" target="_blank">coderbin</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a><a class="post-meta__tags" href="/tags/JVM/">JVM</a><a class="post-meta__tags" href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">垃圾回收</a><a class="post-meta__tags" href="/tags/%E5%86%85%E5%AD%98/">内存</a></div><div class="post_share"><div class="social-share" data-image="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/jvm.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/coderbin/44a1cd79.html"><img class="prev-cover" src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/cloud.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">微服务技术栈</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/coderbin/397c083a.html" title="Java8新特性"><img class="cover" src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/cover_java.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-10</div><div class="title">Java8新特性</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">coderbin</div><div class="author-info__description">他发着光骑着马，咋咋呼呼有点傻</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">47</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ishuaige"><i class="fab fa-github"></i><span>我的github仓库</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ishuaige" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">将有一天你会遇见美好的一切</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="toc-text">类加载子系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%B8%80"><span class="toc-text">类加载子系统一</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%BD%9C%E7%94%A8"><span class="toc-text">类加载子系统作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8ClassLoader%E7%9A%84%E8%A7%92%E8%89%B2"><span class="toc-text">类加载器ClassLoader的角色</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-text">类的加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80-%E5%8A%A0%E8%BD%BD"><span class="toc-text">一.加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C-%E9%93%BE%E6%8E%A5"><span class="toc-text">二.链接</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%AA%8C%E8%AF%81-Verify"><span class="toc-text">1.验证(Verify)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%87%86%E5%A4%87-Prepare"><span class="toc-text">2.准备(Prepare)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E8%A7%A3%E6%9E%90-Resolve"><span class="toc-text">3.解析(Resolve)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">三.初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E"><span class="toc-text">补充说明</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%BA%8C"><span class="toc-text">类加载子系统二</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%88%86%E7%B1%BB"><span class="toc-text">一.类加载器分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-%E4%BB%A3%E7%A0%81%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%9A"><span class="toc-text">二.代码获取类加载器：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89-%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88%E5%BC%95%E5%AF%BC%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8CBootstrap-ClassLoader%EF%BC%89%EF%BC%9A"><span class="toc-text">三.启动类加载器（引导类加载器，Bootstrap,ClassLoader）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B-%E6%89%A9%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88java9-%E5%B9%B3%E5%8F%B0%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">四.扩展类加载器（java9:平台类加载器)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%9AAppClassLoader%EF%BC%89"><span class="toc-text">五.应用程序类加载器（系统类加载器：AppClassLoader）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD-%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">六.用户自定义类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83-%E5%85%B3%E4%BA%8ECLassLoader"><span class="toc-text">七.关于CLassLoader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-text">八.双亲委派机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E4%BC%98%E5%8A%BF"><span class="toc-text">一.双亲委派机制优势</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%9D-%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6"><span class="toc-text">九.沙箱安全机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0"><span class="toc-text">运行时数据区概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%AD%90%E7%A8%8B%E5%BA%8F%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88PC%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89"><span class="toc-text">⭐程序寄存器（PC寄存器）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%AD%90%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-text">⭐虚拟机栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%A0%88%E5%92%8C%E5%A0%86"><span class="toc-text">一，内存中的栈和堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8C%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9"><span class="toc-text">二，基本内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%EF%BC%8C%E4%BC%98%E7%82%B9"><span class="toc-text">三，优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%EF%BC%8C%E6%A0%88%E7%9A%84%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D"><span class="toc-text">四，栈的存储单位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%EF%BC%8C%E6%A0%88%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-text">五，栈运行原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%EF%BC%8C%E6%A0%88%E5%B8%A7%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-text">六，栈帧的内部结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%EF%BC%88Local-variables%EF%BC%89"><span class="toc-text">局部变量表（Local variables）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8ESlot%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">关于Slot的理解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88-Operand-Stack"><span class="toc-text">操作数栈(Operand Stack)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%EF%BC%88%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%EF%BC%89%EF%BC%9A"><span class="toc-text">操作数栈（数组实现）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E9%A1%B6%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF%EF%BC%9A"><span class="toc-text">栈顶缓存技术：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%EF%BC%88%E6%88%96%E6%8C%87%E5%90%91%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%EF%BC%89"><span class="toc-text">动态链接（或指向运行时常量池的方法引用）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-text">指向运行时常量池的方法引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-text">常量池、运行时常量池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-text">方法的调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E9%93%BE%E6%8E%A5%E4%B8%8E%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%91%E5%AE%9A"><span class="toc-text">一，链接与方法的绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8C%E8%99%9A%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%9E%E8%99%9A%E6%96%B9%E6%B3%95"><span class="toc-text">二，虚方法和非虚方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%EF%BC%8C%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-text">三，方法调用指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%EF%BC%8C%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-text">四，方法重写的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%EF%BC%8C%E8%99%9A%E6%96%B9%E6%B3%95%E8%A1%A8"><span class="toc-text">五，虚方法表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80%E5%8F%8A%E6%A0%88%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">方法返回地址及栈的面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80"><span class="toc-text">一，方法返回地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8C%E4%B8%80%E4%BA%9B%E9%99%84%E5%8A%A0%E4%BF%A1%E6%81%AF"><span class="toc-text">二，一些附加信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%EF%BC%8C%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">三，面试题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%AD%90%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-text">⭐本地方法接口与本地方法栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3"><span class="toc-text">一，本地方法接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-text">二，本地方法栈</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%AD%90%E5%A0%86"><span class="toc-text">⭐堆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E5%A0%86%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-text">一，堆的核心概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8C%E8%AE%BE%E7%BD%AE%E5%A0%86%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E4%B8%8EOOM"><span class="toc-text">二，设置堆内存大小与OOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%EF%BC%8C%E5%B9%B4%E8%BD%BB%E4%BB%A3%E4%B8%8E%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-text">三，年轻代与老年代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%EF%BC%8C%E5%9B%BE%E8%A7%A3%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E4%B8%80%E8%88%AC%E8%BF%87%E7%A8%8B"><span class="toc-text">四，图解对象分配一般过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">总结：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MinorGC%EF%BC%8CMajorGC%EF%BC%8CFullGC"><span class="toc-text">MinorGC，MajorGC，FullGC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%EF%BC%8CMinorGC%EF%BC%8CMajorGC%EF%BC%8CFullGC"><span class="toc-text">一，MinorGC，MajorGC，FullGC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8CMinorGC%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="toc-text">二，MinorGC的触发条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%EF%BC%8C%E8%80%81%E5%B9%B4%E4%BB%A3GC%EF%BC%88MajorGC-x2F-FullGC%EF%BC%89%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="toc-text">三，老年代GC（MajorGC&#x2F;FullGC）触发条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%EF%BC%8CFullGC%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="toc-text">四，FullGC的触发机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E7%A9%BA%E9%97%B4%E5%88%86%E4%BB%A3%E6%80%9D%E6%83%B3%E3%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-text">堆空间分代思想、内存分配策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E5%A0%86%E7%A9%BA%E9%97%B4%E5%88%86%E4%BB%A3%E6%80%9D%E6%83%B3"><span class="toc-text">一，堆空间分代思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-text">二，内存分配策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%EF%BC%8C%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D"><span class="toc-text">三，空间分配担保</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%EF%BC%8C%E4%B8%BA%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%EF%BC%9ATLAB"><span class="toc-text">四，为对象分配内存：TLAB</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89TLAB%EF%BC%88Thread-Local-Allocation-Buffer%EF%BC%89%EF%BC%9F"><span class="toc-text">为什么有TLAB（Thread Local Allocation Buffer）？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFTLAB%EF%BC%9F"><span class="toc-text">什么是TLAB？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TLAB%E7%9A%84%E5%86%8D%E8%AF%B4%E6%98%8E"><span class="toc-text">TLAB的再说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E8%A1%A5%E5%85%85"><span class="toc-text">堆补充</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E6%A6%82%E8%BF%B0"><span class="toc-text">一，逃逸分析概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8C%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96"><span class="toc-text">二，逃逸分析代码优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D"><span class="toc-text">1.栈上分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%90%8C%E6%AD%A5%E7%9C%81%E7%95%A5"><span class="toc-text">2.同步省略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%A0%87%E9%87%8F%E6%9B%BF%E6%8D%A2"><span class="toc-text">3.标量替换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%EF%BC%8C%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E5%B0%8F%E7%BB%93%EF%BC%9A%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E5%B9%B6%E4%B8%8D%E6%88%90%E7%86%9F"><span class="toc-text">三，逃逸分析小结：逃逸分析并不成熟</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%AD%90%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-text">⭐方法区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E4%B8%8E%E5%90%A6%E7%9A%84%E8%A7%92%E5%BA%A6%E6%9D%A5%E7%9C%8B%EF%BC%9A"><span class="toc-text">从线程共享与否的角度来看：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E3%80%81%E5%A0%86%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB"><span class="toc-text">栈、堆、方法区的交互关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">方法区的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E6%96%B9%E6%B3%95%E5%8C%BA%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-text">一，方法区在哪里？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8C%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%90%86%E8%A7%A3"><span class="toc-text">二，方法区的基本理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%EF%BC%8CHotSpot%E4%B8%AD%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E6%BC%94%E8%BF%9B"><span class="toc-text">三，HotSpot中方法区的演进</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95%E5%8C%BA%E5%A4%A7%E5%B0%8F%E4%B8%8EOOM"><span class="toc-text">设置方法区大小与OOM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jdk7%E5%8F%8A%E4%BB%A5%E5%89%8D"><span class="toc-text">jdk7及以前</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK8%E4%BB%A5%E5%90%8E"><span class="toc-text">JDK8以后</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%BF%99%E4%BA%9BOOM"><span class="toc-text">如何解决这些OOM</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-text">方法区内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%88Method-Area%EF%BC%89%E5%AD%98%E5%82%A8%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">一，方法区（Method Area）存储什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8C%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-text">二，方法区的内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E4%BF%A1-%E6%81%AF"><span class="toc-text">类型信 息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%9F%EF%BC%88Field%EF%BC%89%E4%BF%A1%E6%81%AF"><span class="toc-text">域（Field）信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%EF%BC%88Method%EF%BC%89%E4%BF%A1%E6%81%AF"><span class="toc-text">方法（Method）信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#non-final%E7%9A%84%E7%B1%BB%E5%8F%98%E9%87%8F"><span class="toc-text">non-final的类变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E%EF%BC%9A%E5%85%A8%E5%B1%80%E5%B8%B8%E9%87%8F%EF%BC%88static-final%EF%BC%89"><span class="toc-text">补充说明：全局常量（static final）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%EF%BC%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0-VS-%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-text">三，运行时常量池 VS 常量池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%9F"><span class="toc-text">为什么需要常量池？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88"><span class="toc-text">常量池中有什么?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-text">运行时常量池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E4%BD%BF%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="toc-text">方法区使用举例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E6%BC%94%E8%BF%9B%E7%BB%86%E8%8A%82"><span class="toc-text">方法区的演进细节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B0%B8%E4%B9%85%E4%BB%A3%E8%A6%81%E8%A2%AB%E5%85%83%E7%A9%BA%E9%97%B4%E6%9B%BF%E4%BB%A3%EF%BC%9F"><span class="toc-text">一，为什么永久代要被元空间替代？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8CStringTable%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%B0%83%E6%95%B4%E4%BD%8D%E7%BD%AE%EF%BC%9F"><span class="toc-text">二，StringTable为什么要调整位置？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%EF%BC%8C%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%AD%98%E6%94%BE%E5%9C%A8%E9%82%A3%E9%87%8C%EF%BC%9F"><span class="toc-text">三，静态变量存放在那里？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-text">方法区的垃圾回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E6%80%BB%E7%BB%93%E5%8F%8A%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">方法区总结及面试题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%AD%90%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%8F%8A%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-text">⭐对象实例化及直接内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-text">对象实例化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">一，创建对象的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8C%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-text">二，创建对象的步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%AF%B9%E5%BA%94%E7%9A%84%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8A%A0%E8%BD%BD%E3%80%81%E9%93%BE%E6%8E%A5%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">1.判断对象对应的类是否加载、链接、初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%BA%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="toc-text">2.为对象分配内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A4%84%E7%90%86%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="toc-text">3.处理并发问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%86%E9%85%8D%E5%88%B0%E7%9A%84%E5%86%85%E5%AD%98"><span class="toc-text">4.初始化分配到的内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="toc-text">5.设置对象的对象头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%89%A7%E8%A1%8Cinit%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">6.执行init方法进行初始化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%99%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">给对象属性赋值的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">对象实例化的过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-text">对象内存布局</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E5%AF%B9%E8%B1%A1%E5%A4%B4%EF%BC%88Header%EF%BC%89"><span class="toc-text">一，对象头（Header）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8C%E5%AE%9E%E4%BE%8B%E6%95%B0%E6%8D%AE%EF%BC%88Instance-Data%EF%BC%89"><span class="toc-text">二，实例数据（Instance Data）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%EF%BC%8C%E5%AF%B9%E9%BD%90%E5%A1%AB%E5%85%85%EF%BC%88Padding%EF%BC%89"><span class="toc-text">三，对齐填充（Padding）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%EF%BC%9A"><span class="toc-text">小结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="toc-text">对象的访问定位</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE"><span class="toc-text">一，句柄访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8C%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%EF%BC%88HotSpot%E9%87%87%E7%94%A8%EF%BC%89"><span class="toc-text">二，直接指针（HotSpot采用）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%EF%BC%88Direct-Memory%EF%BC%89"><span class="toc-text">直接内存（Direct Memory）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E6%A6%82%E8%BF%B0"><span class="toc-text">一，直接内存概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8C%E9%9D%9E%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%AD%98%E5%8C%BA"><span class="toc-text">二，非直接缓存区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%EF%BC%8C%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%AD%98%E5%8C%BA"><span class="toc-text">三，直接缓存区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%AD%90%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E"><span class="toc-text">⭐执行引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E6%A6%82%E8%BF%B0"><span class="toc-text">一，执行引擎概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8C%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">二，执行引擎的工作流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%E5%92%8C%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">Java代码编译和执行过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E8%A7%A3%E9%87%8A%E5%99%A8%EF%BC%88Interpreter%EF%BC%89%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AFJIT%E7%BC%96%E8%AF%91%E5%99%A8%EF%BC%9F"><span class="toc-text">一，什么是解释器（Interpreter）？什么是JIT编译器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88Java%E6%98%AF%E5%8D%8A%E7%BC%96%E8%AF%91%E5%8D%8A%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%EF%BC%9F"><span class="toc-text">二，为什么Java是半编译半解释型语言？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E7%A0%81%E3%80%81%E6%8C%87%E4%BB%A4%E3%80%81%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80"><span class="toc-text">机器码、指令、汇编语言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E6%9C%BA%E5%99%A8%E7%A0%81"><span class="toc-text">一，机器码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8C%E6%8C%87%E4%BB%A4"><span class="toc-text">二，指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%EF%BC%8C%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="toc-text">三，指令集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%EF%BC%8C%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80"><span class="toc-text">四，汇编语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%EF%BC%8C%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80"><span class="toc-text">五，高级语言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C%E3%80%81C-%E6%BA%90%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">C、C++源程序执行过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%EF%BC%8C%E5%AD%97%E8%8A%82%E7%A0%81"><span class="toc-text">六，字节码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E5%99%A8"><span class="toc-text">解释器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E8%A7%A3%E9%87%8A%E5%99%A8%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-text">一，解释器工作机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8C%E8%A7%A3%E9%87%8A%E5%99%A8%E5%88%86%E7%B1%BB"><span class="toc-text">二，解释器分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%EF%BC%8C%E7%8E%B0%E7%8A%B6"><span class="toc-text">三，现状</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JIT%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-text">JIT编译器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%EF%BC%8CJava%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C%E5%88%86%E7%B1%BB"><span class="toc-text">一，Java代码的执行分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8CHotSpot-JVM%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="toc-text">二，HotSpot JVM执行方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%EF%BC%8C%E6%A6%82%E5%BF%B5%E8%A7%A3%E9%87%8A"><span class="toc-text">三，概念解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%EF%BC%8C%E7%83%AD%E7%82%B9%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%8E%A2%E6%B5%8B%E6%8A%80%E6%9C%AF"><span class="toc-text">四，热点代码及探测技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-text">方法调用计数器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%83%AD%E7%82%B9%E8%A1%B0%E5%87%8F"><span class="toc-text">热点衰减</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E8%BE%B9%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-text">回边计数器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%EF%BC%8CHotSpotVM-%E5%8F%AF%E4%BB%A5%E8%AE%BE%E7%BD%AE%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95"><span class="toc-text">五，HotSpotVM 可以设置程序执行方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%EF%BC%8CHotSpotVM%E4%B8%AD-JIT-%E5%88%86%E7%B1%BB"><span class="toc-text">六，HotSpotVM中 JIT 分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%88%B0%E6%9C%80%E5%90%8E1"><span class="toc-text">写到最后1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%88%B0%E6%9C%80%E5%90%8E2%EF%BC%9AAOT%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-text">写到最后2：AOT编译器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#StringTable"><span class="toc-text">StringTable</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-text">String的内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#StringTable%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%B0%83%E6%95%B4%EF%BC%9F"><span class="toc-text">StringTable为什么要调整？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">String的基本操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%93%8D%E4%BD%9C"><span class="toc-text">字符串拼接操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81"><span class="toc-text">字节码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%93%8D%E4%BD%9C%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94"><span class="toc-text">字符串拼接操作性能对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#intern-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">intern()的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%EF%BC%8Cintern%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9AJDK6-vs-JDK7-x2F-8"><span class="toc-text">一，intern的使用：JDK6 vs JDK7&#x2F;8</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8Cintern%E7%9A%84%E6%95%88%E7%8E%87%E6%B5%8B%E8%AF%95%EF%BC%9A%E7%A9%BA%E9%97%B4%E8%A7%92%E5%BA%A6"><span class="toc-text">二，intern的效率测试：空间角度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%EF%BC%8CStringTable%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-text">三，StringTable的垃圾回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%EF%BC%9AG1%E4%B8%AD%E7%9A%84String%E5%8E%BB%E9%87%8D%E6%93%8D%E4%BD%9C"><span class="toc-text">四：G1中的String去重操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%AE%97%E6%B3%95"><span class="toc-text">垃圾回收概述及算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0"><span class="toc-text">垃圾回收概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0"><span class="toc-text">一，垃圾回收概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE%EF%BC%9F"><span class="toc-text">1，什么是垃圾？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%8C%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">2，大厂面试题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE%EF%BC%9F"><span class="toc-text">3，什么是垃圾？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81GC"><span class="toc-text">4，为什么需要GC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%EF%BC%8C%E6%97%A9%E6%9C%9F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-text">5，早期垃圾回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%EF%BC%8CJava%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">6，Java垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#GC%E4%B8%BB%E8%A6%81%E5%85%B3%E6%B3%A8%E7%9A%84%E5%8C%BA%E5%9F%9F"><span class="toc-text">GC主要关注的区域</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5"><span class="toc-text">垃圾回收相关算法——标记阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%AD%98%E6%B4%BB%E5%88%A4%E6%96%AD"><span class="toc-text">对象存活判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C-%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5"><span class="toc-text">一， 标记阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95"><span class="toc-text">方式一：引用计数算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8"><span class="toc-text">循环引用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-text">方式二：可达性分析算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%EF%BC%88%E6%A0%B9%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E3%80%81%E8%BF%BD%E8%B8%AA%E6%80%A7%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%EF%BC%89"><span class="toc-text">可达性分析算法（根搜索算法、追踪性垃圾收集）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF"><span class="toc-text">基本思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-text">注意</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84finalization%E6%9C%BA%E5%88%B6"><span class="toc-text">对象的finalization机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E7%94%9F%E5%AD%98%E8%BF%98%E6%98%AF%E6%AD%BB%E4%BA%A1%EF%BC%9F"><span class="toc-text">一，生存还是死亡？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8C%E5%85%B7%E4%BD%93%E8%BF%87%E7%A8%8B"><span class="toc-text">二，具体过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MAT%E4%B8%8EJProfiler%E7%9A%84GC-Roots%E6%BA%AF%E6%BA%90"><span class="toc-text">MAT与JProfiler的GC Roots溯源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5"><span class="toc-text">垃圾回收相关算法——清除阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4"><span class="toc-text">标记清除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95%EF%BC%88Mark-Sweep%EF%BC%89"><span class="toc-text">标记-清除算法（Mark-Sweep）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">一，执行过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8C%E7%BC%BA%E7%82%B9"><span class="toc-text">二，缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%EF%BC%8C%E4%BD%95%E4%B8%BA%E6%B8%85%E9%99%A4"><span class="toc-text">三，何为清除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-text">复制算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%EF%BC%88Copying%EF%BC%89%E7%AE%97%E6%B3%95"><span class="toc-text">复制（Copying）算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-text">一，核心思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8C%E4%BC%98%E7%82%B9"><span class="toc-text">二，优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%EF%BC%8C%E7%BC%BA%E7%82%B9"><span class="toc-text">三，缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%EF%BC%8C%E7%89%B9%E5%88%AB%E7%9A%84"><span class="toc-text">四，特别的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%94%EF%BC%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">五，应用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E5%8E%8B%E7%BC%A9%EF%BC%88%E6%95%B4%E7%90%86%EF%BC%89%E7%AE%97%E6%B3%95"><span class="toc-text">标记-压缩（整理）算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E5%8E%8B%E7%BC%A9%EF%BC%88%E6%88%96%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E3%80%81Mark-Compact%EF%BC%89%E7%AE%97%E6%B3%95"><span class="toc-text">标记-压缩（或标记-整理、Mark-Compact）算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B-1"><span class="toc-text">一，执行过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8C%E6%8C%87%E9%92%88%E7%A2%B0%E6%92%9E%EF%BC%88Bump-the-Pointer%EF%BC%89"><span class="toc-text">二，指针碰撞（Bump the Pointer）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%EF%BC%8C%E4%BC%98%E7%82%B9-1"><span class="toc-text">三，优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%EF%BC%8C%E7%BC%BA%E7%82%B9"><span class="toc-text">四，缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%EF%BC%9A-1"><span class="toc-text">小结：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-text">分代收集算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E5%B9%B4%E8%BD%BB%E4%BB%A3%EF%BC%88Young-Gen%EF%BC%89"><span class="toc-text">一，年轻代（Young Gen）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8C%E8%80%81%E5%B9%B4%E4%BB%A3%EF%BC%88Tenured-Gen%EF%BC%89"><span class="toc-text">二，老年代（Tenured Gen）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E3%80%81%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95"><span class="toc-text">增量收集算法、分区算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-text">增量收集算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-text">一，基本思想</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8C%E7%BC%BA%E7%82%B9-1"><span class="toc-text">二，缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95"><span class="toc-text">分区算法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-text">垃圾回收相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%EF%BC%8CSystem-gc-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">一，System.gc()的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%B8%8ESTW"><span class="toc-text">内存溢出与内存泄露与STW</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%EF%BC%88OOM%EF%BC%89"><span class="toc-text">一，内存溢出（OOM）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%88Memory-Leak%EF%BC%89"><span class="toc-text">二，内存泄漏（Memory Leak）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%EF%BC%8CStop-The-World"><span class="toc-text">三，Stop The World</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="toc-text">垃圾回收的并行与并发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%EF%BC%88Concurrent%EF%BC%89"><span class="toc-text">并发（Concurrent）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%EF%BC%88Parallel%EF%BC%89"><span class="toc-text">并行（Parallel）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91-vs-%E5%B9%B6%E8%A1%8C"><span class="toc-text">并发 vs 并行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="toc-text">垃圾回收的并发与并行</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E5%B9%B6%E8%A1%8C%EF%BC%88Parallel%EF%BC%89"><span class="toc-text">一，并行（Parallel）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8C%E4%B8%B2%E8%A1%8C%EF%BC%88Serial%EF%BC%89"><span class="toc-text">二，串行（Serial）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%EF%BC%8C%E5%B9%B6%E5%8F%91%EF%BC%88Concurrent%EF%BC%89"><span class="toc-text">三，并发（Concurrent）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%82%B9%E4%B8%8E%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F"><span class="toc-text">安全点与安全区域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E5%AE%89%E5%85%A8%E7%82%B9"><span class="toc-text">一，安全点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8C%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F%EF%BC%88Safe-Resion%EF%BC%89"><span class="toc-text">二，安全区域（Safe Resion）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E8%BD%AF%E5%BC%B1%E8%99%9A%E5%BC%95%E7%94%A8"><span class="toc-text">强软弱虚引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E5%BC%BA%E5%BC%95%E7%94%A8%EF%BC%88Strong-Reference%EF%BC%89%E2%80%94%E2%80%94%E4%B8%8D%E5%9B%9E%E6%94%B6"><span class="toc-text">一，强引用（Strong Reference）——不回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8C%E8%BD%AF%E5%BC%95%E7%94%A8%EF%BC%88Soft-Reference%EF%BC%89%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E5%8D%B3%E5%9B%9E%E6%94%B6"><span class="toc-text">二，软引用（Soft Reference）——内存不足即回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%EF%BC%8C%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%88Weak-Reference%EF%BC%89%E2%80%94%E2%80%94%E5%8F%91%E7%8E%B0%E5%8D%B3%E5%9B%9E%E6%94%B6"><span class="toc-text">三，弱引用（Weak Reference）——发现即回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%EF%BC%8C%E8%99%9A%E5%BC%95%E7%94%A8%EF%BC%88Phantom-Reference%EF%BC%89%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E5%9B%9E%E6%94%B6%E8%B7%9F%E8%B8%AA"><span class="toc-text">四，虚引用（Phantom Reference）——对象回收跟踪</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%EF%BC%8C%E7%BB%88%E7%BB%93%E5%99%A8%E5%BC%95%E7%94%A8"><span class="toc-text">五，终结器引用</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/coderbin/ce7050cc.html" title="SpringSecurity + oauth2 + jwt"><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/asdsafsdafwfwsrght.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringSecurity + oauth2 + jwt"/></a><div class="content"><a class="title" href="/coderbin/ce7050cc.html" title="SpringSecurity + oauth2 + jwt">SpringSecurity + oauth2 + jwt</a><time datetime="2023-02-08T04:51:52.000Z" title="发表于 2023-02-08 12:51:52">2023-02-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/coderbin/739cefcf.html" title="EasyExcelDemo"><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/rqqqwegbs.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="EasyExcelDemo"/></a><div class="content"><a class="title" href="/coderbin/739cefcf.html" title="EasyExcelDemo">EasyExcelDemo</a><time datetime="2023-02-08T04:47:27.000Z" title="发表于 2023-02-08 12:47:27">2023-02-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/coderbin/bdc467cb.html" title="Vue路由History模式下页面报404错误"><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/Benefits-of-Using-VUE.JS.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vue路由History模式下页面报404错误"/></a><div class="content"><a class="title" href="/coderbin/bdc467cb.html" title="Vue路由History模式下页面报404错误">Vue路由History模式下页面报404错误</a><time datetime="2023-01-14T13:24:49.000Z" title="发表于 2023-01-14 21:24:49">2023-01-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/coderbin/883768d.html" title="微信小程序轮播图美化"><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/ghfghfghf.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="微信小程序轮播图美化"/></a><div class="content"><a class="title" href="/coderbin/883768d.html" title="微信小程序轮播图美化">微信小程序轮播图美化</a><time datetime="2023-01-14T13:20:05.000Z" title="发表于 2023-01-14 21:20:05">2023-01-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/coderbin/8c30c2b2.html" title="Netty网络编程自用资料"><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/359/nettytupian.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Netty网络编程自用资料"/></a><div class="content"><a class="title" href="/coderbin/8c30c2b2.html" title="Netty网络编程自用资料">Netty网络编程自用资料</a><time datetime="2023-01-14T13:15:01.000Z" title="发表于 2023-01-14 21:15:01">2023-01-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By coderbin</div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn"><span>粤ICP备2022055363号-1</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>